[{"title":"cssText批量修改dom的样式","date":"2019-11-26T03:09:34.000Z","path":"cssText-operate-style.html","text":"之前用js修改dom的样式一般都是采用以下的方式：1234const element = this.$refs.target;element.style.width = '200px';element.style.height = '100px';element.style.color = 'red'; 样式不多的话，性能还可以，但是如果样式特别多，或者涉及到动画的时候，性能会不太理想。前者每一次设置都会reflow一次，后者之后reflow一次。早上阅读某开源框架的源码时发现了一种用js覆写css的方式，查阅之后发现兼容性和性能都超级棒，这里记录一下以加深记忆。 功能和语法MDN介绍: The cssText property of the CSSStyleDeclaration interface returns or sets the text of the element’s inline style declaration only. To be able to set a stylesheet rule dynamically, see Using dynamic styling information. 语法：12345const element = this.$refs.target;// 获取内联样式,好像只能获取到内联样式，写在style标签和css文件中的样式需要使用 window.getComputedStyle 获取alert(element.style.cssText)// 覆写样式element.style.cssText = 'width:200px;height:100px;color:red;'; 使用cssText会覆盖之前的所有样式，所以如果要保留之前的样式，则需要先获取到已有样式，然后追加新样式。 兼容性各浏览器目前都兼容（包括IE6,7,8）cssText的方式设置样式，但是在IE下，累加的时候回丢失之前的样式中最后一个;， 所有需要做一下兼容，可以采用正则的方式对获取到的已有样式进行匹配。获取已有属性可以用window.getComputedStyle，IE浏览器用document.currentStyle，此API仅用来覆写样式即可。 使用示例1234567891011121314// 获取原有样式, IE 用 dom元素.currentStyle 火狐谷歌用window.getComputedStyle(dom, null)const getStyle = (function()&#123; if(window.document.currentStyle) &#123; return (dom, attr) =&gt; dom.currentStyle[attr]; &#125; else &#123; return (dom, attr) =&gt; getComputedStyle(dom, false)[attr]; &#125;&#125;)()const element = document.querySelecter('#target');let widthExists = getStyle(element, 'width');// 去除pxlet width = Number(widthExists.replace(/\\%/g, ''));element.style.cssText += `;width: $&#123;widthExists + 200&#125;px;` 这里用到了getComputedStyle和currentStyle，其中currentStyle是IE浏览器的API，getComputedStyle是google等主流浏览器都支持的获取已有样式的接口。该方法有两个参数，第一个参数是要获取样式的dom节点，第二个参数一般可设置为 null或fasle，仅在获取伪类元素时传入伪类的值，返回值是一个只读的对象，里面包含了该dom元素的样式。 123456789101112131415&lt;style&gt; h3::after &#123; content: \"rocks!\"; &#125;&lt;/style&gt;&lt;h3&gt;generated content&lt;/h3&gt;&lt;script&gt; let h3 = document.querySelector('h3'), result = getComputedStyle(h3, '::after').content; alert(`the generated content is: $&#123;result&#125;`); console.log(`the generated content is: $&#123;result&#125;`); // the generated content is: \"rocks!\"&lt;/script&gt;","tags":[{"name":"css","slug":"css","permalink":"https://mhynet.cn/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"}]},{"title":"vps搭建指南","date":"2019-09-23T08:00:56.000Z","path":"vps-deploy-guide.html","text":"上周发现我的vps又被禁了，又得重新部署。每次部署vps都要google搜索相关命令，特别麻烦，这里记录一下搭建vps的简单步骤吧。 安装shadowsocks命令12345wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 安装过程中根据命令行交互选择服务器类型（如Shadowsocks-libev）、端口、密码、加密方法等。如Shadowsocks-libev类型的服务的配置文件在 /etc/shadowsocks-libev/config.json，可以编辑配置。 查看状态1/etc/init.d/shadowsocks-libev status 重启服务1/etc/init.d/shadowsocks-libev restart 关闭服务1/etc/init.d/shadowsocks-libev stop 开启服务1/etc/init.d/shadowsocks-libev start 参考:科学上网的终极姿势：在 Vultr VPS 上搭建 Shadowsocks美国 VPS Hostwinds 购买流程新手教程一键安装最新内核并开启 BBR 脚本新购VPS后的设置及网站迁移步骤2019年最好的国外VPS推荐","tags":[{"name":"vps","slug":"vps","permalink":"https://mhynet.cn/tags/vps/"}]},{"title":"vue+element后台管理搜索表单缓存","date":"2019-06-22T02:41:53.000Z","path":"vue-element-admin-search-query-cache.html","text":"在后台管理系统中经常会有这样的需求，从列表页跳转到详情页再返回列表后希望保持之前的查询条件，此类需求一般有以下几种处理方式可以参考。 新页面打开详情页偷懒的做法是打开详情页时在新窗口打开，这样就可以保持列表页的搜索参数了，但是这样往往会打开很多的新页面，用户需要在多个页面直接来回切换操作繁琐，而且有个关键的问题是切换到列表页标签后数据并不是最新的，因为刚才在详情页已经编辑过数据了。我负责开发维护的后台管理系统在新建和编辑时是在不同的路由下调用同一个详情页组件来实现的，所以在编辑和新建请求完成之后详情页是否直接关闭还是让用户手动关闭是一个问题，新建页如果留给用户处理会连续创建多条相同数据的情况发生。而且连续打开多个页面标签页违背了单页面应用的初衷， 基于这些问题，我放弃了这种方式。基于vue技术栈，在新标签页打开详情页主要有两种实现方式，一种是 router-link标签加target=&quot;_blank&quot;属性，其原理是a标签的target属性。1&lt;router-link :to=\"&#123;name: 'detail'&#125;\" target=\"_blank\"&gt;&lt;/router-link&gt; 另一种方式是js控制，其绑定的DOM元素渲染之后不再是a标签，而是一个button，页面跳转主要是基于window对象的功能实现的。1234567891011121314&lt;template&gt; &lt;el-button @click=\"handleToDetail(params)\"&gt;detail&lt;/el-button&gt;&lt;/template&gt;&lt;script&gt;export default&#123; methods: &#123; // 参数可以自定义,一般包含主键id等性质的参数 handleToDetail(params) &#123; const routerData = this.$router.resolve(&#123;name: 'detail', query: &#123;params: params&#125;&#125;) window.open(routerData.href, \"_blank\") &#125; &#125;&#125;&lt;/script&gt; 其中的vue-router特性不多说，具体可以查阅官方文档。 query携带查询参数另一种实现方式是在路由跳转时在路由的query中把参数携带过去，返回时再带回来，列表页在mounted生命周期内对query进行处理，如果query中携带了查询参数则使用该查询参对数据进行赋值然后查询即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div&gt; &lt;el-form :model=\"params\" inline&gt; &lt;el-from-item prop=\"title\"&gt; &lt;el-input v-model=\"params.title\"&gt;&lt;/el-input&gt; &lt;/el-from-item&gt; &lt;el-from-item prop=\"title\"&gt; &lt;el-input v-model=\"params.title\"&gt;&lt;/el-input&gt; &lt;/el-from-item&gt; &lt;el-from-item prop=\"title\"&gt; &lt;el-input v-model=\"params.title\"&gt;&lt;/el-input&gt; &lt;/el-from-item&gt; &lt;el-form-item&gt; &lt;el-button @click=\"handleToDetail\"&gt;detail&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; params: &#123; id: '', title: '', desc: '', imgUrl: '' &#125; &#125; &#125;, mounted() &#123; this.getSearchQueryIfExists() this.handleSearch() &#125;, methods: &#123; // 路由跳转时把搜索表单参数转换成字符串赋值给searchQuyery携带过去 ，跳转回来时直接带回来 handleToDetail() &#123; const params = JSON.stringify(this.params) this.$router.push(&#123;name: 'detail', query: &#123; id: this.params.id, searchQuyery: params &#125;&#125;) &#125;, // 进入列表时，如果query中含有searchQuyery字段，则转换成对象赋值给查询对象参数即可 getSearchQueryIfExists() &#123; const &#123; query = &#123;&#125; &#125; = this.$router.query if(query.hasOwnProperty('searchQuyery')) &#123; const stashQuery = JSON.parse(query.searchQuyery) this.params = stashQuery &#125; &#125; &#125;, // 发送查询http请求 handleSearch() &#123; // 。。。。 &#125;&#125;&lt;/script&gt; 这种实现方式可以基本满足要求，在页面较少或者项目中没有引入vuex时可以使用。缺点是需要缓存的页面较多时，需要重复进行处理，比较繁琐。 使用vuex缓存查询参数如果需要缓存的页面较多，且系统中已经引入了vuex，则可以使用vuex缓存的方式来实现查询参数缓存。首先需要把查询参数写入vuex中, 在store目录下创建一个用于缓存路由查询参数的文件，例如routerCache.js123456789101112131415161718// routerCache.jsconst routeCache = &#123; state: &#123; cachedRoutes: &#123;&#125; &#125;, mutations: &#123; SET_CACHED_ROUTES: (state, route) =&gt; &#123; const &#123; name, query &#125; = route state.cachedRoutes[name] = query &#125; &#125;, actions: &#123; setCachedRoutes(&#123; commit &#125;, route) &#123; commit('SET_CACHED_ROUTES', route) &#125; &#125;&#125;export default routeCache 在getter中引入。12345// getter.jsconst getters = &#123; cachedRoutes: state =&gt; state.routeCache.cachedRoutes,&#125;export default getters 其中，name是路由的name属性值，查询参数query保存在name中，当然也可以使用路由的path做为键，区别在于是否区分动态路由。query可以是对象，也可以是JSON化的字符串，建议使用JSON字符串进行保存。接下来是在查询时调用actions中的setCachedRoutes()方法保存页面查询参数和进入页面后获取getter中缓存的值。这部分涉及vuex的使用方式，不太清楚可以查阅官方文档。这部分我们可以使用mixin进行封装，暴露出两个方法来保存和获取缓存即可。如下所示：123456789101112131415161718192021222324252627282930313233343536373839// mixins/queryCache.jsimport &#123; mapActions, mapGetters &#125; from 'vuex'export default &#123; data() &#123; return &#123; searchKey: '' // 每个页面查询表单`model`绑定的值可能不一样，使用此变量来接收查询对象的 key 值 &#125; &#125;, computed: &#123; ...mapGetters(['cachedRoutes']) &#125;, methods: &#123; ...mapActions(['setCachedRoutes']), /** * 设置路由缓存相关配置 * @param: queryKey 页面搜索表单对象的key */ setSearchQuery(queryKey) &#123; const name = this.$route.name if (typeof this.setCachedRoutes === 'function') &#123; this.setCachedRoutes(&#123; name: name, query: JSON.stringify(this[queryKey]) &#125;) &#125; &#125;, /** * 获取路由缓存相关配置 * @param: queryKey 页面搜索表单对象的key */ getSearchQuery(queryKey) &#123; // 如果使用 路由 的 name属性缓存的话，这里就取当前页面路由的 name值，如果使用了 path 缓存替换即可 const name = this.$route.name const cachedRoutes = this.cachedRoutes || &#123;&#125; if (cachedRoutes.hasOwnProperty(name)) &#123; const target = JSON.parse(cachedRoutes[name]) this[queryKey] = Object.assign(&#123;&#125;, target） &#125; &#125; &#125;&#125; 如果需要缓存查询参数对象之外的方法，则需要在getSearchQuery和setSearchQuery中添加特殊情况下的判断逻辑即可。其中setSearchQuery可以在点击搜索按钮或发送查询请求时进行调用，区别在是否需要缓存分页查询相关参数。getSearchQuery必须在created或mounted生命周期中掉用，将缓存的数据赋值给查询对象之后调用页面的查询请求，这样就实现了路由跳转的查询数据缓存。页面中调用方法代码如下：12345678910111213141516171819202122232425262728293031import CacheQuery from '../mixins/queryCache' // 具体路径按项目实际路径export default &#123; data() &#123; reutrn &#123; // 查询表单数据对象 params: &#123; &#125; &#125; &#125;， mounted() &#123; // 获取vuex中的缓存，赋值 this.getSearchQuery('params') // 然后按缓存的参数查询 this.getList() &#125;, methods: &#123; // 搜索点击事件监听 handleSearch() &#123; // 缓存搜索参数 this.setSearchQuery('params') // 查询数据 this.getList() &#125;, async getList() &#123; // 获取数据发送请求 let resp = await axios.get('/api/get/list') &#125; &#125;&#125; 需要注意的是，如果要缓存分页参数，可能会发现一个问题。示例如下：12345678// 查询参数对象:searchParams: &#123; id: '', title: '', status: '', current_page: 1, // 当前页 page_size: 10， // 每页多少数据&#125; 分页组件：1234&lt;el-pagination :total=\"page.total\" :current-page=\"searchParams.page_index\" @current-change=\"handleCurrentChange\"/&gt; 如果查询参数中包含了分页组件中的两个参数，在调用了getSearchQuery方法对其进行赋值之后，即便发送请求时的current_page是2，el-pagination组件中显示的仍然是在页面的data中初始化时的默认值，研究了element分页组件的源码，发现其改变current-page只能通过监听current-change来实现，而在上文中缓存了数据之后直接赋值是无法实现响应的, 如下图: 分享告一段落啦，如果您有其他的实现方式可以留言交流啊，感谢！","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://mhynet.cn/tags/vue/"},{"name":"element","slug":"element","permalink":"https://mhynet.cn/tags/element/"}]},{"title":"pynongo使用笔记","date":"2019-06-11T03:38:12.000Z","path":"pynongo-notes.html","text":"前段时间学习了python爬虫，然后爬取了必应壁纸、拉钩、小红唇视频和评论等，其中也使用了mongodb数据库存储数据。 工作电脑和家里电脑都实现了壁纸每分钟实时更新，海量的背景图片，基本不重复，每天中午休息时喜欢盯着屏幕发呆，哈哈😁。其中除了用到的除了基本的爬虫至少，还有pymongo将爬取的数据存储到数据库，不会因为官方更新而丢失早期的图片信息，也用到了shell脚本和crontab定时任务，每周一中午定时爬取，然后下载图片，非常nice啊。更多脚本可以去github看到，自动执行的shell脚本为项目目录下的 wallpaper.sh文件。 这里记录一下pymongo使用笔记，避免下次使用时再去找文档。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 引入pymongoimport pymongo# 创建连接client = pymongo.Conection('127.0.0.1', 27017)client = pymongo.Conection(host='127.0.0.1', port=27017)# 连接数据库db = client.bing# 或db = client['bing']# 其中的`bing`是所创建的数据库的名称。# 或dbName = 'xhc'db = client[dbName]# 连接集合collection = db.video# 或collection = db['video']# 查看全部集合名称db.collection_names()# 查找集合的记录db.bing.find()for doc in db.test.find(): print(doc)db.bing.find_one(&#123;x: 1&#125;)db.bing.find_mangy(&#123;&#125;)db.bing.count_document(&#123;x: 1&#125;)# 插入数据db.bing.insert_one(&#123;x: 1&#125;)db.bing.insert_many([&#123;'x': i&#125; for i in range(2)])# 替换db.bing.replace_one(&#123;x: 1&#125;, &#123;y: 1&#125;)# 更新# update 后面的操作符同 mongodb 原生的操作符db.bing.update_one(&#123;x: 1&#125;, &#123;'$inc': &#123;x: 3&#125;&#125;)db.bing.find_one_and_update(&#123;'_id': 665&#125;, &#123;'$inc': &#123;'count': 1&#125;, '$set': &#123;'done': True&#125;&#125;)db.bing.find_one_and_update(&#123;'_exists': False&#125;, &#123;'$inc': &#123;'count': 1&#125;&#125;)db.bing.find_one_and_update( &#123; '_id': 'userid' &#125;, &#123; '$inc': &#123;'seq': 1&#125;&#125;, projection=&#123;'seq': True, '_id': False&#125;, upsert=True, return_document=ReturnDocument.AFTER)# 删除db.bing.delete_one(&#123;x: 1&#125;)db.bing.delete_many(&#123;'x': 1&#125;)db.bing.find_one_and_delete(&#123;'x': 1&#125;)db.bing.find_one_and_delete(&#123;'x': 1&#125;, sort=[('_id', pymongo.DESCENDING)])# 新建索引db.bing.create_index(\"mike\") 更多内容可以参考官方文档。参考文档： http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.delete_one","tags":[{"name":"python","slug":"python","permalink":"https://mhynet.cn/tags/python/"},{"name":"mongodb","slug":"mongodb","permalink":"https://mhynet.cn/tags/mongodb/"}]},{"title":"elementUI表单使用自定义组件并获取子组件验证","date":"2019-04-20T03:04:54.000Z","path":"elementUI-component-validate.html","text":"最近工作中很多次遇到一种情况，表单元素中某个字段是对象组成的数组，需要使用自定义组件来遍历数组，每个数组元素对象中的许多字段需要单独封装成自定义组件，在父组件中使用v-model方式来实现响应式的调用。这样做的好处是可以利于组件独立运行环境的特性，有效的区分了父组件表单中数组字段下各个对象的独立。 假如父组件中的表单数据是这种格式的：12345678910111213141516171819202122&lt;script&gt; data() &#123; return &#123; info: &#123; id: '', start_time: '', end_time: '', items: [&#123; title: '', desc: '', type: '', img_url: '' &#125;, &#123; title: '', desc: '', type: '', img_url: '' &#125;] &#125; &#125; &#125;&lt;/script&gt; 要使用elementUI的 form组件来实现表单的数据渲染，其中items部分最合理的方式是抽离出单独的组件，在父组件中遍历该数组字段，每一项单独渲染该子组件。 子组件定义假设子组件这样定义：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;template&gt; &lt;div&gt; &lt;el-form ref=\"item\" :model=\"content\" :rules=\"rules\"&gt; &lt;el-form-item prop=\"title\" label=\"title\"&gt; &lt;el-input v-model=\"content.title\"/&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=\"desc\" label=\"desc\"&gt; &lt;el-input v-model=\"content.desc\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=\"type\" label=\"type\"&gt; &lt;el-input v-model=\"content.type\" /&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=\"img_url\" label=\"img\"&gt; &lt;el-input v-model=\"content.img_url\"/&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Child', props: &#123; value: &#123; type: Object, default() &#123; return &#123; title: '', desc: '', type: '', img_url: '' &#125; &#125; &#125;, index: &#123; type: Number, default: null &#125; &#125;, data() &#123; return &#123; content: &#123; ...this.value &#125;, rules: &#123; title: [&#123;required: true, trigger: 'blur'&#125;], desc: [&#123;required: true, trigger: 'blur'&#125;], type: [&#123;required: true, trigger: 'blur'&#125;], img_url: [&#123;required: true, trigger: 'blur'&#125;], &#125; &#125; &#125;, computed: &#123; // 定义该变量是为了便于监听对象的变化，特别是多层嵌套的对象非常有效 contentStr() &#123; return JSON.stringify(this.content) &#125; &#125;, watch: &#123; // 监听对象每个字段的改变，另一种方法是使用deep属性，具体可以查阅vue文档 contentStr(value) &#123; this.update() &#125; &#125;, methods: &#123; update() &#123; // input 事件父组件可以监听到，具体下文会介绍，这里是把子组件的变更通过事件告诉父组件，实现子组件向父组件的数据传递 this.$emit('input', this.content) &#125;, formValidate() &#123; let flag = false this.$refs['item'].validate(valid =&gt; &#123; flag = valid // 如果需要进行信息提示 if (!valid) &#123; this.$message(`第$&#123;index&#125;条数据未填写完!`) &#125; &#125;) return flag &#125; &#125;&#125;&lt;/script&gt; 自定义组件中props中的value属性是vue默认的，可以接收调用时绑定在v-model上的属性，子组件中给value设置默认值可以避免一些初始化时缺少字段的报错。为了让v-model正常工作，这个组件内必须： 将其value特性绑定到一个名为value的prop上 将其input事件触发时，将新的值通过自定义的input事件抛出123&lt;input v-model=\"title\"&gt;&lt;!-- 等价于 --&gt;&lt;input v-bind:value=\"title\" v-on:input=\"title = $event.target.value\"/&gt; 子组件需要实时的把数据的变化告诉父组件，所以需要wath数据的变化，如果传给子组件的数据只是简单的对象类型，即对象的字段都是简单类型，可以直接使用vue中watch的高级用法，定义handler方法，使用immediaate和deep属性，具体可以参考Vue.js中 watch 的高级用法,更标准的使用方式可以查阅官方文档。在本文例子中可以这样使用：12345678910&lt;script&gt; watch: &#123; content:&#123; handler(newVal, oldVal) &#123; this.$emit('input', this.content) &#125;, deep: true // deep属性默认为false, 表示十分深度监听 &#125; &#125;&lt;/script&gt; 介绍完了子组件中数据的处理，接下来说一下父组件中如何使用。 父组件调用自定义组件前面已经定义了自定义组件，可以支持数据的双向绑定，父组件调用自定义子组件时可以像elementUI中的表单组件一样使用，示例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;el-form :model=\"info\" ref=\"form\"&gt; &lt;!-- 为简化类型，这里无关的字段都使用el-input --&gt; &lt;el-form-item prop=\"start_time\" lable=\"start time\"&gt; &lt;el-input v-model=\"info.start_time\"/&gt; &lt;/el-form-item&gt; &lt;el-form-item prop=\"end_time\" lable=\"end time\"&gt; &lt;el-input v-model=\"info.end_time\"/&gt; &lt;/el-form-item&gt; &lt;!-- 遍历数组，循环调用自定义子组件 --&gt; &lt;div v-for=\"(content, index) in info.items\" v-show=\"(currentIndex - 1) === index\" :key=\"index\"&gt; &lt;el-form-item prop=\"item\" lable=\"item\"&gt; &lt;st-item v-model=\"info.items[index]\" :index=\"index\" :ref=\"index + '_item'\"/&gt; &lt;/el-form-item&gt; &lt;/div&gt; &lt;/el-form&gt;&lt;/template&gt;&lt;script&gt;import Item from './item.vue'export default &#123; name: 'Parents', components: &#123; 'st-item': Item &#125;, data() &#123; return &#123; currentIndex: 0, // 控制显示当前的是哪个item info: &#123; id: '', start_time: '', end_time: '', items: [&#123; title: '', desc: '', type: '', img_url: '' &#125;, &#123; title: '', desc: '', type: '', img_url: '' &#125;] &#125; &#125; &#125;, methods: &#123; &#125;&#125;&lt;/script&gt; 子组件表单验证接下来说如何在父组件提交数据时验证子组件的是否已通过验证。刚才子组件中定义了一个方法 formValidate, 该方法会将子组件的验证结果返回，在父组件中调用该方法即可获得子组件的验证结果。12345678910methods: &#123; submit() &#123; // 调用子组件验证，验证结果赋值给isValid变量 let isValid = Object.keys(this.info.item).every(key =&gt; this.$refs[key + '_item'].formValidate()) if (!isValid) &#123; return false &#125; // .. &#125;&#125; 参考文献： https://blog.csdn.net/ligang2585116/article/details/79475652","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://mhynet.cn/tags/vue/"},{"name":"element","slug":"element","permalink":"https://mhynet.cn/tags/element/"}]},{"title":"linux学习笔记(5)","date":"2019-03-14T05:15:31.000Z","path":"linux-note-5.html","text":"at 一次性定时任务at服务是否安装 chkconfig –list | grep atd at服务重启 service atd restart at的访问控制 /etc/at.allow 白名单/etc/at.deny 黑名单 （对root不起作用） 白名单比黑名单优先级高。如果这两个文件都不存在，那么只有root用户可以使用at命令 at使用方法: at [选项] 时间 选项： -m: 当at工作完成后，无论是否命令有输出，都用email通知执行at命令的用户 -c：工作号\b：显示该at工作的实际内容 时间：HH:MM 03:23HH:MM: YYYY-MM=DD 02:32 2018-09-21… eg:123#在2分钟后执行脚本hello.shat now +2 minutesat &gt; /home/mhy/work/hello.sh &gt;&gt; /home/mhy/work/log_hello.log atq #查询当前服务器上的at工作、 atrm [工作号] # 删除指定的at任务 crontab 循环定时任务crond服务 操作crond服务123456# /sbin/serviceservice crond start #启动服务service crond stop #关闭服务service crond restart #重启服务service crond reload #重新载入配置service crond stats # 查看crontab服务状态 操作crond服务需要root权限 查看crond服务是否在运行： 1chkconfig --list | grep cron 加入开机自动启动 1234# 查看crond服务是否已设置为开机启动ntsysv# 加入开机自动启动chkconfig --level 35 crond on crontab 命令 crontab [选项] (参数) 选项： -e: 编辑当前用户crontab定时任务 -l: 查询当前用户crontab定时任务 -r: 删除当前用户所有的crontab定时任务 -u&lt;用户名&gt;: 指定要设定时任务的用户名称 参数： crontab文件： 指定包含\b待执行任务的crontab文件 绑定当前登录用户，要确保没有超出当前用户权限。 linux下的任务调度分为两类：系统任务调度和用户任务调度。注意: 因为用户的定时任务是和用户绑定的，所有使用crontab -e来设置，系统定时任务(root权限)是编辑/etc/crontab来设置的， 而且必须指定用户。 系统任务调度系统周期性所要执行的工作，比如写缓存数据到硬盘、\b日志清理等。在/etc目录下有个crontab文件，这个就是系统任务调度的配置文件。/etc/crontab默认有以下内容：123456789101112131415SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootHOME=/# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed eg:123401 * * * * root run-parts /etc/cron.hourly02 4 * * * root run-parts /etc/cron.daily22 4 * * 0 root run-parts /etc/cron.weekly42 4 1 * * root run-parts /etc/cron.monthly 前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。通过/etc/crontab配置文件来设置定时任务是比较好的方式。 执行系统的定时任务的方法有两种： 把需要定时执行的脚步复制到/etc/cron.{daily,weekly,montyly}目录的任意一个 修改/etc/crontab配置文件 用户任务调度用户定期执行的工作，比如数据备份、定时邮件提醒等。 用户可以使用crontab工具来定制自己的计划任务。所有永不定义crontab文件都保存在/var/spool/cron目录中。其文件名与用户名一致，使用\b者权限文件如下：123/etc/cron.deny 该文件中所有用户不允许使用crontab命令（黑名单）/etc/cron.allow 该文件中所列用户允许使用crontab命令 （白名单）/etc/spool/cron/ 所有用户crontab文件存放的目录，以用户名命名 白名单比黑名单优先级高， 白名单的用户一定有权限，黑名单的用户如果在\b白名单\b，则有权限；如果黑名单的用户不在白名单，则没有权限。所以只需要把需要\b限制权限的用户加入到黑名单就可以了，白名单不需要单独添加用户，除了优先级外，有权限的用户\b一般都比限制权限的用户多，加黑名单比较方便。 crontab文件的含义用户所建立的crontab文件中，每一行都代表一条任务，每行的每个字段代表一项设置，它的格式\b一共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：1* * * * * [执行的任务] 顺序： miniute hour day month week command其中： minute: 一小时当中的第几分钟, 范围0-59之间的任意整数 hour: 一天当中的第几个小时, 范围是0-23之间的任意整数 day: 一个月当中的第几天, 范围是1-31之间的任意整数 month: 一年当中的第几个月, 范围是1-12之间的任意整数 week: 一周当中的星期几, 范围是0-7(0和7都代表星期日)之间的任意整数 command: 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件 以上各个字段中， 还可以使用以下特殊字符： 星号*: 代表所有可能的值，比如minute字段为*代表每分钟执行一次 逗号,: 逗号隔开的值指定一个列表范围，比如: 1,2,3,5,6,列表中的每个时间点执行一次 中杠-: 可以用整数之间的中杠表示一个整数范围，如：2-5表示2,3,4,5 正斜线/: 正斜线指定时间的间隔频率， 如0-23/2表示每两个小时执行一次，minute字段的*/10表示每十分钟执行一次 使用以下命令设置定时任务:12crontab -e#进入crontab编辑界面。会打开vim编辑，按刚才的格式设置定时任务 crontab定时任务实例：1234567891011121314* * * * * command # 每一分钟执行一次3,15 * * * * command # 每小时内在第3和第5分钟执行3,15 8-11 * * * command # 上午8点到11点的第3和第15分钟执行3，15 8-11 */2 * * command #每隔两天的上午8点到11点的第3和第5分钟执行3，15 8-11 * * 1 command #每个星期一的上午8点到11点的第3和第5分钟执行30 21 * * * service /etc/init.d/smb restart #每晚的21:30重启smb45 4 1,10,22 * * /etc/init.d/smb restart #每月的1、10、22日重启smb30 4 * * 6,7 /etc/init.d/nginx restart #没周六日的4:30重启nginx0,30 18-23 * * * /etc/init.d/nginx restart #每天18:00至23:00之间每隔30分钟重启nginx, 注意，minute的范围是0-59，每隔30分钟的写法*/30和0,30的区别0 23 * * 6 /etc/init.d/nginx restart #每周六晚11:00重启nginx0 */1 * * * /etc/init.d/nginx restart #每一小时重启nginx0 23-7 * * * /etc /init.d/nginx restart #晚上11点到早上7点之间，每隔一小时重启nginx0 11 4 * 1-3 /etc/init.d/nginx restart #每月的4号与每周一到周三的11点重启nginx0 * * * * root run-parts /etc/cron.hourly #每小时执行/etc/cron.hourly目录内的脚本 其他命令： crontab -l # 查询crontab任务 crontab -r # 清除当前用户的所有crontab任务 注意事项： 六个选项都不能为空，必须填写，如果不确定使，用*代替任意时间 crontab定时任务，最小有效时间是分钟，最大时间范围是月 在定义时间时，日期和星期最好不要在一条定时任务中出现，因为他们都是以天为单位，不利于管理员管理 在定时任务中，不管\b是直接写\b命令，还是在脚本中写命令，最好都用绝对路径 anacron配置anacron会自动执行因为关机等故障没有执行的定时任务，只会检测/etc/cron.{daily,weekly,montyly}目录，而不会检测crontab -e设置的定时任务 anacron检测周期 anacron会使用一天，七天，一个月作为检测周期 在系统的/var/spool/anacron目录中存在cron.{daily,weekly,montyly}文件，用于记录上次执行crontab的时间 和当前时间做比较，如果两个时间的差值超过了anacron的指定时间差值，证明有cron任务呗漏执行 /etc/anacrontab配置文件12345678910111213141516# /etc/anacrontab: configuration file for anacron# See anacron(8) and anacrontab(5) for details.SHELL=/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# the maximal random delay added to the base delay of the jobsRANDOM_DELAY=45# the jobs will be started during the following hours onlySTART_HOURS_RANGE=3-22#period in days delay in minutes job-identifier command1 5 cron.daily nice run-parts /etc/cron.daily7 25 cron.weekly nice run-parts /etc/cron.weekly@monthly 45 cron.monthly nice run-parts /etc/cron.monthly cron.daily工作执行过程 首先读取/var/spool/anacron/cron.daily中的上一次anacron执行的时间 和当前时间做比较，如果两个时间的差值超过一天，就执行cron.daily工作 执行这个工作只能在03:00-22:00之间 执行工作时强制延迟时间为5分钟，再随机延迟0-45分钟时间 使用nice命令指定默认优先级，使用run-parts脚本执行/etc/cron.daily目录中的所有可执行文件 crontab实例1234# 检查crond服务是否安装yum list cronie &amp;&amp; systemctl status crond# 检查crontab工具是否安装yum list crontabs &amp;&amp; which crontab &amp;&amp; crontab -l systemctl 是类似service的一个命令，可以\b代替 cron日志cron日志保存在/var/log/cron查看日志：1tail -n 2 /var/log/cron 清理日志系统12#定时任务清理\b日志/dev/null &gt; /var/log/shadowsocks.log","tags":[{"name":"linux","slug":"linux","permalink":"https://mhynet.cn/tags/linux/"},{"name":"bash","slug":"bash","permalink":"https://mhynet.cn/tags/bash/"},{"name":"crontab","slug":"crontab","permalink":"https://mhynet.cn/tags/crontab/"}]},{"title":"[转载]mongodb常用查询语句","date":"2019-01-04T03:36:21.000Z","path":"mongodb-searchs.html","text":"记录一下MongoDB常用语句，顺带与SQL做个简单的对比。 1、查询(find) （1）查询所有结果12select * from articledb.article.find() （2）指定返回哪些键12select title, author from articledb.article.find(&#123;&#125;, &#123;\"title\": 1, \"author\": 1&#125;) （3）where条件12select * from article where title = \"mongodb\"db.article.find(&#123;\"title\": \"mongodb\"&#125;) （4）and条件12select * from article where title = \"mongodb\" and author = \"god\"db.article.find(&#123;\"title\": \"mongodb\", \"author\": \"god\"&#125;) （5）or条件12select * from article where title = \"mongodb\" or author = \"god\"db.article.find(&#123;\"$or\": [&#123;\"title\": \"mongodb\"&#125;, &#123;\"author\": \"god\"&#125;]&#125;) （6）比较条件12select * from article where read &gt;= 100;db.article.find(&#123;\"read\": &#123;\"$gt\": 100&#125;&#125;) $gt(&gt;)、$gte(&gt;=)、$lt(&lt;)、$lte(&lt;=)12select * from article where read &gt;= 100 and read &lt;= 200db.article.find(&#123;\"read\": &#123;\"$gte\": 100, \"lte\": 200&#125;&#125;) （7）in条件12select * from article where author in (\"a\", \"b\", \"c\")db.article.find(&#123;\"author\": &#123;\"$in\": [\"a\", \"b\", \"c\"]&#125;&#125;) （8）like12select * from article where title like \"%mongodb%\"db.article.find(&#123;\"title\": /mongodb/&#125;) （9）count12select count(*) from articledb.article.count() （10）不等于12select * from article where author != \"a\"db.article.find(&#123; \"author\": &#123; \"$ne\": \"a\" &#125;&#125;) （11）排序升序：12select * from article where type = \"mongodb\" order by read descdb.article.find(&#123;\"type\": \"mongodb\"&#125;).sort(&#123;\"read\": -1&#125;) 降序：12select * from article where type = \"mongodb\" order by read ascdb.article.find(&#123;\"type\": \"mongodb\"&#125;).sort(&#123;\"read\": 1&#125;) findOne()：除了只返回一个查询结果外，使用方法与find()一样。2、创建（insert）12insert into article(title, author, content) values(\"mongodb\", \"tg\", \"haha\")db.article.insert(&#123;\"title\": \"mongodb\", \"author\": \"tg\", \"content\": \"haha\"&#125;) 3、更新（update） （1）update() 语法：1db.collecion.update(query, update[, options] ) query : 必选，查询条件，类似find中的查询条件。update : 必选，update的对象和一些更新的操作符（如$,$inc…）等options：可选，一些更新配置的对象。upsert：可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。multi：可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。writeConcern：可选，抛出异常的级别。 简单更新：12update article set title = \"mongodb\" where read &gt; 100db.article.update(&#123;\"read\": &#123;\"$gt\": 100&#125;&#125;, &#123;\"$set\": &#123; \"title\": \"mongodb\"&#125;&#125;) （2）save()1db.article.save(&#123;_id: 123, title: \"mongodb\"&#125;) 执行上面的语句，如果集合中已经存在一个_id为123的文档，则更新对应字段;否则插入。 注：如果更新对象不存在_id，系统会自动生成并作为新的文档插入。 （3）更新操作符 MongoDB提供一些强大的更新操作符。 更新特定字段（$set）：12update game set count = 10000 where _id = 123db.game.update(&#123;\"_id\": 123&#125;, &#123; \"$set\": &#123;\"count\": 10000&#125;&#125;) 删除特定字段（$unset）：1db.game.update(&#123;\"_id\":123&#125;, &#123;\"$unset\": &#123;\"author\":1&#125;&#125;) 注：$unset指定字段的值只需是任意合法值即可。 递增或递减（$inc）1db.game.update(&#123;\"_id\": 123&#125;, &#123; \"$inc\": &#123;\"count\": 10&#125;&#125;) // 每次count都加10 注意：$inc对应的字段必须是数字，而且递增或递减的值也必须是数字。 数组追加（$push）：1db.game.update(&#123;\"_id\": 123&#125;, &#123; \"$push\": &#123;\"score\": 123&#125;&#125;) 还可以一次追加多个元素：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$push\": &#123;\"score\": [12,123]&#125;&#125;) 注：追加字段必须是数组。如果数组字段不存在，则自动新增，然后追加。 一次追加多个元素（$pushAll）：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pushAll\": &#123;\"score\": [12,123]&#125;&#125;) 追加不重复元素（$addToSet）：$addToSet类似集合Set，只有当这个值不在元素内时才增加：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$addToSet\": &#123;\"score\": 123&#125;&#125;) 删除元素（$pop）：12db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pop\": &#123;\"score\": 1&#125;&#125;) // 删除最后一个元素db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pop\": &#123;\"score\": -1&#125;&#125;) // 删除第一个元素 注：$pop每次只能删除数组中的一个元素，1表示删除最后一个，-1表示删除第一个。 删除特定元素（$pull）：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pull\": &#123;\"score\": 123&#125;&#125;) 上面的语句表示删除数组score内值等于123的元素。 删除多个特定元素（$pullAll）：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pullAll\": &#123;score: [123,12]&#125;&#125;) 上面的语句表示删除数组内值等于123或12的元素。 更新嵌套数组的值： 使用数组下标（从0开始）：1234&#123; address: [&#123;place: \"nanji\", tel: 123&#125;, &#123;place: \"dongbei\", tel: 321&#125;]&#125;db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$set\": &#123;\"address.0.tel\": 213&#125;&#125;) 如果你不知道要更新数组哪项，我们可以使用$操作符（ $表示自身，也就是按查询条件找出的数组里面的项自身，而且只会应用找到的第一条数组项）：1db.game.update(&#123;\"address.place\": \"nanji\"&#125;, &#123;\"$set\": &#123;\"address.$.tel\": 123&#125;&#125;) 在上面的语句中，$就是查询条件{&quot;address.place&quot;: &quot;nanji&quot;}的查询结果，也就是{place: &quot;nanji&quot;, tel: 123}，所以{&quot;address.$.tel&quot;: 123}也就是{&quot;address.{place: &quot;nanji&quot;, tel: 123}.tel&quot;: 123} 4、删除（remove）删除所有文档：12delete from articledb.article.remove() 删除指定文档：12delete from article where title = \"mongodb\"db.article.remove(&#123;title: \"mongodb\"&#125;) MongoDB特有的语句 数组查询（1）数组的普通查询假如type是[“mongodb”, “javascript”]：1db.article.find(&#123;\"type\": \"mongodb\"&#125;) 上面的语句可以匹配成功。 （2）多个元素的查询1db.article.find(&#123;\"type\": &#123;\"$all\": [\"mongodb\", \"javascript\"]&#125;&#125;) 只有type数组同时存在mongodb和javascript才会匹配。 （3）限制数组长度查询1db.article.find(&#123;\"type\": &#123;\"$size\": 2&#125;&#125;) 只有数组的长度是2才会匹配 注：type必须是数组 （4）返回特定数量 当$slice的参数是一个时，表示返回的数量;当是一个数组时，第一个参数表示偏移量，第二个表示返回的数量：123db.article.find(&#123;\"type\": &#123;\"$slice\": 1&#125;&#125;) // 返回第1个db.article.find(&#123;\"type\": &#123;\"$slice\": -1&#125;&#125;) // 返回最后一个db.article.find(&#123;\"type\": &#123;\"$slice\": [20, 10]&#125;&#125;) // 从第21个开始，返回10个，也就是21～30 注：$slice针对的是数组 （5）元素匹配 如果文档中有一个字段的值是数组，可以使用$elemMatch来匹配数组内的元素：1234&#123; kown: [&#123; a: 2, b: 4&#125;, 10, &#123; a: 4&#125;, &#123;b:10&#125;]&#125;db.article.find(&#123;\"kown\": &#123; \"$elemMatch\": &#123;a: 1, b: &#123;\"$gt\": 2&#125;&#125;&#125;&#125;) 只有a=1且b&gt;2才会匹配。 取模（$mod）比如我们要匹配 read % 5 == 1： 1db.article.find(&#123;\"read\": &#123;$mod: [5, 1]&#125;&#125;) 是否存在（$exists)如果我们要判断love字段是否存在，可以这样： 1db.article.find(&#123;\"love\": &#123;\"$exists\": true&#125;&#125;) // 如果存在字段love，就返回 我们也可以判断不存在：1db.article.find(&#123;\"love\": &#123;\"$exists\": false&#125;&#125;) // 如果不存在字段love，就返回 正则表达式 mongodb支持正则表达式，使用方法与正则字面量一样：1db.article.find(&#123;\"title\": /mongodb/i&#125;) // i是忽略大小写 类型查询我们可以根据字段类型来返回数据：1db.article.find(&#123;\"comments\": &#123;\"$type\": 4&#125;&#125;) 只有当comments的类型是数组才匹配 注：更多类型的数值可以参考这里：mongodb $type 内嵌文档mongodb是允许内嵌文档的，而且要查询内嵌文档也很简单（使用点语法）：1234&#123; address: &#123; name: \"nanji\" &#125;&#125;db.article.find(&#123;\"address.name\": \"nanji\"&#125;) 上面的语句是查询comments中的author。 数组也可以采取点语法:1234&#123; comments: [&#123;title: \"mongodb\"&#125;, &#123;title: \"javascript\"&#125;]&#125;db.article.find(&#123;\"comments.title\": \"mongodb\"&#125;) 取反$not是元语句，即可以用在任何其他条件之上：1db.article.find(&#123;\"author\": &#123;\"$not\": /mongodb/i&#125;&#125;) 只要使用$not操作符，就表示取反。 MongoDB常用方法 控制返回数量（limit）1db.article.find().limit(10) 返回10条数据 略过数量1db.article.find().skip(5) 略过前5条数据，也就是从第6条开始返回。 可以结合limit()和skip()来达到分页效果：12select * from article limit 10, 20db.article.find().skip(10).limit(20) 统计 返回匹配数据的长度：1db.article.find().count() 格式化pretty()方法可以以格式化的方式显示所有文档： 1db.article.find().pretty() 删除集合当你要删除一个集合中的所有文档时，直接删除一个集合效率会更高： 1db.article.drop() 原文: http://ghmagical.com/article/page/id/Bj7qgmJ3CJUE","tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://mhynet.cn/tags/mongodb/"},{"name":"数据库","slug":"数据库","permalink":"https://mhynet.cn/tags/数据库/"}]},{"title":"express之request和response对象","date":"2018-12-25T13:37:53.000Z","path":"express_request_and_response.html","text":"express是基于Node搭建web应用的框架，使用express可以快速搭建一个网站，express的和核心功能有以下三点： 可以设置中间件来响应 HTTP 请求。 定义了路由表用于执行不同的 HTTP 请求动作。 可以通过向模板传递参数来动态渲染 HTML 页面。 request 和 response 对象的具体介绍：Request 对象 request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。 常见属性有： req.app：当callback为外部文件时，用req.app访问express的实例 req.baseUrl：获取路由当前安装的URL路径 req.body / req.cookies：获得「请求主体」/ Cookies req.fresh / req.stale：判断请求是否还「新鲜」 req.hostname / req.ip：获取主机名和IP地址 req.originalUrl：获取原始请求URL req.params：获取路由的parameters req.path：获取请求路径 req.protocol：获取协议类型 req.query：获取URL的查询参数串 req.route：获取当前匹配的路由 req.subdomains：获取子域名 req.accepts()：检查可接受的请求的文档类型req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第- 一个可接受字符编码 req.get()：获取指定的HTTP请求头 req.is()：判断请求头Content-Type的MIME类型 Response 对象 response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。 常见属性有： res.app：同req.app一样 res.append()：追加指定HTTP头 res.set()在res.append()后将重置之前设置的头 res.cookie(name，value [，option])：设置Cookie opition: domain / expires / httpOnly / maxAge / path / secure / signed res.clearCookie()：清除Cookie res.download()：传送指定路径的文件 res.get()：返回指定的HTTP头 res.json()：传送JSON响应 res.jsonp()：传送JSONP响应 res.location()：只设置响应的Location HTTP头，不设置状态码或者close response res.redirect()：设置响应的Location HTTP头，并且设置状态码302 res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的- 页面，这样就不会自动输出了。 res.send()：传送HTTP响应 res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定- Content-Type res.set()：设置HTTP头，传入object可以一次设置多个头 res.status()：设置HTTP状态码 res.type()：设置Content-Type的MIME类型 路由12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require('express');var app = express();// 主页输出 \"Hello World\"app.get('/', function (req, res) &#123; console.log(\"主页 GET 请求\"); res.send('Hello GET');&#125;)// POST 请求app.post('/', function (req, res) &#123; console.log(\"主页 POST 请求\"); res.send('Hello POST');&#125;)// /del_user 页面响应app.get('/del_user', function (req, res) &#123; console.log(\"/del_user 响应 DELETE 请求\"); res.send('删除页面');&#125;)// /list_user 页面 GET 请求app.get('/list_user', function (req, res) &#123; console.log(\"/list_user GET 请求\"); res.send('用户列表页面');&#125;)// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get('/ab*cd', function(req, res) &#123; console.log(\"/ab*cd GET 请求\"); res.send('正则匹配');&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;) 静态文件Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。 你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：1app.use(express.static('public')); 假设有一张图片/public/images/logo.png，应用添加处理静态文件的功能实例：1234567891011121314151617var express = require('express');var app = express();app.use(express.static('public'));app.get('/', function (req, res) &#123; res.send('Hello World');&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;) 用node启动该文件后，在浏览器中访问 http://127.0.0.1:8081/images/logo.png， 即可看到/public/images/logo图片 使用post请求的实例1234567891011121314151617181920212223242526272829303132var express = require('express');var app = express();var bodyParser = require('body-parser');// 创建 application/x-www-form-urlencoded 编码解析var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;)app.use(express.static('public'));app.get('/index.htm', function (req, res) &#123; res.sendFile( __dirname + \"/\" + \"index.htm\" );&#125;)app.post('/process_post', urlencodedParser, function (req, res) &#123; // 输出 JSON 格式 var response = &#123; \"first_name\":req.body.first_name, \"last_name\":req.body.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;) 使用中间件向node服务器发送cookie的实例12345678910111213// express_cookie.js 文件var express = require('express')var cookieParser = require('cookie-parser')var util = require('util');var app = express()app.use(cookieParser())app.get('/', function(req, res) &#123; console.log(\"Cookies: \" + util.inspect(req.cookies));&#125;)app.listen(8081) 总结：express是基于node快速搭建网站的框架，底层实现使用了promise + callback的方式，功能全面。但是比较推荐的是koa2，koa2是koa2.0版本之后的称呼，koa1.0版本使用了generator函数实现，2.0使用了async/await函数实现，非常精简，但是功能并不比Express少，express能做的koa都能做，而且做得更好。不同的是，koa把express的部分功能拆分出去了，使用的时候可以根据需求合理引入中间件，比如koa-router。在上一家公司的时候使用过koa1.0多页面的电商网站，前端项目集成了部分node代码实现页面路由和服务的渲染，体验非常棒，也阅读过公司内部使用koa2.0的后台项目，感觉更友好一些。本篇博客大部分内容都是摘自runoob，不是原创，算是一篇介绍express的笔记吧。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"node","slug":"node","permalink":"https://mhynet.cn/tags/node/"}]},{"title":"hexo+github博客多设备同步","date":"2018-10-19T03:25:59.000Z","path":"hexo-mutl-device-sync.html","text":"为什么hexo博客需要多设备同步呢？ 很多基于hexo的博客的主题都是引用的第三方的主题项目啊，作为一个第三方的项目，导入到自己博客项目的themes目录下之后，作为一个subproject 是无法commit到自己的项目下的，删除原项目的.git文件把整个主题包嵌入自己项目也行，但是也需要尊重一下主题的开发者呀。 这样一来，在一个新设备上git pull了自己的项目后还要去git pull主题目录，直接拉下来的主题包的配置文件_config.yml文件一般都需要修改下吧，如果有google、百度统计相关的代码需要添加到主题中的相关文件中的，就需要改下原来的主题文件了，这些改的第一次改动之后，下一次你还记得怎么改不? 不记得啦！那只好在相关文件里面记录下来，下次直接参考该记录来重新配置下吧，手动配置感觉很麻烦，那就写一个shell脚本，下次直接执行以下该脚本就自动配置好啦！ 这里贴一下我的自动化配置shell脚本：1234567891011121314151617181920212223242526#!/bin/bashlocalRepo=\"$HOME/hexo-theme-BlueLake\"floader=\"themes/BlueLake\"subGitFloader=\"themes/BlueLake/.git\"if [ ! -d \"$localRepo\" ]; then echo \"1. local BlueLake theme repostory not exist and start clone from remote......\" echo $( git clone git@github.com:chaooo/hexo-theme-BlueLake.git &amp;&amp; mv \"hexo-theme-BlueLake\" \"$HOME/\" )else echo \"1. local BlueLake theme repostory exist!\"fiif [ -d \"$floader\" ]; then rm -rf \"$floader\" &amp;&amp; echo \"2.remove themes/BlueLake success!\"ficp -Rf \"$HOME/hexo-theme-BlueLake\" \"themes/BlueLake\" &amp;&amp; echo \"3. copy thems successed!\" || echo \"3. copy thems failed!\"cat \"source/_data/BlueLake_theme_config.yml\" &gt; \"$floader/_config.yml\" &amp;&amp; echo \"4. move _config.yml successed!\"cat \"source/_data/baidu_config_script.jade\" &gt;&gt; \"themes/BlueLake/layout/_partial/after_footer.jade\" &amp;&amp; echo \"5. add baidu_config_script success!\" || echo \"5. add baidu_config_script failed!\"if [ -d \"$subGitFloader\" ]; then echo $( rm -rf $&#123;subGitFloader&#125; ) &amp;&amp; echo \"6.remove $&#123;subGitFloader&#125; succsssful!\"fi 自从写好这段脚本后再也不用担心更换新设备后重新部署hexo博客的问题啦。 为什么需要经常部署博客呢？我爱折腾啊，电脑经常换系统啊，虚拟机ubuntu，Windows，Mac OS X双系统，近一年来重装了好多次系统啊，每次都重新部署开发环境好麻烦，而且换工作之后也会更换电脑啊。 如果担心主题开发者后续更新了主题导致在新设备上部署时环境不一致，可以把原主题fork到自己的github，然后把仓库URL改成fork过来的URL即可。 注：后续补充，现在我已不再使用以上方案同步博客配置，百度站长和google站长验证使用 html 标签验证方式，相应的识别码已写入配置文件，而且可以把主题中的部分配置项配置到项目的配置下。主题同步采用了 git modules，把原作者的主题fork到自己的github，然后自己维护主题仓库，这样可以在原主题的基础上进行功能和样式的调整和优化。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://mhynet.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://mhynet.cn/tags/github/"},{"name":"github pages","slug":"github-pages","permalink":"https://mhynet.cn/tags/github-pages/"},{"name":"博客","slug":"博客","permalink":"https://mhynet.cn/tags/博客/"}]},{"title":"linux学习笔记(4)","date":"2018-09-22T10:15:31.000Z","path":"linux-note-4.html","text":"这里记录下linux系统下用户和用户组的管理方面的\b学习笔记。12用户: 使用操作系统的\b人用户组: 具有相同系统权限的一组用户 /etc/group 存储当前系统中所有\b用户组信息 格式：12group:x:123:ABC,def,xyz组名称:组密码占位符:组编号:组中用户列表 组只有一个用户，用户组合\b和用户名相同，用户组列表为空,root用户组的组号为0,编号1~499全部是分配给系统的，越早安装的应用组编号越靠前,个人用户编号从500\b开始计数,组密码占位符全部都是x /etc/gshadow 存储当前系统中用户组的密码信息12group:*: :abc组名称:组密码:组管理者:组中用户列表 组密码为*或!或空表示没有组密码 /etc/paswd 存储当前系统所有用户的信息。12user:x:123:456:xxxx:/home/user:/bin/bash用户名:密码占位符:用户编号:用户组编号:用户注释信息:用户主目录:shell类型 /etc/shadow 存储当前系统中所有用户的密码信息。\b用户和用户组的密码保存在单独的文件/etc/gshadow 和/etc/shadow中， 需要的权限要比保存用户和用户组的文件高很多 管理用户组的命令： 添加用户组：groupadd [用户组名] 修改用户组名：groupmod -n [newGroupName] [oldGroupName] 修改用户组编号：groupmid -g 666 [groupName] 创建用户组的时候\b指定编号：groupadd -g 888 [groupName] 删除用户组(删除用户组之前必须先清空组内用户， 否则这些用户的组信息丢失， 有权限方面的影响)：groupdel [groupName] 组内添加用户(用户目录默认\b在/home下，默认创建一个和用户名相同的用户组)： 12useradd userNameuseradd -g groupName -d /home/userName userName 给用户添加备注：useradd -c 备注内容 userName 改用户名：usermod -l 新用户名 旧用户名 指定新的用户文件夹：usermod -d /home/mhy mhy 修改所属用户组：usermod -g 组名 用户名 删除账号：userdel 用户名 删除的同时删除用户目录:userdel -r 用户名 禁止root以外的用户登录服务器（空文件就可以）：touch /etc/nologin 锁定用户账户：passwd -l 用户名 解锁用户passwd -u 用户名 清除用户的密码，无密码登录：passwd -d 用户名 主要组和附属组：一个用户可以属于多个组，一个主要组，若干个个附属组, 添加多个，用逗号连接\b多个附属组名:1gpasswd -a 用户名 附属组名 创建用户时指定主要组和附属组\b：`useradd -g 主要组 -G 附属组1,负数组2 用户名 用户组设置密码：gpasswd 用户组名 切换用户身份:su 用户名 我是谁:whoami 用户信息：id 用户名 所属组：groups 用户名","tags":[{"name":"linux","slug":"linux","permalink":"https://mhynet.cn/tags/linux/"},{"name":"bash","slug":"bash","permalink":"https://mhynet.cn/tags/bash/"}]},{"title":"linux学习笔记(3)","date":"2018-09-11T10:12:07.000Z","path":"linux-note-3.html","text":"linux中常用的命令使用笔记。 echo 命令 echo [选项] [输出内容] 选项： -e 支持反斜杠控制的字符转换 控制字符 作用 \\a 输出警告音 \\b 退格键，即左删除键 \\n 换行符 \\r 回车键 \\t 制表符 \\v 垂直制表符 \\0n nn 按八进制ASCII码表输出字符，其中0是数字零，nnn是三位八进制数 \\xh h 按照十六进制ASCII码表输出z福。其中hh是两位十六进制数 aliaseg:alias la=&quot;ls -la&quot;查看系统中的别名：alias1.临时设置别名： 命令行输入 alias la=&quot;ls -al --color=auto&quot; 2.永久设置： 写入环境变量配置文件:~/.bashrc 3.删除别名：临时删除可以直接输入: unalias la,永久删除需要修改配置文件 命令生效顺序 第一顺位执行用绝对路径活泼相对路径执行的命令 第二顺位执行别名 第三执行bash的内部命令 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令 命令快捷键 快捷键 功能 ctrl + c 强行终止 cmd + l 清屏(清除一行) ctrl + l 清屏(屏幕中所有行), 效果同clear ctrl + a 光标移动到命令行行首 ctrl + e 光标移动到命令行行尾 ctrl + u 从光标位置删除到行首 ctrl + z 把命令放入后台(命令无法使用ctrl + c z\b终止的时候使用，不建议 ) ctrl + r 在历史命令中搜索 ctrl + 左右方向键 按单词左右移动光标 历史命令上下箭头读取历史命令 读取所有历史命令 history [选项] [历史命令保存文件] 选项： -c 清空历史命令 -w 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history 注意: history命令中的命令包括文件保存的和当前登录输入的所有命令， 文件只会在登出的时候才会主动保存到文件，\b但是可以通过-w选项把当前登录后的历史命令手动保存在文件中 历史命令默认保存1000条，可以在/etc/profile中的HISTSIZE=1000字段中设置 使用!n重复\b执行第n条历史命令 使用!字串重复执行最后一条以该字串开头的命令 使用!!重复执行上一条命令 命令和文件补全 在bash中，按tab键自动补全命令、文件路径， \b对提高输入速度和排错非常有用 输出重定向1234标准的输入输出设备:键盘 /dev.stdin 0 标准输入显示器 /dev/sdtout 1 标准输出显示器 /dev/sdterr 2 标准错误输出 标准输出重定向：12命令 &gt; 文件 ： 以覆盖方式，把命令的正确输出输出到指定文件或设备中命令 &gt;&gt; 文件 ： 以追加的方式，把命令的正确输出输出到指定文件或设备中 文件不存在， 先创建后写入， &gt;覆盖 &gt;&gt;追加 命令的错误输出：12错误命令 2&gt; 文件 ： 以覆盖方式，把命令的错误输出输出到指定文件或设备中错误命令 2&gt;&gt; 文件 ： 以追加的方式，把命令的错误输出输出到指定文件或设备中 注意：正确输出大于号左右有空格，错误输出左右没有空格 正确和错误输出同时保存： 以覆盖方式，把正确输出和错误输出都保存到同一个文件中： 命令 &amp;&gt;文件 命令 &gt; 文件 2&gt;&amp;1 eg: ./test.sh &gt;&gt; common.log 2&gt;&amp;1 以追加方式，把正确输出和错误输出都保存到同一个文件中： 命令 &amp;&gt;&gt;文件 命令 &gt;&gt; 文件 2&gt;&amp;1 eg: ./test.sh &gt;&gt; common.log 2&gt;&amp;1 把正确输出追加到文件1， 把错误输出追加到文件2： 命令 &gt;&gt; 文件一 2&gt;&gt; 文件二 eg: ./test.sh &gt;&gt; success.log 2&gt;&gt; error.log 注意上面命令中的空格，在错误输出中2&gt;\b或者2&gt;&gt;之间没有空格， 1&gt; 等同于 &gt;，1省略不写一般都是以追加的方式写入日志文件最常用的命令：12`命令&gt;&gt;文件一 2&gt;&gt;文件二``命令 &amp;&gt;&gt;\b 文件` /dev/null目录文件写入后丢弃，用于一些不需要过程只需要结果的命令 123&gt; 和 1&gt; 相同, 标准输出重定向2&gt;&amp;1 标标准错误输出 重定向到 标准输出&amp;&gt; file 把标准输出和错误输出都重定向到文件file中 输入重定向wc [选项] [文件名] 选项： -c 统计字节数 -w 统计单词数 -l 统计行数12命令 &lt; 把文件作为命令的输入命令 &lt;&lt; 标识符 标识符把标识符之间的内容作为命令\b的输入eg:12wc &lt; acc.log # 统计文件的输入&lt;&lt;很少用 管道符多命令顺序执行： 多命令执行符 格式 作用 ; 命令1; 命令2 多个命令顺序执行，之间没有任何逻辑关系 &amp;&amp; 命令1 &amp;&amp; 命令2 逻辑与， 当命令1正确执行，则命令2才会执行，否则命令2不执行 命令1 命令2 逻辑或， 当命令1执行不正确，才会执行命令2，否则命令2不会执行 判断命令是否正确执行: ./test.sh &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; 管道符格式： 命令1 | 命令2 命令1的正确\b输出作为命令2的操作对象1netstat -an | grep ESTABLISHED 通配符 通配符 作用 ？ \b 匹配一个任意字符 * 匹配0个或任意多个字符 [] 匹配中括号中任意一个字符 [-] 匹配中括号中任意一个字符， - 代表范围 [^] 逻辑非， 匹配不上中括号内的一个字符 通配符用于匹配文件名或目录名 bash中其他特殊符号1234567''\"\"`` : 反引号，反引号括起来的是系统命令，在bash中会先执行它，和$()作用一样$() : 作用同反引号, 执行系统命令，然后获取到执行结果$ : 调用变量的值\\ : 转义符# :注释","tags":[{"name":"linux","slug":"linux","permalink":"https://mhynet.cn/tags/linux/"},{"name":"bash","slug":"bash","permalink":"https://mhynet.cn/tags/bash/"}]},{"title":"linux学习笔记(2)","date":"2018-08-20T05:26:13.000Z","path":"linux-note-2.html","text":"1.shell 脚本脚本语言是用来让计算机自动化执行完成一系列工作的程序，不需要编译，通常是通过解释器运行的。 2.shell环境shell文件的第一行的”#!”是一个约定的标记，告诉系统其后路径所指定的程序即是解释此脚本的shell程linux的shell种类常见的有： Bourne Ageng Shell(/bin/bash) Bourne Shell(/usr/bin/sh 或/bin/sh) “C Shell” (/usr/bin/csh) Shell for Root(/sbin/sh) 3.运行shell脚本创建一个shell脚本文件,保存为test.sh1echo \"hello\" #echo命令用于向窗口输出文本 作为可执行文件12chmod +x ./text.sh #使脚本具有执行权限./test.sh #执行脚本 执行脚本必须指定路径，可以用绝对路径或者相对路径，不指定路径会从PATH里面找。 作为解释器参数 直接运行解释器，其参数为shell脚本的文件名12/bin/sh test.sh/bin/php test.php 这种方式运行脚本，第一行不需要指定解释器信息，写了也不起作用 4.shell变量4.1 变量定义变量名和等号之间不能有空格，shell变量定义的规定： 变量命名只能使用英文字母，数字和下划线，首字符不能以数字开头 中间不能有空格，可以使用下划线 不能使用标点符号 不能使用bash里的关键字 有效的变量示例如下：1234RoomL_YARM_varvar2 无效的变量名：12?var=123user*name=runoob 变量赋值可以显式的直接赋值也可以用语句来赋值：123Room=222for file in `ls /etc` 4.2 变量的使用使用一个定义过的变量，只需要在变量前面加上美元符号即可123your_name='mhy'echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号可选，加花括号是为了帮助解释器识别变量的边界123for skill in Ada Coffe Action Java; do2echo \"I am good at $&#123;skill&#125;Script\"done 推荐给所有变量加上$ 已定义的变量可以重新被定义1234your_name=\"tom\"echo $&#123;your_name&#125;your_name=\"lily\"echo $&#123;your_name&#125; 但是变量定义的时候不能加$符号。 4.3 只读变量使用readonly命令可以将变量定义为只读变量，修改只读变量会报错1234#!bin/bashgirl_friend=\"lily\"readonly girl_fiendgir_friend=\"leilei\" 运行脚本报错了. 4.4 删除变量使用unset 命令删除变量12girl_friend=\"xiao mei\"unset girl_friend unset 命令不能删除只读变量 4.5 变量类型shell脚本语言存在三种变量： 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效 环境变量 所有的程序包括shell启动的程序，都能访问环境变量，必要时shell脚本也能定义环境变量 shell变量 shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，一部分是局部变量，这些变量保证了shell的正常运行 5.shell字符串字符串是shell编程中最常用最有效的数据类型。字符串可以用单引号或双引号或不用引号。 5.1 单引号单引号字符串的限制： 单引号里任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字符串中不能出现单引号（对单引号使用转义符后也不行）5.2 双引号 双引号的有点： 双引号里可以有变量 双引号里可以出现转义字符 5.3 拼接字符串1234your_name=\"mhy\"greeting=\"hello\", \"$your_name\"!\"greeting_1=\"hello, $&#123;your_name&#125;!\"echo $greeting $greeting_1 5.4 获取字符串长度12# string=\"beijing\"# echo $&#123;#string&#125; #输出 7 5.5 提取字符串以下实例从字符串第2个字符开始截取4个字符12string=\"hello beijing!\"echo $&#123;string:1:4&#125; #输出 trin 5.6 查找子字符串查找子字符串的位置12string=\"wellcome to beijing, shaonian\"echo `expr index \"$string\" is` # 输出 5.7 判断读取字符串值 表达式 含义 ${var} 定义var的值，与$var相同 $(var-DEFAULT} 如果var没有被声明，那么就以$DEFAULT作为其值 ${var:-DEFAULT} 如果var没有被声明，或者其值为空，那么就以$DEFAULT作为其值 ${var=DEFAULT} 如果var没有被声明，那么就以$DEFAULT作为其值 ${var:=DEFAULT 如果var没有被声明，或者其值为空，那么就以$DEFAULT作为其值 ${var+OTHER} 如果var声明了，那么其值就是$OTHER,否则就为null字符串 ${var:+OTHER} 如果var被设置了，那么其值就是$OTHER，否则就为null字符串 5.8 字符串操作汇总 表达式 含义 ${string:position 在$string中, 从位置$position开始提取子串 ${string:position:length 在$string中, 从位置$position开始提取长度为$length的子串 ${string#substring 从变量$string的开头, 删除最短匹配$substring的子串 ${string##substring 从变量$string的开头, 删除最长匹配$substring的子串 ${string%substring 从变量$string的结尾, 删除最短匹配$substring的子串 ${string%%substring 从变量$string的结尾, 删除最长匹配$substring的子串 ${string/substring/replacement 使用$replacement, 来代替第一个匹配的$substring ${string//substring/replacement 使用$replacement, 代替所有匹配的$substring ${string/#substring/replacement 如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring ${string/%substring/replacement 如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring 6.shell数组bash支持一维数组不支持多维数组，没有限定数组的大小数组下标从0开始编号，下便可以是整数或算数表达式，其值应该大于或等于0。 6.1 定义数组在shell中用括号来表示数组，元素用空格符号隔开：1数组名=(值1 值2 值3 ... 值n) eg：123456array_name=( value0 value1 value2 value3) 还可以单独定义数组的各个分量：123array_name[0]=value0array_name[1]=value1array_name[100]=value100 可以不使用连续的下标，而且下标的范围没有限制。 6.2 数组的操作 读取数组 读取数组的语法：1$(array_name[index]) 使用@符号可以获取数组中所有元素：1echo $(array_name[@]) 获取数组的长度 获取数组的长度的方法与获取字符串长度的方法相同。123456# 获取数组元素的个数length=$(#array_name[@])# 或者length=$(#array_name[*])# 获取数组单个元素的长度lengthn=$(#array_name[n]) 7 注释shell中只有单行注释， 在每一行的开头加入#即可 多行代码可以用花括号括起来定义成一个函数，不调用它这块代码不会执行，和多行注释的效果一样","tags":[{"name":"linux","slug":"linux","permalink":"https://mhynet.cn/tags/linux/"},{"name":"bash","slug":"bash","permalink":"https://mhynet.cn/tags/bash/"}]},{"title":"linux学习笔记(1)","date":"2018-08-16T04:25:59.000Z","path":"linux-note-1.html","text":"最近给家里的PC的虚拟机上搭建开发环境，经常用到文件或目录权限的问题， 发现对这一块的了解还不够，所以抽时间恶补了一下，这里记录一下。 文件类型文件权限区分的文件类型有三种，分别是： -: 文件;d: 目录;l: 软连接文件rw- r– r–u 所有者 g所属组 o其他人r read w write x 执行(excute) 权限范围的表示使用ls -la 命令查看文件权限范围： ls 命令的选项详解: -a -l (lang) (ll) -d 查看目录属性 -h 人性化显示文件大小 -i 显示inode 执行ls -la后显示出来的内容从左到右依次为：12-rw-r--r-- 1 root wheel 515B 7 13 2015 afpovertcp.cfg 权限 1引用计数 所有者root 所属组sheel 文件大小 最后修改时间 文件名 文件权限控制文件格式：-rw-r-r-- liniux文件权限格式\b\b一共有10位，第一位是文件类型，后面没三位代表一组，每三位一组， 相同权限的为一组，依次为：u 所有者, g所属组, o其他人 u: User, 文件或目录的拥有者g: Group，文件或目录的所属群组o: Other, 除了文件或目录的拥有者或所属群组之外，其他用户皆属于这个范围a: All, 全部用户，包含拥有者、所属群组以及其他用户r: read， 读取权限， 数字代号为 ‘4’w: write, 写入权限，数字代号为’2’x: 执行或切换的权限，数字代号为’1’-: 不具备任何权限， 数字代号为’0’s: 特殊功能说明，变更文件或目录的权限 chmod 格式： 1chmod [-cfvR] [--help] [--version] mode file... 选项 -c或–change: 效果类似’-v’参数，但仅返回更改的部分-f或–quiet或–silent: 不显示错误信息-R或–recursive: 递归处理， 将指令目录下的所有文件及字母里一并处理-v或–verbose： 显示指令执行过程–reference=&lt;参考文件或目录&gt;： 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同&lt;权限范围&gt;+&lt;权限设置&gt;： 开启权限范围的文件或目录的该选项权限设置&lt;权限范围&gt;-&lt;权限设置&gt;： 关闭权限范围的文件或目录的该选项权限设置&lt;权限范围&gt;=&lt;权限设置&gt;： 指定权限范围的文件或目录的该选项权限设置 参数权限模式： 指定文件的权限模式文件： 要改变权限的文件 chmod 722 ./shell.sh chmod 777 shell.sh # 统一授权方式，使用三位数字代表权限，每一位代表一个组，三个组授权均为7（rwx）chmod u+x shell.sh # 给u组增加权限x 数字0 ~ 7代表含义 0: — 0001: –x 0012: -w- 0103: -wx 0114: r– 1005: r-x 1016: rw- 1107: rwx 111 可以看出规律，每一组的权限按照从左到右的排序依次是rwx,按三个二进制位排序，哪一位为1就代表该位有权限 chown改变文件所有者命令格式： chown [选项] 参数chown [选项]… [所有者][:[组]] 文件… eg:1chown -R mhy:mhy ~/.ssh 同时把.ssh的所有者和组都改成了mhy 选项： -R 或 –recursive 递归处理 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录拥有者与所属群组相同 参数： 用户：组 指定所有者和所属组， 当省略组，仅改变所有者 文件 文件列表，可使用shell通配符改变多个eg：1chown -R mhy /home/mhy/* 相对路径和绝对路径12/home/user./file.js 常用命令： cd ~ (当前用户的家目录，如果是root用户，则是在/root， 其他用户家目录在/home/username)cd . 当前cd .. 上一级cd - 进入上一次目录 文件和文件夹处理命令创建文件夹格式： mkdir -p [目录名] 选项： -p 递归创建（先建立上一级目录） 其他命令： pwd rmdir 删除空白目录，如果有子文件则无法删除，不常用 rm 删文件或目录 rm -rf 强制删除目录 rm -r 删除目录， 会有确认提示 rm -f 强制删除，不会提示 cp 复制文件或目录 cp [选项] 需要复制的路径 目标位置 cp -r 复制目录 cp -p 连带文件属性复制 cp -d 若源文件是链接文件则复制链接属性 cp -a 相当于 -pdr mv [源文件位置] [目标位置] 常用目录系统命令目录1234567891011121314151617/bin/sbin/usr/bin/usr/sbinsbin下只有root权限可以执行， 其他两个所有不需要root/boot 启动目录/etc 默认配置文件目录/lib 函数库/media 挂载移动盘/mnt 挂载磁盘/sys /proc 内存相关的目录/tmp 临时目录/usr 系统软件资源目录2/usr/bin 系统命令(普通用户)2/usr/sbin 系统命令(root)/var 系统相关的文档内容 链接命令(link) ln -s [原文件]] [目标文件] 选项： -s 生成软连接 不带s则生成 硬链接 硬链接特点： 1.拥有相同的i节点和存储block块，可以看成是同一个文件2.可通过i节点识别3.不能跨分区4.不能针对目录使用5.删除一个，另一个还在（通过i节点识别） 软链接：特点： 1.类似windows的快捷方式2.软链接有自己的i节点和block块，数据只保存在原文件的文件名和i节点，并没有实际的文件数据3.lrwx—– 第一个l表示软链接4.修改原文件，改任何一个的都会改变，5.删除原文件，软链接不能使用（硬链接不影响使用）6.删除软链接可以使用原文件7.软链接的权限777，但是实际权限是原文件的权限8.创建软链接时原文件必须写绝对路径 查看i节点：1ls -i 文件搜索命令 1.文件搜索命令: locate2.文件搜索命令: find3.命令搜索命令: whereis, which4.字符串搜索命令: grep locate locate 文件名 在后台数据库按文件名搜索，速度快, locate命令搜索的数据库是 /var/lib/locate每天更新一次，所有新建文件后可以强制更新该数据库：1updatedb locate使用特点：1234只能按文件名搜索配置文件: /etc/updatedb.conf配置里面的选项是不搜索的文件系统MAC系统和linux系统的locate有差异 whereis (where), which whereis 查看执行位置和帮助文档位置 选项： -b 只查找可执行文件 -m 之查找帮助文件 which 查看命令的可执行位置和别名 which 只能查外部安装的命令，即只能查需要执行脚本文件的命令搜索依赖于环境变量 $PATH find文件搜索命令, 很强大 find [搜索范围] [搜索条件] eg:12find / -name nginx.conffind ~/.ssh -name config 避免大范围搜索，很消耗系统资源。find是在系统中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配. 通配符：123* 匹配任意内容? 匹配任意一个字符[] 匹配任意一个中括号内的字符 选项： -name 按名称 -iname 不区分大小写按名称 -user 按所有者搜索 -nouser 查找没有所有者的文件（内核文件没有所有者，u盘的数据可能没有所有者，windows文件没有所有者） -mtime 查找限定时间前修改的文件 默认是天 eg：1234567891011121314151617find /var/log/ -mtime +10 #查找10天前修改的文件-10 10天内10 10天当天+10 10天前-atime 文件访问时间-ctime 改变文件属性-mtime 修改文件内容find / -size 25k #查找文件大小是25kb的文件—25 小于25kb25kb 等于25kb+25kb 大于25kbfind / -size +25k -a -50k # 大于25k 且 小于50kfind / -size -25k -o +50k # 小于25k 或 大于50kfind / -size 25k -exec ls -lh &#123;&#125; \\; #查找，并显示详细信息 查找到的文件执行后面的操作 -exec:1234-exec ... &#123;&#125; \\; #标准格式find . -inum 262422 #查找i节点是262422的文件# k字节小写， M字节大写ls -i 文件名 grep命令在指定文件中搜索字符串 grep [选项] 字符串 文件名选项： -i 忽略大小写 -v 排除指定字符串， 取反搜索 eg:12grep \"size\" file_namegrep \"size\" file1 file2 file3 #多文件搜索 标记匹配颜色 –color=auto 选项：1grep \"size\" file_name --color=auto 使用正则表达式 -E 选项：123grep -E \"[1-9]+\"#或egrep \"[1-9]+\" 只输出文件中匹配到的部分 -o 选项：1echo this is a test line. | grep -o -E \"[a-z]+\\.\" grep 和 find 区别 find 在系统中搜索文件名，通配符匹配， 通配符是完全匹配 grep 在文件中搜索字符串，可以使用正则匹配，正则是包含匹配 帮助命令man man 命令 查看有哪些级别: man -f 命令 == whatis 命令 查看指定级别: man -5 passwdman -4 nullman -8 ifconfig 查看所有含有命令关键词的信息: man -k 命令 其他帮助命令 选项帮助: –help 命令帮助选项 shell内部命令： help 获取shell内部的帮助，shell有自带的一些命令，比如cd,help可以通过whereis cd 确定是否是shell内部命令，看可执行文件 help cd #command not found: help info 压缩命令 常营压缩格式： .zip .gz .bz2.tar.gz .tar.bz2 linux文件不区分后缀名，但是压缩文件为了区分文件类型和压缩类型，必须要在后缀中写清楚格式按压缩格式来记命令笔记方便 zip 压缩文件： zip 压缩文件名 源文件 压缩目录“ zip -r 压缩文件名 源目录 解压缩： unzip 压缩文件 gzip 压缩为.gz格式文件，源文件会消失： gzip 源文件 压缩为.gz格式，源文件保留： gzip -c 源文件 &gt; 压缩文件eg： 1gzip -c a.js &gt; a.js.gz 实际上是把源文件输出到新的文件 压缩目录压缩目录实际上是把目录内的文件全部压缩 gzip -r 目录 压缩目录下所有子文件，但是不能压缩目录 解压缩文件 gzip -d 压缩文件gunzip 压缩文件 解压缩目录 gunzip -r 压缩目录 .bz2 （不能压缩目录）压缩文件： bzip2 文件名bzip2 -k 文件名 解压缩文件： -k 保留压缩文件bzip2 -d 压缩文件bunzip2 压缩文件 上面三个压缩命令只有zip可以压缩没有了， gzip压缩目录实际上是压缩了目录内的文件，bz2直接回报错，可以用tar命令打包，然后再压缩 打包命令 tar 打包命令： tar -cvf 打包文件名 源文件 选项： -c 打包 -v 显示过程 -f 指定打包后的文件名eg: 1tar -cvf longzls.tar longzls 解打包命令： tar -xvf 打包文件名 选项： -x: 解打包eg:1tar -xvf longzls.tar .tar.gz.tar.gz格式是先打包为.tar格式，然后压缩为.gz格式 tar -zcvf 压缩包名.tar.gz 源文件 选项： -z 压缩为.tar.gz格式 tar -zxvf 压缩包名.tar.gz 选项： -x 解压缩.tar.gz格式 .tar.bz2 tar -jcvf 压缩包名.tar.bz2 源文件 选项： -j 压缩为.tar.bz2格式 tar -jxvf 压缩包名.tar,bz2 选项： -x 解压缩.tar.bz2格式 指定解压缩位置： tar -jxvf 压缩包名.gz.bz2 -C 解压缩位置 注意： 选项大写C必须写到压缩包名后面 压缩多个文件时压缩文件名用空格连接 查看包里面内容不解压，选项： -t Linux最常用的压缩格式是.tar.gz和.tar.bz2 Linux的关机和重启命令关机 shutdown [选项] 时间 选项： -c 取消前一个挂机命令 -h 关机 -r 重启 时间： now #立即执行 10 #十分钟后执行 eg:12shutdown -h 2:33 # 2:32 关机shutdown -r now shutdown 命令可以正确保持关机前的文件，比较安全. 以下命令关机不安全123haltpoweroffinit 0 重启：12rebootinit 6 reboot 是比较安全的重启方式 退出登录： logout 挂载命令查询系统中挂载的点： mount 依据/etc/fstab文件自动挂载： mount -a 挂载命令格式： mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点 选项： -t 文件系统：eg:ext3,ext4, ios9660…. -o 特殊选项：可以指定挂载的额外选项 挂载光盘(先要插入光盘或者虚拟机导入iso镜像): 1.建立挂载点： mkdir /mnt/cdrom/ 2.挂载光盘 mount -t iso9660 /dev/cdrom/ /mnt/cdrom/ 3.简写（默认的文件系统） mount /dev/sr0 /mnt/cdrom 4.卸载命令： umount 设备名或挂载点umount /mnt/cdrom 5.挂载U盘: fdisk -l # 查看U盘设备文件名mount -t vfat /dev/sdb1 /mnt/ust/ 远程登录y用户信息查看 w w 命令查看系统远程登录用户信息，包括系统资源 who who 命令查看系统远程登录用户信息，功能和w命令类似，不过没有系统资源信息 last last命令默认是读取/var/log/wtmp文件的数据。命令输出： 用户名 登录终端 登录ip 登录时间 退出时间(在线时间) lastlog 查询所有用户的最后一次登录 参考：chmod命令Linux chmod命令","tags":[{"name":"linux","slug":"linux","permalink":"https://mhynet.cn/tags/linux/"},{"name":"bash","slug":"bash","permalink":"https://mhynet.cn/tags/bash/"}]},{"title":"mongodb学习笔记","date":"2018-07-04T02:36:21.000Z","path":"mongodb-notes.html","text":"启动服务在mac下启动mongod服务时，如果读取默认配置文件的话直接执行mongod就行了，如果要添加其他配置可以添加对应的配置项，但是最合理的应该是读取配置文件且后台运行服务。使用 -f 或 –config 选项指定配置文件123mongod -f /etc/mongod.conf &amp;# 或mongod --config /etc/mongod.conf &amp; 创建数据库如果存在则切换，不存在则创建1use DATABASE_NAME 显示所有数据库1show dbs 发现刚刚创建的数据库没有有显示出来，可以插入数据1db.runoob.insert(&#123;\"name\":\"菜鸟教程\"&#125;) 然后执行show dbs发现刚刚创建的数据库显示出来了 删除数据库以下命令删除的是当前的数据库，如果要删除非当前数据库需要先使用use DATABASE_NAME命令切换过去，然后执行以下命令1db.dropDatabase() 创建集合1db.createCollection(name, optipon) name: 集合名称 options： 可选参数对象，有以下选项 capped: 布尔 (可选)， 如果为true则创建固定集合，是指有固定大小的集合，当达到最大值时会自动覆盖最早的数据， 当该值为true时，必须指定size参数 autoIndexId: 布尔 （可选）如果为true，则自动在_id字段创建索引，默认为false size: 数值 （可选） 固定集合指定一个最大值， 单位是字节 max: 数值 （可选） 固定集合中包含的文档的最大数量 查看集合查看当前数据库的已有集合1show collections eg:1db.createCollection(\"my_test_coll1\", &#123; capped: true, autoIndexId: true, size: 6142800, max : 10000 &#125;) 在mongodb中也可以通过直接插入数据创建集合1db.my_test_coll2.insert(&#123;\"name\": \"mhyuan\", \"age\": 22&#125;) 删除集合1db.COLLECTION_NAME.drop() 如果删除成功返回true，否则返回false 插入文档BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。mongodb中所有存储在集合中的数据都是BSON结构。1db.COLLECTION_NAME.insert(document) eg:1234567db.col.insert(&#123;title: 'MongoDB 教程', description: 'MongoDB 是一个 Nosql 数据库', by: 'mhy', url: 'http://www.mhynet.cn', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;) 可以将数据定义成一个变量，然后插入1234567document=(&#123;title: 'MongoDB 教程', description: 'MongoDB 是一个 Nosql 数据库', by: 'mhy', url: 'http://www.mhynet.cn', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;); 然后1db.col2.insert(document) 也可以执行1db.col.save(document) 如果不知道_id字段则效果和insert一样，如果指定了_id，则会更新该_id的数据 db.collection.insertOne(): 向指定集合中插入一条文档数据 1db.collection.insertOne(&#123;\"a\": 3&#125;) db.collection.insertMany(): 向指定集合中插入多条文档数据 1db.collection.insertMany([&#123;\"b\": 3&#125;, &#123;'c': 4&#125;]) 更新文档mongodb使用updata()和save()方法更新数据update()方法用于更新已存在的文档123456789db.collection.update(2&lt;query&gt;,2&lt;update&gt;,2&#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt;2&#125;) 参数说明： query: update的查询条件，类似于SQL update 的where后面的 update: update的对象和一些更新的操作符（如$,$inc…），也可以理解为SQL update 查询内set后面的 upsert: 可选， 如果不存在update的记录，是否插入数据， true为插入， 默认为false multi: 可选， mongodb默认为false，只更新找到的第一条记录，如果这个参数为true，就把按条件查出来的多条记录全部更新 writeConcern: 可选，抛出异常的级别 只更新第一条记录： 1db.col.update( &#123; \"count\" : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125; ); 全部更新： 1db.col.update( &#123; \"count\" : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; \"test2\" : \"OK\"&#125; &#125;,false,true ); 只添加第一条： 1db.col.update( &#123; \"count\" : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,false ); 全部添加进去: 1db.col.update( &#123; \"count\" : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; \"test5\" : \"OK\"&#125; &#125;,true,true ); 全部更新： 1db.col.update( &#123; \"count\" : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,true ); 只更新第一条记录： 1db.col.update( &#123; \"count\" : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; \"count\" : 1&#125; &#125;,false,false ); save()方法save方法通过传入的文档来替换已有文档123456db.collection.save(2&lt;document&gt;,2&#123;22writeConcern: &lt;document&gt;2&#125;) 参数说明： document: 文档数据 writeConcern: 可选， 抛出异常的级别 删除文档12345db.collection.remove( &lt;query&gt;, &lt;justOne&gt;)如果你的 Mong 如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明 query : （可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。 writeConcern :（可选）抛出异常的级别。 remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法。 如删除集合下全部文档：1234567db.inventory.deleteMany(&#123;&#125;)// 删除 status 等于 A 的全部文档：db.inventory.deleteMany(&#123; status : \"A\" &#125;)// 删除 status 等于 D 的一个文档：db.inventory.deleteOne( &#123; status: \"D\" &#125; ) remove() 方法 并不会真正释放空间。需要继续执行 db.repairDatabase() 来回收磁盘空间 查询文档1db.collection.find(query, projection) 参数 query ：可选，使用查询操作符指定查询条件 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。 如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：1db.col.find().pretty() pretty() 方法以格式化的方式来显示所有文档。 除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。 操作 格式 范例 RDBMS中的类似语句 等于 {\\:\\} db.col.find({“by”:”菜鸟教程”}).pretty() where by = ‘菜鸟教程’ 小于 {\\:{$lt:\\}} db.col.find({“likes”:{$lt:50}}).pretty() where likes &lt; 50 小于或等于 {\\:{$lte:\\}} db.col.find({“likes”:{$lte:50}}).pretty() where likes &lt;= 50 大于 {\\:{$gt:\\}} db.col.find({“likes”:{$gt:50}}).pretty() where likes &gt; 50 大于或等于 {\\:{$gte:\\}} db.col.find({“likes”:{$gte:50}}).pretty() where likes &gt;= 50 不等于 {\\:{$ne:\\}} db.col.find({“likes”:{$ne:50}}).pretty() where likes != 50 MongoDB AND 条件 MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。 语法格式如下：1db.col.find(&#123;key1:value1, key2:value2&#125;).pretty() eg:1234567891011121314db.col.find(&#123;\"by\":\"菜鸟教程\", \"title\":\"MongoDB 教程\"&#125;).pretty()&#123; \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100&#125; 以上实例中类似于 WHERE 语句：WHERE by=’菜鸟教程’ AND title=’MongoDB 教程’ MongoDB OR 条件MongoDB OR 条件语句使用了关键字 $or,语法格式如下： 1234567db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() AND 和 OR 联合使用类似常规 SQL 语句为：&#39;where likes&gt;50 AND (by = &#39;菜鸟教程&#39; OR title = &#39;MongoDB 教程&#39;)&#39; 1234567891011121314db.col.find(&#123;\"likes\": &#123;$gt:50&#125;, $or: [&#123;\"by\": \"菜鸟教程\"&#125;,&#123;\"title\": \"MongoDB 教程\"&#125;]&#125;).pretty()&#123; \"_id\" : ObjectId(\"56063f17ade2f21f36b03133\"), \"title\" : \"MongoDB 教程\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100&#125;","tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://mhynet.cn/tags/mongodb/"},{"name":"数据库","slug":"数据库","permalink":"https://mhynet.cn/tags/数据库/"}]},{"title":"vuex学习笔记","date":"2018-05-09T11:37:39.000Z","path":"vuex-notes.html","text":"vuex是为Vue应用开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 这个状态自管理应用包含以下几个部分： state，驱动应用的数据源； view，以声明方式将 state 映射到视图； actions，响应在 view 上的用户输入导致的状态变化。 单向数据流 多个组件共享状态 安装使用npm安装：1npm install vuex --save 使用yarn安装1yarn add vuex 在项目中使用Vue.use()来安装引入 Vuex1234import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex) State在 Vue 组件中获得 Vuex 状态从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：123456789// 创建一个 Counter 组件const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return store.state.count &#125; &#125;&#125; Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：1234567891011const app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现：12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：123456789101112131415161718// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 对象展开运算符mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符（现处于 ECMASCript 提案 stage-3 阶段），我们可以极大地简化写法：1234567computed: &#123; localComputed () &#123; /* ... */ &#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState(&#123; // ... &#125;)&#125; getterVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数：12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 1, test: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Getter 会暴露为 store.getters 对象：1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] 我们可以很容易地在任何组件中使用它：12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; mapGetters 辅助函数mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; //使用对象展开符 将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anothersGetters', // ... ]) &#125;&#125; 如果你想将一个 getter 属性另取一个名字，使用对象形式：1234mapGetters([ // 映射 `this.doneCount` 为 `store.getters.doneTodosCount` doneCount: 'doneTodosCount']) Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：123456789101112import Vuex from 'vuex'const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutation: &#123; increment(state) &#123; count ++ &#125; &#125;&#125;) 当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：1store.commit('increment') 可以传入\b额外的参数：1234567// ...mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit('increment', 10) 多数情况下为一个对象：12345678mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123; amount: 10&#125;) 对象风格的提交方式提交 mutation 的另一种方式是直接使用包含 type 属性的对象：12345678910muations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit(&#123; type: 'increment', amount: 10&#125;) Mutation 需遵守 Vue 的响应规则Vuex 的 store 中的状态是响应式的，\b所以当我们变更状态时，监视状态的Vue组件也会自动更新。 意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在 store 中 初始化所有需要的属性 当需要在对象上添加新属性时： 使用 Vue.set(obj, ‘newProp’, 123) 或者 以新对象替换\b旧对象。例如，使用 stage-3 的 对象展开运算符：1state.obj = &#123; ...state.obj, newProp: 123 &#125; 使用常量替代 Mutation 事件类型使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：12345678910111213141516// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from 'mutation-types'const store = new Vuex.store(&#123; state: &#123;...&#125;, mutation: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) 使用常量对于多人协作的大型项目很有帮助， 但不是必需的。 Mutation 必须是同步函数mutation必须是同步函数 在组件中提交 mutation在组件中使用 this.$store.commit(&#39;xxx&#39;) 提交 mutation ，或者使用 mapMutation 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。123456789101112131415import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations ([ 'increment', // 将`this.increment()` 映射为`this.$store.commit('increment')` 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations([ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` ]) &#125;&#125; mutation都是同步事物，处理异步事物需要使用action. actionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 让我们来注册一个简单的 action：123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, motations: &#123; increment(state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) 分发 ActionAction 通过 store.dispatch 方法触发：1store.dispatch('increment') 可以在 action 内部进行异步操作：1234567action: &#123; incrementAsync(&#123;commit&#125;)&#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; Actions 支持同样的载荷方式和对象方式进行分发：12345678store.dispatch('incrementAsync', &#123; amount: 10&#125;)store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 来看一个官方文档上更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：12345678910111213141516actions: &#123; checkout (&#123; commit, state &#125;, products) &#123; // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =&gt; commit(types.CHECKOUT_SUCCESS), // 失败操作 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) &#125;&#125; 再来一个：1234567891011121314151617181920212223242526272829// action.jsimport axios from 'axios'let url = '...'async function loadmore(state) &#123; let details = state.details let resp = await axios.get(url) return resp.data&#125;export default &#123; async moreDetails(&#123;commit, state&#125;) &#123; commit('loadmore', await loadmore(state)) &#125;, changeAddress(&#123;commit, address&#125;) &#123; commit('CHANGEADDRESS', address) &#125;, async resetAddress(&#123;commit&#125;) &#123; let addresses = [] try&#123; let resp = await axios.get(`...`) addresses = resp.data &#125; catch(e) &#123; console.log(e) &#125; commit('CHANGEADDRESS', addresses) &#125;&#125; 在组件中分发 Action在组件中分发action有两种方式： 使用 this.$store.dispatch(&#39;xxx&#39;) 使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch来调用（需要在根节点注入store）来个官网的例子：12345678910111213141516import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 组合使用 Actionstore.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise。12345678910// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 Vuex官方API文档","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://mhynet.cn/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://mhynet.cn/tags/vuex/"}]},{"title":"移动端页面远程调试","date":"2018-05-05T11:27:02.000Z","path":"mobile-remote-debug.html","text":"本文记录一下移动端页面调试的方法，待日后有时间在详细说明相关步骤。 手机连接代理手机端调试页面都需要代理，IOS和安卓都一样，连接代理的方式因手机类型不同稍有差异，但是归纳起来只有开启权限、下载证书、配置代理几部分。首先需要在电脑上打开Charles应用程序，Charles官网是https://www.charlesproxy.com/，安装证书\b的方式都大同小异,在浏览器中打开charles官网，下载证书，然后安装。如果安装失败，\b很大的可能是浏览器权限或者手机设置不对。一般只需要在浏览器中打开Charles官网，连接代理后访问页面会自动下载代理。 安装证书连接完代理之后需要安装证书，否则无法解析https的数据。依次点击: 电脑上charles的help菜单 =&gt; SSL Proxying =&gt; ios手机：install Charles Root ceritificate in ios simulatore; Android手机： on a mobile devices or remote browser =&gt; 弹窗中的 chls.pro/ssl 输入到手机的浏览器中下载证书 =&gt; 在手机上点击该文件进行安装 =&gt; 部分手机的可以识别.pem证书，可以直接安装，不识别该类型文件的手机需要手动安装，请继续下面的操作 =&gt; 找到该证书文件所在资源管理器中的路径，记住它，QQ浏览器下载的路径一般在: Tentcent/QQfile_recv目录下 =&gt; 接下来是手动安装, 打开手机的设置 =&gt; 找到 “安全与隐私” 菜单，点进入，不同的手机菜单不同，请根据不同手机进行实际查找，进入该菜单下 =&gt; 在当前菜单或其子菜单中找到 “从存储设备安装” 菜单(华为mate20手机，在该目录下的 更多安全设置 -&gt; 加密与凭证 下) =&gt; 然后进入了资源管理器，找到刚才的证书路径，安装证书 不同的手机找中 “从存储设备安装”功能菜单的路径有差异，基本上都可以在安全与隐私菜单下面找到，有些手机可以在设置中直接搜索，极大地方便了查找。 安卓手机远程调试远程调试 Android 设备使用可以参考这本篇文章需要注意的是该方法必须使用Chrome浏览器，浏览器需要相关权限。 IOS手机远程调试IOS手机远程调试需要使用的是原生浏览器safari，同样需要数据线连接电脑，连接代理需要的相关设置 手机端：依次进入：设置 &gt; Safari &gt; 高级，然后开启Javascript 和 Web检查器 电脑端：打开 Safari 浏览器， 在设置里面打开： 设置 &gt; 高级 , 勾选最后面的 在菜单中显示“开发”菜单，在电脑用户名选项下勾选自动显示JSContext的网页检查器，然后在手机端的Safari浏览器中打开需要调试的页面，电脑Safari浏览器的开发菜单中会\b出现一个\b手机名称的选项卡，里面会显示出手机端\b在Safari中打开的所有页面，点击需要调试的\b页面即可。如果没有显示出来，重启电脑上的Safari浏览器即可。如果还么有，可能是数据线或者设置的问题，检查相关步骤有没有问题。","tags":[{"name":"安卓","slug":"安卓","permalink":"https://mhynet.cn/tags/安卓/"},{"name":"调试","slug":"调试","permalink":"https://mhynet.cn/tags/调试/"}]},{"title":"dispatchEvent的用法","date":"2018-05-04T03:58:31.000Z","path":"dispatchEvent.html","text":"浏览器事件一般被称为DOM事件，通常的用法是给某个DOM元素添加事件。浏览器中原生的DOM事件有很多，最常用的有以下几大类：鼠标事件、键盘事件、框架/对象事件、表单事件、剪切板事件、打印事件、多媒体事件、动画事件等。每一类都有若干个DOM事件。前端最常用的是鼠标事件和键盘事件，比如鼠标点击、键盘键入、移动端的touch等，Web页面与用户交互是通过DOM事件来完成的。最常用的事件列表这里不在罗列，可以在www.runoob.com上查。之前总结过DOM事件方面的\b知识，本文想说的是自定义事件的使用. 创建事件的方式早期的有createEvent()，但是目前已经过时了，现在常用的方式是使用构造函数的方式来创建事件。 事件触发一般通过用户在页面上的操作触发，但是也可以通过事件触发器来实现。在一些特殊情况下，用事件触发器来触发事件比用户的实际操作来触发事件更方便。 触发事件每种浏览器都有原生的方式，IE支持fireEvent()方法触发事件，标准浏览器都支持dispatchEvent()方法。简单介绍一下fireEvent()方式吧，下面是一段prototype.js的源码：12345678910111213141516var fireEvent = function fireEvent(element,event)&#123; if (document.createEventObject)&#123; // IE浏览器支持fireEvent方法 var evt = document.createEventObject(); return element.fireEvent('on'+event,evt) &#125; else&#123; // 其他标准浏览器使用dispatchEvent方法 var evt = document.createEvent( 'HTMLEvents' ); // initEvent接受3个参数： // 事件类型，是否冒泡，是否阻止浏览器的默认行为 evt.initEvent(event, true, true); return !element.dispatchEvent(evt); &#125;&#125;; dispatchEvent 事件触发器 早期的创建事件的方式： 123var event = document.createEvent('Event'); // 一个参数\b， 表示事件类型event.initEvent('build', true, true); // 三个参数，eventName事件\b类型、canBubble是否冒泡、preventDefault是否阻止事件的默认操作document.dispatchEvent(event) // 参数为事件对象 构造函数方式 123456789var event = new Event('build');//监听事件document.addEventListener('build', function (e) &#123; // e.target matches document from above&#125;, false);// 触发事件document.dispatchEvent(event); 再举个可以给事件传值的例子，可以将触发事件定义在一个方法内:12345678910111213141516let obj = &#123; name: 'mhy', age: 23&#125;let evt = new Event('haha')function handler(e) &#123; let o = e.eventBody console.log('addevt', o) console.log('evt', evt)&#125;document.addEventListener('haha', handler, false)function disPatchEvt(obj) &#123;2evt.eventBody = obj2document.dispatchEvent(evt, obj)&#125;disPatchEvt(obj) 以上例子中所传的数据可以是任\b任意类型的数据，通过这种方法基本可以满足任意标准浏览器环境下通过自定义事件的需求。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"dispatchEvent","slug":"dispatchEvent","permalink":"https://mhynet.cn/tags/dispatchEvent/"},{"name":"Event","slug":"Event","permalink":"https://mhynet.cn/tags/Event/"}]},{"title":"window对象之屏幕尺寸相关的属性","date":"2018-03-15T05:12:19.000Z","path":"window-screen-property.html","text":"window对象中屏幕尺寸相关的属性window.screenX 和 window.screentY返回浏览器窗口左上角相对于屏幕左上角的（0,0)的水平距离和垂直距离， 单位为像素。 window.innerWidth 和 window.innerHeight返回当前浏览器窗口可视部分的宽度和高度, 即“视口”（viewport）, 单位像素。这两个属性包含滚动条的尺寸。当用户放大网页尺寸的时候，这两个属性的值会变小，因为这时网页的像素大小不变，只是每个像素占据的屏幕空间变大了，因为可见部分（视口）就变小了。 window.outerWidth 和 window.outerHeight返回浏览器窗口的高度和宽度，包括浏览器菜单栏和边框，单位为像素。 window.pageXOffset 和 window.pageYOffset返回页面的水平和垂直滚动距离， 单位为像素。 window对象中屏幕滚动相关的方法window对象中屏幕滚动相关的方法最常用的有window.scrollTo(x, y) 和window.scrollBy(x, y)， 单位都是像素。 window.scrollTo()该方法用于将网页的指定位置（参数坐标位置），滚动到浏览器的左上角。参数是相对于整张网页的坐标。1window.scrollTo(0, 1000); window.scrollBy()该方法用于将网页滚动指定距离。两个参数分别为向右滚动的距离和项下滚动的距离，如果为负值，则向相反的方向滚动。1window.scrollBy(0, window.innerHeight);","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"window","slug":"window","permalink":"https://mhynet.cn/tags/window/"}]},{"title":"ES6之Set和Map","date":"2018-03-08T07:28:03.000Z","path":"ES6-Set-and-Map.html","text":"Set和Map是ES6新增的数据结构, Set类似于数组，Map类似于对象。 SetSet的元素可以是任何类型的数据，但是都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set实例。生成Set实例用\bnew操作符。 生成Set实例12const arr = [1,2,3,3, [1,2,3], &#123;name:'li',age:22&#125;];let set = new Set(arr) 1234const set = new Set();[1,2,2,3,4,5,5].forEach(e =&gt; set.add(e));console.log(set); //Set &#123; 1, 2, 3, 4, 5console.log(set.size); // 5 123456let obj = &#123;&#125;;const set = new Set(obj); //Set &#123;&#123;&#125;&#125;set.add(obj); // Set &#123;&#123;&#125;&#125;set.add(obj); // Set &#123;&#123;&#125;&#125;set.add(&#123;&#125;); // Set &#123;&#123;&#125;, &#123;&#125;&#125;set.add(&#123;&#125;); // Set &#123;&#123;&#125;, &#123;&#125;&#125; Set的属性和方法size属性返回Set实例的元素数量123const arr = ['s','s', 2,3,3];const set = new Set(arr); // Set &#123;'s', 2, 3&#125;set.size; // 3 \b#### \badd(value) add() 方法用于向Set的末尾添加元素，可以添加任何类型的数据(包括Set类型)。如果set中有该元素，则不添加；添加某个值，返回 Set 结构本身。例子见上面。链式写法:1234let s = new Set() .add(3) .add(2) .add(1); delete(value)delete方法用于删除Set实例中的元素，删除的元素为传入的参数。返回值为布尔值， 如果实例中有该参数值，删除并返回true，否则返回false.1234const arr = ['s','s', 2,3,3];const set = new Set(arr); // Set &#123;'s', 2, 3&#125;set.delete('s'); // trueset.delete('s'); // false has(value)has方法用来检查set实例中是否包含某个值， 如果有则返回true, 否则返回false。12345const arr = ['s','s', 2,3,3];const set = new Set(arr); // Set &#123;'s', 2, 3&#125;set.has('s'); //trueset.delete('s'); // trueset.has('s'); //false clear()clear方法用于清空Set\b。没有返回值。123const set = new Set([1,2,3,4,5]);set.clear();console.log(set); // Set &#123;&#125; Set 的遍历方法Set有四个遍历方法。 keys()、values()和 enttries()keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for…of循环遍历 Set。123456789101112Set.prototype[Symbol.iterator] === Set.prototype.values// truelet set = new Set(['red', 'green', 'blue']);//for (let x of set) &#123; console.log(x);&#125;// red// green// blue forEach()Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。 另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。123let set = new Set([1,2,3,4,5,5,6,6]);set.forEach(item =&gt; console.log(item) )console.log(set) 遍历器的应用数组去重数组去重的方法：1234let arr = [1,2,2,'2','s','s'];console.log([...new Set(arr)]);// orArray.from(new Set(arr)); 数组的map和filter方法也可以间接用于 Set1234567//数组的map()let set = new Set([1,2,3,4,5,5,6,6,7]);set = new Set([...set].map(item =&gt; `$&#123;item&#125;&lt;----&gt;$&#123;item * 2&#125;`))//数组的filterlet set = new Set([1, 2, &#123;name: 'li', age: 22&#125;, &#123;name: 'wang', age: 22&#125;, &#123;name: 'li', age: 24&#125;]);let s = new Set([...set].filter(item =&gt; item instanceof Object &amp;&amp; item.age == 22 )) 实现并集（Union）、交集（Intersect）和差集（Difference)1234567891011let a = new Set([1,2,3,4]);let b = new Set([1,3,5,7]);// 并集 unionlet nuion = new Set([...a, ...b]);// 交集let intersect = new Set([...a].filter(item =&gt; b.has(item)));// 差集let difference = new Set([...a].filter(item =&gt; !b.has(item))); 直接在遍历操作中改变原来的 Set 结构123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 MapMap和对象类似，都是存储的键值对，不同之处在于对象的键只能是字符串，而Map的键可以为任意类型的数据。 生成Map实例12345let m = new Map([ ['name', 'lili'], ['age', 22], ['sex', 'male']]); Map的属性和操作方法Map的属性sizeMap的size属性和Set的size属性类似，返回Map结构的成员总数。1m.size; // 3 set(key, value)Map的set()方法\b用于向Map实例中添加新成员，该方法有两个\b参数，分别为Map实例的键和值。如果键key已存在，则更新值value。返回Map结构。12let m = new Map();m.set('name', 'liu'); // Map &#123;'name', 'liu'&#125; 可以采用链式写法：1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); get(key)Map的get()方法用于查询Map实例的成员， 参数为键, 返回该键key所对应的值value。123let m = new Map(['name', 'lili']);m.get('name'); // 'lili'm.get('age'); // undefined has(key)Map结构的has()方法用来判断某个键是否在该Map结构中， 返回布尔值。123let m = new Map('name', 'wang');m.has('name'); // turem.has('sex'); // false clear()同Set的clear()方法， 用于清空所有成员\b， 没有返回值。 delete(key)删除某个键， 删除成功返回true, 否则返回false。 Map的遍历方法Map的遍历方法有keys(), values(), entries(), forEach().Map 的遍历顺序就是插入顺序。与for…of循环组合使用很好用。123456789101112131415161718let m = new Map([ ['name', 'lili'], ['age', 22], ['sex', 'male']]);for(let key of m.keys()) &#123; console.log(key)&#125;for(let [key, value] of m.entries()) &#123; console.log(key, value)&#125;// 等同于使用m.entries()for (let [key, value] of m) &#123; console.log(key, value);&#125; 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。 Map 转换为其他数据结构Map&lt;==&gt;数组转为数组结构，可以\b用展开符：123456789101112131415161718// 数组转为Mapconst map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);// Map转为数组[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map] Map\b&lt;==&gt;Object1234567function strMapToObj(map) &#123; let obj = Object.create(null); // 该方法创建的对象没有原型， 参数为null for(let [k,v] of map.entries()) &#123; obj[k] = v; &#125;&#125; 如果Map的键为字符串可以无损转为对象，如果不是字符串\b则转化为字符串，然后转为对象。1234567function strObjToMap(obj) &#123; let map = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return map;&#125; Map &lt;==&gt; JSON1234567891011121314// JSON -&gt; Mapfunction JSONToMap(str)) &#123; return strObjToMap(JSON.parse(str))&#125;// Map -&gt; JSON//键名为字符串function strMapToJSON(strMap) &#123; return JSON.stringify(strMapToObj(strMap))&#125;// 键名为非字符串function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"}]},{"title":"MySQL学习笔记","date":"2018-03-03T03:35:30.000Z","path":"MySQL-notes.html","text":"MySQL数据库学习笔记。MySQL环境搭建可查阅资料，此处不细说。默认已搭建好MySQL环境。 1.授权、登录相关启动MySQL服务常用命令: 启动mysql服务：sudo start mysql 或者 sudo service mysql start 停止mysql服务：sudo stop mysql 或者 sudo service mysql stop 重启mysql服务： sudo restart mysql 或者 sudo service mysql restart 查看mysql数据库的版本号：mysql -V 启动mysqld服务: sudo /etc/init.d/mysql start 停止mysqld服务: sudo /etc/init.d/mysql stop 启动mysqld服务: sudo /etc/init.d/mysql restart \b以root\b用户登录MySQL1mysql -uroot -p 然后输入密码，登录成功后输入以下命令，创建个人用户：1create user mhy inentified by '123'; 用户名为: mhy, 密码为: 123。 授权创建用户\b后需要进行授权， 授权命令格式: grant [privilegesCode] on [dbName.tableName] to [username@host] identified by [&quot;password&quot;]; []内的项需要根据自己的情况\b选择。 12grant all privileges on test.* to mhy@localhost identified by '123';flush privileges; privilegesCode代表授予的权限，常用的权限类型有： all privileges 所有权限 \bselect 读取权限 delete 删除权限 update 更新权限 create 创建权限 drop 删除数据库、数据表权限 dbName.tableName表示授予权限的数据库和数据表，常用的类型\b有以下几个： . 授予该数据库服务器上所有的数据库的权限 dbName.* 授予dbName数据库上所有数据表的权限 dbName.dbTable 授予\bdbName数据库的dbTable数据表的权限 username@host表示授予权限的用户及允许该用户登录的IP地址。其中Host有以下几种选择： localhost 只允许本地登录，不允许远程登录。 % 允许在除本机之外的任何一台机器远程登录。 192.168.33.21 具体的IP地址，\b表示允许该用\b户从特定的IP登录。 password 指定该用户登录时的密码。 flush privileges 表示刷新权限变更。 运行以下命令可以删除用户：1drop user zhangsan@'%'; 查看用户mhy的权限用以下命令：1show grants for 'mhy'; 2.创建、修改和删除数据库 database创建数据表创建数据库\b命令, \bdbName为数据库名字：1create database dbName; 删除数据库：1drop database dbName; 查看所有数据库：1show databases; 修改数据表\b\b修改数据表更多的是修改数据表的结构。使用alter table语句。 删除字段\b用 drop 1alter table tableName drop 字段名; 添加字段用 add 1alter table tableName add 字段名 数据类型 [可选项]; 修改字段名称和类型有两种方式：modify和change 1alter table tableName modify 字段名 [char(20)] 可选项中\b可以是数据类型。 change语句除了重新定义字段，还可以重命名字段：1alter table tableName change 原字段名 新字段名 char(10); 修改数据表名1alter table tableName rename to newTableName; 还可以修改字段的默认值。 如果引擎\b是innodb的话，数据库名称不能修改，其他引擎\b的数据库重命名有数据丢失的\b风险，所以在创建数据库的时候命名切勿草率。 3.创建和修改\b数据表 table创建数据表之前需要选择数据库，使用以下命令选择数据库：1use dbName; 选择数据库之后就可以创建数据表了，创建数据表的时候需要填写的\b有表名、表的字段名称、\b每个字段的数据类型，还有其他可选项主键（PRIMARY KEY）、外键（）、自动增长（AUTO_INCREMENT）、默认值（DEFAULT）、是否允许为空（NOT NULL）等。ENGINE=InnoDB设置引擎，引擎一般\b会在配置文件中设置，如果要建的数据表的引擎和配置文件不一样需要在此处指明。12345create table tableName ( 字段1 数据类型 [其他可选项]， 字段2 数据类型 [其他可选项]， ...) [ENGINE=InnoDB DEFAULT CHARSET=utf8]; []内的项为可选项，最后面的ENGING DEFAULT CHARSET也是可选项，一般都会在配置文件中设置，\b不需要在创建表时\b进行设置。创建数据表的具体实例稍后讲了mysql的数据类型和约束后在将。查看数据表：1show tables [from dbName]; 查看表结构：1show columns from tableName; 数据表删除的三种语句drop、delete和truncate的异同： 相同点： truncate和delete只删除表数据保留表结构； truncate和不带where子句的delete，以及drop都能删除表内的数据. 不同点： drop整个删除数据表，速度最快； delete删除数据表中的数据，可以加入条件语句where，\b需要先查询符合条件的数据然后删除，如果不加条件语句，则清空所有数据; truncate清空表内数据，\b但不删除数据表结构。123456789101112#删除数据表（结构、属性、索引）drop table tableName;# 删除某一行delete from tableName Where volumnName=values;# 删除所有数据delete from tableName；# ordelete * from tableName#清空数据truncate table tableName; 对于有主外键关系的表，不能使用truncate而应该使用不带where子句的delete语句，由于truncate不记录在日志中，不能够激活触发器。 4.SQL数据类型SQL语句常见的\b数据类型有字符串、数字和日期三大类。 字符串类型CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 数值类型 日期时间类型 合理选用数据类型\b对于提高MySQL性能具有非常重要的意义，这一块可以参考《高性能MYSQL》进行学习。 5.约束约束主要完成对数据的检验和限制，从而保证数据库的完整性。常见的约束有以下几种： 外键约束(foreign key) 主键约束(primary key) 唯一值约束(unique) 自增长约束(auto_increment) 默认值约束(default) 非空约束(not null) 主键约束（primary key)主键约束列不能重复，任意两行的主键\b值都不能相同，也不能为空值。一般每一张数据表都有一个约束，通常为\bid，最好不要把业务字段设为主键，因为可能会有重复的数据。创建数据表的时候在需要\b创建主键约束的字段后面的可选项位置加入 primary key 即可。拥有主键约束的表插入\b数据时，拥有主键约束的字段的数据重复或为空时会报错。\b常见的操作：12345678910111213141516171819# 创建数据表时加入主键的两种方法create table tableName ( 字段名1 数据类型 primary key, 字段名2 数据类型);create table tableName ( 字段名1 数据类型, 字段名2 数据类型, constraint 约束名 primary key(字段名1));# 添加主键 列名columnName如果为多个时建立联合主键alter table tableName add primary key(columnName);# 删除主键约束alter table tableName drop primary key;# 修改列为主键alter table tableName modify 字段名 数据类型 primary key; 联合主键:联合多个列建立联合\b主键。 外键约束（foreign key）外键约束的作用是\b建立两张表之间的联系，保持数据的一致性。表的外键可以是另一张表的主键或唯一索引或唯一约束。外键可以有重复的, 可以是空值。实现一对一或一对多关系。创建外键约束实例：12345678910111213141516171819202122# 创建父表create table fatherTable( id int primary key, title varchar(10));# 创建子表，建立外键有两种方式# 第一种：添加关键字create table sonTable( id int auto_increment, name varchar(20), constraint son_id primary key(id), father_id int references fatherTable(id));# 第二种： 额外声明 son_id 为主键的名字，fa_tab_id为外键的名字create table sonTable( id int auto_increment, name varchar(20), constraint son_id primary key(id), father_id int, constraint fa_tab_id foreign key(father_id) reference fatherTable(id)); 加外键约束的条件： 父表和子表必须使用相同的存储引擎， 数据表的存储引擎只能为InnoDB,default-storage-engine-INNODB 外键列和参照列必须具有相似的数据类型，数字的长度或是有符号位必须相同，而字符 的长度可以不同 外键列和参照列必须创建索引，如果外键列不存在索引的话，MySQL将自动创建索引。 设定参照列:FOREIGN KEY(id) PEFERENCES provinces(id)123456# 删除外键约束alter table tableName drop foreign key 外键约束名;(创建外键的方法没有指定约束名称，系统会默认给外键约束分配外键约束名称，命名为student_ibfk_n)# 增加外键约束alter table tableName add foreign key 列名 references 父表(对应列名); 唯一约束（unique key）unique key的用途：主要是用来防止数据插入的时候重复。创建数据表时在字段后面加入unique key即可建立唯一约束。也可以单独设置：1alter table tableName modify columnName char(20) unique key; 6.插入和\b修改记录建立好数据表之后就可以插入数据了。 插入数据插入数据使用insert into语句，具体如下：12insert into tableName (字段1, 字段2, 字段3,...字段n) values (值1, 值2, 值3, ...值n);# 如果数据为字符串，必须加引号。 注意：以上语句插入数据的时候必须要保证一致性，即前后\b必须一一对应。还有一种方式：1insert into tableName (字段1=值1, 字段2=值2, ...); 修改数据update set命令用来修改表中的数据。update set命令格式：1update tableName set 字段=新值, ... where 条件; 7.查询数据查询使用select语句。select 查询项 from \btableName [where 条件]","tags":[{"name":"mysql","slug":"mysql","permalink":"https://mhynet.cn/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"https://mhynet.cn/tags/数据库/"}]},{"title":"window对象之screen","date":"2018-02-28T04:49:02.000Z","path":"window-screens.html","text":"window.screen返回当前window的screen对象。screen对象实现了Screen接口，它是个特殊的对象，返回当前渲染窗口中和屏幕有关的属性。 screen.availWidth - 可用的屏幕宽度screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏。 screen.availHeight - 可用的屏幕高度screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏。 属性 说明 availHeight 返回屏幕的高度（不包括Windows任务栏） availWidth 返回屏幕的宽度（不包括Windows任务栏） colorDepth 返回目标设备或缓冲器上的调色板的比特深度 height 返回屏幕的总高度 pixelDepth 返回屏幕的颜色分辨率（每象素的位数） width 返回屏幕的总宽度","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"window","slug":"window","permalink":"https://mhynet.cn/tags/window/"}]},{"title":"window对象的属性和方法","date":"2018-02-25T02:12:19.000Z","path":"window-property-and-function.html","text":"在JavaScript语言中，DOM( Document Object Model) 是操作文档的API，document 是其的一个对象；而BOM是控制浏览器行为的API，window 是其的一个对象。 引用知乎上的解释,整个窗口中分为几个区域，其中： DOM\b管辖区域：E区归DOM管，是根据开发出来的网站文档（html,css,javascript）等渲染出来的页面。 BOM管辖区域其余的几个区域都归BOM管。 A区：浏览器的地址栏、标签栏、搜索栏、书签栏、菜单栏等。 B区：浏览器右键菜单。 C区：状态栏，document加载时显示http\b状态等信息。 D区：滚动条。BOM BOM 是浏览器对象模型，window是BOM的一个对象，window对象下有很多子对象，一起控制浏览器的行为。在浏览器中window对想为global对象。 window 对象表示一个包含DOM文档的窗口，其 document 属性指向窗口中载入的 DOM文档 。使用 document.defaultView 属性可以获取指定文档所在窗口。 window.scrollbars返回滚动条对象，可以检查其可见性。 window.scrollbars 有一个属性","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"window","slug":"window","permalink":"https://mhynet.cn/tags/window/"}]},{"title":"window对象之location","date":"2018-02-24T16:21:28.000Z","path":"window-location.html","text":"window.location 只读属性，返回一个 Location 对象，其中包含有关文档当前位置的信息。 window.location : 所有字母必须小写！尽管 window.location 是一个只读 Location 对象，你仍然可以赋给它一个 DOMString。这意味着您可以在大多数情况下处理 location，就像它是一个字符串一样：window.location = ‘http://www.example.com&#39;，是 window.location.href = ‘http://www.example.com&#39;的同义词 。 可以用location.href获取。要获得URL各个部分的值，可以这么写：123456location.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' 要加载一个新页面，可以调用12location.assign(url)location.href = url 如果要重新加载当前页面，调用location.reload()方法非常方便。 window.location.search 方法 reload()重新加载页面 assign()加载新文档 1- location.assign('https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location') replace()使用新文档替换当前文档","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"window","slug":"window","permalink":"https://mhynet.cn/tags/window/"}]},{"title":"window对象之navigator","date":"2018-02-24T03:22:09.000Z","path":"window-navigator.html","text":"从今天开始会陆续学习window对象的属性，今天先学习window.navigator。window.navigator返回一个navigator对象的引用,可以用它来查询一些关于运行当前脚本的应用程序的相关信。在chrome浏览器中按快捷键alt + ⌘打开开发者工具，在console下输入navigator、回车，即可打印出navigator对象。 \b常用属性 navigator.userAgent返回当前浏览器的user agent字符串。该属性是navigatior对象用的最多的，常用于判断客户端类型判断浏览器类型123function goPAGE() &#123; return (navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))&#125; 请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本;正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算。 判断浏览器类型:1234567891011121314151617181920function getExploreName()&#123; var userAgent = navigator.userAgent; if(userAgent.indexOf(\"Opera\") &gt; -1 || userAgent.indexOf(\"OPR\") &gt; -1)&#123; return 'Opera'; &#125;else if(userAgent.indexOf(\"compatible\") &gt; -1 &amp;&amp; userAgent.indexOf(\"MSIE\") &gt; -1)&#123; return 'IE'; &#125;else if(userAgent.indexOf(\"Edge\") &gt; -1)&#123; return 'Edge'; &#125;else if(userAgent.indexOf(\"Firefox\") &gt; -1)&#123; return 'Firefox'; &#125;else if(userAgent.indexOf(\"Safari\") &gt; -1 &amp;&amp; userAgent.indexOf(\"Chrome\") == -1)&#123; return 'Safari'; &#125;else if(userAgent.indexOf(\"Chrome\") &gt; -1 &amp;&amp; userAgent.indexOf(\"Safari\") &gt; -1)&#123; return 'Chrome'; &#125;else if(!!window.ActiveXObject || \"ActiveXObject\" in window)&#123; return 'IE&gt;=11'; &#125;else&#123; return 'Unkonwn'; &#125;&#125; navigator.appName返回当前浏览器的正式名称,该名称可能是不”正确”的. navigator.appVersion返回当前浏览器的版本号,该值可能是不”正确”的. navigator.language返回一个字符串,表明当前浏览器的语言种类. navigator.platform返回一个字符串,表明当前所使用的系统平台类型.\b不常用属性 navigator.appCodeName返回当前浏览器的内部“代码”名称,该名称可能是不”正确”的. navigator.buildID返回当前浏览器的构建标识符 (例如: “2006090803”). navigator.connection提供有关设备的网络连接的信息. navigator.cookieEnabled返回一个布尔值,表明当前浏览器是否启用了cookies. navigator.doNotTrack返回用户配置中do-not-track项的值,如果值为”yes”,则网站和应用程序不会跟踪用户. navigator.id返回 id 对象,你可以用它来为自己的网站添加对BrowserID的支持. navigator.mimeTypes返回当前浏览器支持的MIME类型列表. navigator.mozBattery返回一个battery 对象,你可以用它来获取自己电脑上的电池的电量情况. navigator.mozNotification Mobile Only in Gecko 2.0 navigator.webkitNotification返回一个notification 对象,你可以用它来向使用你的web应用程序的用户发送通知. navigator.mozTelephony Mobile Only in Gecko返回一个DOMTelephony 对象,你可以用它来创建和管理手机通话. navigator.onLine返回一个布尔值,表明当前浏览器是否正常联网. navigator.oscpu返回一个字符串,表明当前所使用的操作系统类型. navigator.plugins返回一个包含了浏览器中所有已安装的插件对象的数组. navigator.product返回当前浏览器的产品名称(例如: “Gecko”). navigator.productSub返回当前浏览器的构建编号(例如: “20060909”). navigator.securitypolicy返回一个空字符串. 在Netscape 4.7x中, 返回”US &amp; CA domestic policy” 或者 “Export policy”. navigator.vendor返回当前浏览器的浏览器供应商名称, (例如: “Netscape6”) navigator.vendorSub返回当前浏览器的浏览器供应商名称的版本号 (e.g. “6.1”). navigator.webkitPointer返回一个Mouse Lock API中的PointerLock对象. 方法 navigator.javaEnabled表明当前浏览器是否启用了对Java的支持. navigator.mozIsLocallyAvailable检测一个URI资源在脱机状态是否可用. navigator.preference 已废弃 Gecko 2.0设置一个用户配置. 该方法只能在特权代码中使用,目前已经废弃,你应该使用XPCOM Preferences API 来代替. navigator.registerContentHandler允许网站将自己注册成为一个给定MIME类型的内容的处理程序. navigator.registerProtocolHandler允许网站将自己注册成为一个给定协议的处理程序. navigator.taintEnabled 已废弃 Gecko 1.7.8 已废弃 Gecko 9.0返回false. 表明浏览器是否支持taint/untaint功能.已在JavaScript 1.2中删除. navigator.vibrate()如果设备支持震动(手机或其他),则触发设备震动.","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"window","slug":"window","permalink":"https://mhynet.cn/tags/window/"}]},{"title":"深浅拷贝方法总结","date":"2018-02-21T08:45:52.000Z","path":"deep-clone-js.html","text":"一.Javascript中的深浅拷贝由来：javascript中数据格式分为基本类型和引用类型，5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。 JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 二.浅拷贝\b1.引用复制2.遍历赋值拷贝：1234567function shallowClone(obj) &#123; var o = &#123;&#125;; for(var key in obj) &#123; o[key] = obj[key]; &#125; return o;&#125; 3.Object.assign()Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。123456var obj = &#123; a: 1, b: 2, c: &#123;d: 'ai', e: 'BB'&#125;&#125;;var o = Object.assign(&#123;&#125;, obj);console.log(objc.d === o.c.d); // true 4.Array.concat() 和 Array.slice()方法\bconcat()和sluce()返回不同的数组实例，但是对于数组的对象元素，只是拷贝了指针。 三.深拷贝1.JSON对象的parse()和stringify()JSON对象的parse()和stringify()方法连用可以实现深拷贝。可以实现深拷贝的情况：123456789101112var obj = &#123; name: 'mhy', age: 22, other: &#123; sex: 'male', city: 'beijing' &#125;&#125;var p = JSON.parse(JSON.stringify(obj))p.other.city = 'shanghai';console.log(obj.other.city); // 'beijing' 对于一般的情况而言，\b该方法可以实现深拷贝。不能实现的情况：123456var obj = &#123; name: 'xxx', fn: function()&#123;console.log('this is a function')&#125;&#125;;var o = JSON.parse(JSON.stringify(obj));console.log(o.fn); // undefined 对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。同时如果对象中存在循环引用的情况也无法正确处理。 2.jQuery.extend()12345678910var obj = &#123; name: 'mhy', age: 22, other: &#123; sex: 'male', city: 'beijing' &#125;&#125;;var o = $.extend(true, &#123;&#125;, obj)// jQuery 的 extend() 方法可以实现\b深浅拷贝， 第一个参数为true时为深拷贝，否则为浅拷贝。 3.递归123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== 'object')&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === 'object' ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;; 其他库的deepClone方法","tags":[{"name":"深拷贝","slug":"深拷贝","permalink":"https://mhynet.cn/tags/深拷贝/"}]},{"title":"对象的方法汇总","date":"2018-02-17T07:25:27.000Z","path":"functions_of_object.html","text":"Javascript语言中，对象Object是该语言重要的数据结构\b之一，掌握对象的属性和方法是学好该语言的必要条件。 Object构造函数的属性Object.length值为1。 Object.prototypeObject.prototype属性表示Object的原型对象可以为所有 Object 类型的对象添加属性几乎所有的 JavaScript 对象都是 Object 的实例；一个典型的对象继承了Object.prototype的属性（包括方法），尽管这些属性可能被遮蔽（也被称为覆盖）。然而，一个Object可能是故意创建的，这是不确定的（例如通过Object.create(null)），或者它可能被改变，所以这不再是准确的（例如Object.setPrototypeOf）。 改变Object原型，会通过原型链，而改变所有对象；除非这些属性和方法被其他对原型链更里层的改动所覆盖。这提供了一个非常强大的、但有潜在危险的机制，来覆盖或扩展对象行为。 Object构造函数的方法:Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 1.语法：Object.assign(target, ...sources)如果目标对象的属性和源对象具有相同的键值，则\b后来的源的属性将覆盖早先的属性。Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 String类型和 Symbol 类型的属性都会被拷贝。注意，Object.assign 不会跳过那些值为 null 或 undefined 的源对象。 针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。 2.复制对象 &amp; 合并对象12var obj = &#123;name: 'mhy',city: 'beijing'&#125;;let obj1 = Object.assign(&#123;&#125;, obj, &#123;city: 'tianjin', age: 22&#125;); //&#123;name: \"mhy\", city: \"tianjin\", age: 22&#125; 3.深拷贝问题针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。对象的深拷贝可以使用JSON.parse(JSON.stringify(obj))实现， 但是该方法在拷贝时会忽略方法和原型。还有一种方式是递归。jQuery 的extend方法也可以实现深拷贝$.extend(true, {}, ...) 12345678910111213141516171819202122232425262728function test() &#123; 'use strict'; let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj2 = Object.assign(&#123;&#125;, obj1); console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj1.a = 1; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; obj2.a = 2; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125; obj2.b.c = 3; console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125; console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125; // 深拷贝 obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;&#125;test(); 4.拷贝 symbol 类型的属性123456var o1 = &#123; a: 1 &#125;;var o2 = &#123; [Symbol('foo')]: 2 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2);console.log(obj); // &#123; a : 1, [Symbol(\"foo\")]: 2 &#125;Object.getOwnPropertySymbols(obj); // [Symbol(foo)] 5.继承属性和不可枚举属性是不能拷贝的123456789101112var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。 bar: &#123; value: 2 // bar 是个不可枚举属性。 &#125;, baz: &#123; value: 3, enumerable: true // baz 是个自身可枚举属性。 &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; Object.create()使用指定的原型对象和属性创建一个新对象。 1.语法: Object.create(proto[, propertiesObject])2.用 Object.create实现类式继承123456789101112131415161718192021222324// Shape - 父类(superclass)function Shape() &#123; this.x = 0; this.y = 0;&#125;// 父类的方法Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info('Shape moved.');&#125;;// Rectangle - 子类(subclass)function Rectangle() &#123; Shape.call(this); // call super constructor.&#125;// 子类续承父类Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;// 因为使用“.prototype =...”后,constructor会改变为“=...”的那个// constructor，所以要重新指定.constructor 为自身。 1234567var rect = new Rectangle();console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // trueconsole.log('Is rect an instance of Shape?', rect instanceof Shape); // truerect.move(1, 1); // Outputs, 'Shape moved.' 1234567891011121314151617181920function Father() &#123;2this.city = 'beijing';2this.lastName = 'ma';&#125;Father.prototype.where = function () &#123;2console.log(\"where? \", this.city)&#125;function Son() &#123;2Father.call(this);&#125;Son.prototype = Object.create(Father.prototype);Son.prototype.constructor = Sonlet s = new Son()s.city;//s.lastName; //s.where(); // 3.使用混入\b模式继承到多个对象123456789101112131415function MyClass() &#123; SuperClass.call(this); OtherSuperClass.call(this);&#125;// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() &#123; // do a thing&#125;; Object.defineProperty()直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 1.语法：Object.defineProperty(obj, prop, descriptor) 2.参数 2.1 obj要在其上定义属性的对象。prop要定义或修改的属性的名称。 2.2 descriptor将被定义或修改的属性描述符。 在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。 Object.defineProperties()在一个对象上定义新的属性或修改现有属性，并返回该对象。 1.语法：Object.defineProperties(obj, props) 2.参数 2.1 obj 在其上定义或修改属性的对象。 2.2 props 要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键： configurabletrue 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。默认为 false enumerabletrue 当且仅当在枚举相应对象上的属性时该属性显现。默认为 false value与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。默认为 undefined.writabletrue当且仅当与该属性相关联的值可以用assignment operator改变时。默认为 false get作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。默认为 undefined set作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。默认为 undefined返回值传递给函数的对象。 Object.defineProperties本质上定义了obj 对象上props的可枚举属性相对应的所有属性。123456789101112var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'property1': &#123; value: true, writable: true &#125;, 'property2': &#123; value: 'Hello', writable: false &#125; // etc. etc.&#125;); Object.entries()返回给定对象自身可枚举属性的[key, value]数组。 Object.freeze()冻结对象：其他代码不能删除或更改任何属性。 Object.getOwnPropertyDescriptor()返回对象指定的属性配置。 Object.getOwnPropertyNames()返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。 Object.getOwnPropertySymbols()返回一个数组，它包含了指定对象自身所有的符号属性。 Object.getPrototypeOf()返回指定对象的原型对象。 Object.is()比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。 Object.isExtensible()判断对象是否可扩展。 Object.isFrozen()判断对象是否已经冻结。 Object.isSealed()判断对象是否已经密封。 Object.keys()返回一个包含所有给定对象自身可枚举属性名称的数组。 Object.preventExtensions()防止对象的任何扩展。 Object.seal()防止其他代码删除对象的属性。 Object.setPrototypeOf()设置对象的原型（即内部[[Prototype]]属性）。 Object.values()返回给定对象自身可枚举值的数组。 3.Object 实例和Object 原型对象:JavaScript中的所有对象都来自Object；所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖。例如，其他构造函数的原型将覆盖constructor属性并提供自己的toString()方法。Object原型对象的更改将传播到所有对象，除非受到这些更改的属性和方法将沿原型链进一步覆盖。 Object.prototype.defineGetter()关联一个函数到一个属性。访问该函数时，执行该函数并返回其返回值。 Object.prototype.defineSetter()关联一个函数到一个属性。设置该函数时，执行该修改属性的函数。 Object.prototype.lookupGetter()返回使用 defineGetter 定义的方法函数 。 Object.prototype.lookupSetter()返回使用 defineSetter 定义的方法函数。 Object.prototype.hasOwnProperty()返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。 Object.prototype.isPrototypeOf()返回一个布尔值，表示指定的对象是否在本对象的原型链中。 Object.prototype.propertyIsEnumerable()判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。 Object.prototype.toSource()返回字符串表示此对象的源代码形式，可以使用此字符串生成一个新的相同的对象。 Object.prototype.toLocaleString()直接调用 toString()方法。 Object.prototype.toString()返回对象的字符串表示。 Object.prototype.unwatch()移除对象某个属性的监听。 Object.prototype.valueOf()返回指定对象的原始值。 Object.prototype.watch()给对象的某个属性增加监听。","tags":[{"name":"Object","slug":"Object","permalink":"https://mhynet.cn/tags/Object/"}]},{"title":"面向对象和继承","date":"2018-01-19T05:48:35.000Z","path":"oop-and-inherit.html","text":"面向对象编程是目前最流行的编程方式\b之一。 面向对象 封装 、 继承、 多态 属性 property 方法 method 原型链1.工厂函数12345var s = function () &#123;2return &#123;22a: 12&#125;&#125;; 2.构造函数 constructor12345678910111213141516171819var s1 = function () &#123;2this.a = 'a';2this.b = 'b';&#125;;// 对象是引用类型，直接赋值只是把地址赋值，改变对象属性的时候可能两个对象都会变var s3 = s2var s4 = function() &#123;2this.a = 'a';2this.b = 'b';&#125;;s4.prototype.c = 'c';var p = new s4()；var p1 = new s4();p.__proto__ === s4.prototype // truep1.__proto__ === p.__proto__ // true 实例共享属性和方法用 构造函数 + 原型链 实现封装和继承调用new 操作符， 开辟内存空间, 返回this 继承 parent class &amp; child class12345678910111213141516var parent = function() &#123;2this.name = name;2this.age = age;&#125;;var child = function(name, age, title) &#123;2this.title = title;2// call 第一个参数手动指定this，2parent.call(this, name, age);2child.prototype.__proto__ = parent.prototype;&#125;;child.prototype.d = 'd';new child('mhy', 11, 'student');// child.prototype = new parent('mhy', 10); | - title : ‘student’| - name : ‘mhy’| - age : ‘11’| - proto | - -d : ‘d’ | - proto | -c : ‘c’ | - Object… Object.create(proto[. propertiesObject] 区别:12child.prototype = Object.create(parent.prototype)child.prototype.__proto__ = parent.prototype; 前者指向新的引用， 后者是在原来的引用基础上挂载新的属性 下面的例子演示了如何使用Object.create()来实现类式继承。这是一个所有版本JavaScript都支持的单继承。1234567891011121314151617181920212223242526272829// Shape - superclassfunction Shape() &#123; this.x = 0; this.y = 0;&#125;// superclass methodShape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info('Shape moved.');&#125;;// Rectangle - subclassfunction Rectangle() &#123; Shape.call(this); // call super constructor.&#125;// subclass extends superclassRectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;var rect = new Rectangle();console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // trueconsole.log('Is rect an instance of Shape?', rect instanceof Shape); // truerect.move(1, 1); // Outputs, 'Shape moved.'` 如果希望能继承到多个对象，则可以使用混入的方式。123456789101112131415function MyClass() &#123; SuperClass.call(this); OtherSuperClass.call(this);&#125;// inherit one classMyClass.prototype = Object.create(SuperClass.prototype);// mixin anotherObject.assign(MyClass.prototype, OtherSuperClass.prototype);// re-assign constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() &#123; // do a thing&#125;; ES6 实现继承 super 方法、 extends 指向父类的方法1234567891011121314151617181920212223class A &#123;2constructor(name, age) &#123;22this.name = naem;22this.age = age;2&#125;2eat() &#123;22console.log('eat');2&#125;&#125;class B extends A &#123;2constructor(naem, age, title) &#123;22super(name, age);22this.title = title;2&#125;2work() &#123;22console.log('work');2&#125;&#125;const c = new B('mhy', 12, 'student');c.eat();c.work(); B 的 super()指向A的构造函数。","tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://mhynet.cn/tags/面向对象/"},{"name":"继承","slug":"继承","permalink":"https://mhynet.cn/tags/继承/"}]},{"title":"使用hexo+github搭建免费个人博客","date":"2017-12-23T16:00:00.000Z","path":"hexo-for-blog.html","text":"前言（本文是刚开始学习hexo搭建博客的时候参考了很多博客记录的，内容比较分散。后来因多次在不同设备上搭建环境，总结了一些个人认为比较有用的知识点，尤其是多设备下搭建方面，记录在该项目的README下，欢迎查阅）。 最开始搭建部分参考了这篇文章，记录了hexo+github搭建博客的方案，后面又新增了评论、页面访问量、https服务、主题配置、多终端配置、百度和google站长验证、 百度统计、google analytics、SEO优化等部分，搜集了很多资料，可能某些部分不是很详细但是比较全面。 使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 其他优点 准备工作在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git和命令行工具 搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 - http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 绑定域名当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。 首先你要注册一个域名，域名注册以前总是推荐去阿里云，价格也不贵，毕竟是大公司，放心！ 绑定域名分2种情况：带www和不带www的。 域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下：然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试： 如果你填写的是没有www的，比如 mygit.me，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://&gt;- mygit.me 如果你填写的是带www的，比如 www.mygit.me ，那么无论是访问 http://www.mygit.me 还是 http://mygit.me ，都会自动跳转到 http://&gt;- www.mygit.me 如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 http://abc.mygit.me 没问题，但是访问 http://mygit.me ，不会自动跳转到 &gt;- http://abc.mygit.me 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 注：后期补充，主域名前带不带www在百度站长验证时时区分的，所有必须明确在所有情况下一致，如果不带www可以在域名解析时设置自动跳转。 配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。1cd ~/.ssh # 查看该文件夹下有没有ssh key 文件 如果没有ssh key，可以使用以下命令创建自己的key。1ssh-keygen -t rsa -C \"邮件地址\" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到~/.ssh/id_rsa.pub文件，打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功1ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：Hi mhy! You&#39;ve successfully authenticated, but GitHub does not provide shell access., 看到这个信息说明SSH已配置成功！ 此时你还需要配置：12git config --global user.name \"用户名\"// 你的github用户名，非昵称git config --global user.email \"邮箱\"// 填写你的github注册邮箱 这个配置展示在你每次提交的git message中。 使用hexo写博客hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些markdown文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项安装之前先来说几个注意事项： 使用windows的用户，很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git &gt;- bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所有使用时注意区分版本； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的_config.yml； 安装1npm install -g hexo 初始化在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是~/Workspaces/hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。12cd ~/Workspaces/hexohexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：1234567891011121314151617.├── .deploy_git/├── public/├── scaffolds│ ├── draft.md│ ├── page.md│ └── post.md├── source│ ├── CNAME│ ├── _data│ ├── _posts│ ├── about├── themes/├── LICENSE├── README.md├── _config.yml└── package.json 其中，public目录是打包后写入静态资源的目录，建议写入.gitignore文件不使用git进行版本管理；source/_post目录是存放markdown博客文章的地方；theme目录是存放博客主题的地方，可以安装你喜欢的多个主题，想启用哪个修改根目录下 _config.yml的配置选项theme即可，主题文件夹可以加入版本库，也可以使用git modules进行管理。 12hexo generate # 打包生成htmlhexo sever # 启动本地开发服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件。hexo sever是开启本地开发服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：http://blog.liuxianan.com/windows-port-bind.html。 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，可以自定义主题。 修改主题选择一个好看的主题对于一个博客来说还是比较重要的。当然也可以自己写一套主题，新手建议去hexo主题页面选择一套自己喜欢的主题。这里已hexo-theme-yilia主题为例，说一下配置过程。首先下载这个主题：12cd ~/Workspaces/hexogit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改项目根目录下的_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 上传之前使用git进行版本管理（不会使用git创建仓库的建议去查阅相关资料）时要注意选择正确的分支，github pages渲染博客时设置master分支为主分支, 该分支不可手动编辑，因为该分支为github pages服务的静态资源存放位置，开发编辑博客必须在其他分支，即博客项目的源代码必须在其他分支，万一弄错了分支会有大量的代码冲突。 上传到github如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。使用git推送hexo博客需要用到一个插件hexo-deployer-git， 先安装一下：12npm install hexo-deployer-git --save` 推送之前，ssh key肯定要先配置好。其次，配置_config.yml中有关deploy的部分：1234deploy: type: git repository: git@github.com:mhy-web/mhy-web.github.io.git branch: master # hexo会把打包后的静态资源自动推送到该分支 然后可以发布博客了，执行以下命令：12345# 先编译hexo g # 是hexo generate命令的缩写# 发布hexo d # hexo deploy命令的缩写 当然了，打包之前有一些配置选项需要注意一下，可以忽略指定目录，具体使用方法可以参考官网。1234567891011source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: lang#跳过source目录下文件的编译, 跳过指定文件的渲染，可使用glob表达式来匹配路径。skip_render: - _test/* # 两个 ** 表示该目录的所有下级目录, 但是两个**会报错，可能是主题里面的配置没有兼容 - _data/* 常用hexo命令常见命令1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写：1234hexo n # == hexo newhexo g # == hexo generatehexo s # == hexo serverhexo d # == hexo deploy 组合命令：12hexo s -g #生成并本地预览hexo d -g #生成并上传 _config.yml这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 写博客定位到我们的hexo根目录，执行命令：1hexo new 'my-first-blog' hexo会帮我们在_posts下生成相关md文件我们只需要打开这个文件就可以开始写博客了，默认格式可以在scaffolds目录下设置，使用方法请查阅 官方文档。当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 一般完整格式如下：123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: # 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---&lt;!-- 以下是正文 --&gt; 首页显示摘要默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？ 答案是在合适的位置加上即可。 最终效果可以访问我的博客来查看效果：http://mhynet.cn 后期优化阅读量统计阅读量统计以前使用过LeanCloud,配置可以参考这篇教程。12345# add post viewsleancloud_visitors: enable: true app_id: #你的app_id app_key: ##你的app_key 现在使用的是卜算子统计，配置方式每个主题可能实现方式都不一样，可以参考这篇教程。 评论系统查阅了一些评论相关的介绍, 最后选用的来必力。配置方式参考自这里。评论系统的配置在主题的配置文件_config.yml中，修改livere_uid的配置值为来必力获取到的data-uid。123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 部署到github 和 gitee最开始做的时候只是部署到github, 并且将自己的域名mhynet.cn解析到GitHub上，这样可以通过自己的域名访问博客。后来因为国内访问Github慢的原因将博客备份到了Gitee,但是还有个问题，Gitee并不支持域名解析，所以无法配成成通过自己的域名来访问Gitee。这个问题还在探索中。这里要记录的是配置推送到Gitee和Github的方法。博客发布hexo d同时推送的配置是在根目录:12345678deploy: type: git repository: github: # github gitee: # 码云 name: mhyuan email: dsz9258@163.com branch: master 推送hexo分支的源文件需要使用git本身的功能，配置多个remote地址，这里参考了廖雪峰老师的博客,但是我的Github的远程库的名字还是使用的是origin，仅仅设置了Gitee的远程库名称。 注：我现在的博客不在使用github pages了，现在部署在了七牛云自己的服务器上，CDN使用的是国外的免费CDN服务商cloudflare，具体使用方法篇幅较多，这里不细说。需要注意的是，使用国内的自己的服务器建站需要备案。 GitHub Pages自定义域名开启HTTPS目前大部分网站都在https协议，gitHub pages本身是走https协议的，但是如果是自定义域名，则需要使用其他方式来配置，google搜索会发现大部分教程都是使用Cloudflare免费的CDN服务。配置过程参考了这篇文章。 这里有一个问题后期需要优化一下，站内的图片有有一些是直接在网上复制的链接，可能不支持https，显示会出现问题。所以后期还有一项可以优化，使用自己的图床，现在比较主流的是七牛云，这样可以保证图片正常显示。 新设备上theme同步问题因为theme是子项目, 所有无法push到本项目的远程仓库下, 新建一个仓库单独存储主题项目也不失为一个解决办法，但是很繁琐。hexo 3.X支持在source文件夹下创建_data文件夹, 可以存储数据。可以把主题配置文件copy到_data文件加下，如next.yml。这样, 在新设备上仅需要根据主题地址git clone下主题仓库, 然后把配置文件内容替换为source/_data/下对应的配置文件即可。还有百度搜索、谷歌搜索的文件，之前会保存在source/_data/文件夹内，换了设备后复制到主题目录下的source文件夹内，这样每次hexo g的时候\b会自动生成。 多次在新设备上部署hexo\b博客后发现最重复和麻烦的是主题的配置，每次从github仓库拉下来博客项目后还要去找主题仓库。拉下来主题仓库，然后还需要改主题仓库的配置文件，谷歌和百度搜索配置等等，需要改很多东西，非常麻烦，后来学了点bash脚本config_sync，写了个文件，每次拉取项目后执行该文件即可自动部署完成，非常快速的\b完成配置。 注：我现在的博客主题使用了git modules，先fork主题仓库到自己的github，然后就可以自己进行版本管理啦。 配置忽略项，该配置下的目录中的 markdown 文件不会编译成 html 文件，可以存放一些数据或者放草稿。123skip_render:2- _test/* # 两个 ** 表示该目录的所有下级目录, 但是两个**会报错，可能是主题里面的配置没有兼容2- _data/* 百度统计和google analytics相关配置教程可有在google搜索，有很多讲的很详细的文章。google analytics和百度统计需要的两个文件备份在项目的source/_data文件夹下(该文件夹内的文件不会编译，可当做仓库)，新设备上复制到主题文件夹的source文件夹下(项目根目录的文件夹下会编译，主题目录的source下不会编译)。123456789&lt;script&gt; var _hmt = _hmt || []; (function() &#123; var hm = document.createElement(\"script\"); hm.src = \"//hm.baidu.com/hm.js?&lt;%=theme.baidu_tongji%&gt;\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); &#125;)();&lt;/script&gt; 12345678910&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;&lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=&lt;%= theme.google_analytics %&gt;\"&gt;&lt;/script&gt;&lt;script&gt; window.dataLayer = window.dataLayer || []; function gtag()&#123;dataLayer.push(arguments);&#125; gtag('js', new Date()); gtag('config', '&lt;%= theme.google_analytics %&gt;');&lt;/script&gt;&lt;!-- End Google Analytics --&gt; *注：最开始搭建博客的时候我SEO配置这块不是很了解，这里补充一下，百度统计和google analytics的配置一般都是在主题配置下，每个主题实现都不一样。 SEO优化SEO优化参考了这篇文章, 简化了文件URL层级结构。 百度推送这里补充一下百度推送相关的内容。首先需要把你的网站添加到[百度推送(https://ziyuan.baidu.com/site/index#/)系统中，添加过程需要百度验证你的网站属于你，验证方式一般有三种方式，html文件方式、html 标签方式和域名解析方式，建议使用html标签方式，即在你的博客文章中添加百度或google需要的meta标签，mate标签的content的内容需要去其网站填写你的网站，然后会生成属于你自己网站的标识码。*12&lt;meta name=\"baidu-site-verification\" content=\"\"&gt;&lt;meta name=\"google-site-verification\" content=\"\"&gt; 参考http://www.cnblogs.com/zhcncn/p/4097881.htmlhttp://www.jianshu.com/p/05289a4bc8b2http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html","tags":[{"name":"hexo","slug":"hexo","permalink":"https://mhynet.cn/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://mhynet.cn/tags/github/"},{"name":"github pages","slug":"github-pages","permalink":"https://mhynet.cn/tags/github-pages/"},{"name":"博客","slug":"博客","permalink":"https://mhynet.cn/tags/博客/"}]},{"title":"前端设计模式","date":"2017-12-09T01:27:02.000Z","path":"Front-end-design-patterns.html","text":"设计模式对于提高开发效率具有非常重要的作用，根据不同的需求采用合适的设计模式可以事半功倍。 1.常见设计模式 构造函数模式 工厂模式 模块模式 混合模式 单例模式 发布订阅模式 2.构造函数模式 Constructor构造函数模式，最简单的方式，实现如下：1234567function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.sayName = function()&#123; return this.name;&#125;; 调用123var student = new Person(\"mhy\", 24);student.sayName(); // \"mhy\"console.log(student); 将方法定义到原型上，可以在每次生成Person实例的时候实现继承，使this指向该对象而不是window。123456789101112function Person(name, age &#123; this.name = name; this.age = age; this.sayName = function() &#123; return this.name; &#125;&#125;)// 调用let teacher = new Person('wang', 28);teacher.sayName();let student = new Person('li', 18);student.sayName(); 上面的实现方法将sayName实现在this上，每次调用的时候都会定义一个sayName方法，如果有很多实例的话会占用更多内存。 调用的时候\b是否使用new关键词？123456789// 作为函数调用var p = Person('m', 12);console.log(typeof p); // \"undefined\"console.log(window.sayName()); // \"m\"// 使用 new 关键词var s = new Person(\"w\", 23);console.log(typeof s); // \"object\"console.log(s.sayName()); // \"w\" 可以强制使用new关键词, 在定义Person的时候加入判断，如果没有使用new操作符则在内部使用new操作符生成\b实例123456function Person(name, age) &#123; if (!(this instanceof Person)) &#123; return new Person(name, age); &#125; // ...&#125; 3.工厂模式 Factory工厂模式可以定义根据参数不同的子类，\b提供了有个创建对象的接口。12345678910111213function createPerson(opts)&#123; var person = &#123; name: opts.name || 'mhy', sayName: function()&#123; console.log(this.name) &#125; &#125;; return person;&#125;var p1 = createPerson(&#123;name : 'mhy'&#125;);var p2 = createPerson(&#123;name : '小李'&#125;);// 工厂模式，每次使用都要new一个实例 根据不同的子类类型，需要定义对应的子类。\b汤姆大叔的讲解非常详细，想深入研究可以参考。 以下几种情景下工厂模式特别有用： 1.对象的构建十分复杂； 2.需要依赖具体环境创建不同实例； 3.处理大量具有相同属性的小对象； 什么时候不该用工厂模式？不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去。 4.模块模式12345678910var Person = (function()&#123; var name = 'mhy'; function sayName()&#123; console.log(name); &#125; return &#123; name: name, sayName: sayName &#125;&#125;)() 闭包方式实现一个模块1234567891011121314var Person = (function()&#123; var name = 'mhy'; return &#123; changeName: function(newName)&#123; name = newName; &#125;, sayName: function()&#123; console.log(name); &#125; &#125;;&#125;)()Person.sayName();Person.changeName('mhy');Person.sayName(); 5.混合模式使用继承的方式实现一个模块123456789101112131415161718192021222324252627var Person = function(name, age)&#123; this.name = name; this.age = age;&#125;;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;var Student = function(name, age, score)&#123; Person.call(this, name, age); //调用call方法，等价于 &lt;==&gt; this.name = name; this.age = age; this.score = score;&#125; ;//Student.prototype = Object.create(Person.prototype);Student.prototype = create(Person.prototype);function create(parentObj)&#123; function F()&#123;&#125;; F.prototype = parentObj; return new F();&#125;;Student.prototype.sayScore = function()&#123; console.log(this.score);&#125;var student = new Student(\"mhy\", 24, 98);console.log(student); 6.单例模式12345678910111213141516171819202122232425var People = (function()&#123; var instance; function init(name)&#123; //define private methods and properties //do something return &#123; //define public methods and properties name: name &#125;; &#125; //词法作用域 return &#123; createPeople: function(name)&#123; if(!instance)&#123; instance = init(name); &#125; return instance; &#125; &#125;;&#125;)()var obj1 = People.createPeople('mhy'); // &#123;name: 'mhy'&#125;var obj2 = People.createPeople('小李子'); //&#123;name: 'mhy'&#125;//初始化一次后，之后每次调用，输出的值为第一次初始的值// 单例模式， 常用于对话框 dialog 7.发布订阅模式发布订阅模式， 处理异步模式非常便利123456789101112131415161718192021222324252627282930313233343536var EventCenter = (function()&#123; var events = &#123;&#125;; function on(evt, handler)&#123; events[evt] = events[evt] || []; events[evt].push(&#123; handler: handler &#125;); &#125; function fire(evt, args)&#123; if(!events[evt])&#123; return; &#125; for(var i = 0; i &lt; events[evt].length; i ++)&#123; events[evt][i].handler(args); &#125; &#125; function off(name)&#123; delete events[name] &#125; return &#123; on: on, fire: fire, off: off &#125;&#125;)()EventCenter.on('mu_event', function(date)&#123; console.log('my_event received...');&#125;);EventCenter.on('my_event', function(date)&#123; console.log('my_event2 received...');&#125;);EventCenter.fire('my_event');","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://mhynet.cn/tags/设计模式/"}]},{"title":"数组的方法汇总","date":"2017-12-03T06:01:08.000Z","path":"function-of-array.html","text":"数组是对象，数组有很多方法，主要\b包括查询(不改变自身)，修改(改变自身)和遍历三大类。 1.不会改变自身的方法下面的这些方法不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 Array.prototype.concat()返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。\b对象是引用类型，要实现对象的拷贝，不能采用直接赋值的方法，因为两者实际上指向同一个对象。可以使用concat方法或者拓展符...。1234567let arr = [1,2,3,4];let arr2 = [].concat(['11','21','12'], arr,['s','d']);console.log(arr); // [1,2,3,4]console.log(arr2); ['11','21','12',1,2,3,4,'s','d']// 或者let arr3 = arr.concat('d', ['beijing','shanghai']); // [1,2,3,4,'d', 'beijing', 'shanghai']let arr4 = [...arr].concat('tianjing') Array.prototype.includes()判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。123let arr = [1,2,3,4];arr.includes(4); //truearr.includes('s'); // false Array.prototype.join()连接所有数组元素组成一个字符串。12let arr = [1,2,3,4];let str = arr.join(''); // \"1234\" Array.prototype.slice(start, end)抽取当前数组中的一段元素组合成一个新数组。两个参数，第一个参数为开始的下标，第二个为结束的下标；只传一个参数则从该参数下标开始截取，不传参数则截取\b整个数组。注意，截取的数组包含的一个参数下标对应的元素，但不包括第二个参宿所指下标对应的元素, 即截取的区间为[start, end)当仅参数为负数时，从数组末尾开始截取。1234let arr = [1,2,3,4];let arr1 = arr.slice(); // [1,2,3,4]let arr2 = arr.slice(3); // [4]let arr3 = arr.slice(1,2); // [2]， 不包括【3】 该方法不改变原数组，返回新数组 Array.prototype.toSource()返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 Object.prototype.toSource() 方法。注意：该特性是非标准的，请尽量不要在生产环境中使用它！目前大部分浏览器都不支持该方法， 仅firefox支持。12var alpha = new Array(\"a\", \"b\", \"c\");alpha.toSource(); //返回[\"a\", \"b\", \"c\"] Array.prototype.toString()返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。12let arr = [1,2,3,4];arr.toString(); // \"1,2,3,4\" Array.prototype.toLocaleString()返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。 Array.prototype.indexOf()返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。123let arr = [1,2,3,4,4,5];arr.indexOf(4); // 3arr.indexOf('2'); // -1 Array.prototype.lastIndexOf()返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 2.会改变自身的方法下面的这些方法会改变调用它们的对象自身的值： Array.prototype.copyWithin()在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。12345[\"alpha\", \"beta\", \"copy\", \"delta\"].copyWithin(1, 2, 3);//[\"alpha\", \"copy\", \"copy\", \"delta\"]['alpha', 'bravo', 'charlie', 'delta'].copyWithin(2, 0);// results in [\"alpha\", \"bravo\", \"alpha\", \"bravo\"] 语法：1234arr.copyWithin(target)arr.copyWithin(target, start)arr.copyWithin(target, start, end)arr.copyWithin(目标索引, [源开始索引], [结束源索引]) target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。 start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。 end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length。 Array.prototype.fill()将数组中指定区间的所有元素的值，都替换成某个固定的值。123456789let arr = [];arr.fill('s'); // [], 由于length = 0, 所有返回[]let arr2 = [];arr2.length = 3;arr2.fill('x'); // ['x','x','x']let arr3 = [1,2,3];arr3.fill(0); // [0, 0, 0] 语法：123arr.fill(value)arr.fill(value, start)arr.fill(value, start, end) 具体要填充的元素区间是 [start, end) , 一个半开半闭区间. Array.prototype.pop()删除数组的最后一个元素，并返回这个元素。 Array.prototype.push()在数组的末尾增加一个或多个元素，并返回数组的新长度。 Array.prototype.shift()删除数组的第一个元素，并返回这个元素。 Array.prototype.unshift()在数组的开头增加一个或多个元素，并返回数组的新长度。pop 和 push 均作用于数组末尾；shift 和 unshift 做用于数组\b开头， 删除返回该元素， 添加返回length\b， 均改变原数组 Array.prototype.reverse()颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 Array.prototype.sort()对数组元素进行排序，并返回当前数组。 Array.prototype.splice()在任意的位置给数组添加或删除任意个元素。语法:12345array.splice(start)array.splice(start, deleteCount)array.splice(start, deleteCount, item1, item2, ...) 返回值： 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。\b该方法改变原数组。 3.遍历方法在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在每一个数组元素都分别执行完回调函数之前，数组的length属性会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。 Array.prototype.forEach()为数组中的每个元素执行一次回调函数。没有返回值。语法：12345array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) Array.prototype.entries()返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。123456789101112131415161718192021222324var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();// undefinedconsole.log(iterator);// Array Iterator &#123;&#125;console.log(iterator.next().value);// [0, \"a\"]console.log(iterator.next().value);// [1, \"b\"]console.log(iterator.next().value);// [2, \"c\"]var arr = [\"a\", \"b\", \"c\"];var iterator = arr.entries();// undefinedfor (let e of iterator) &#123; console.log(e);&#125;// [0, \"a\"]// [1, \"b\"]// [2, \"c\"] Array.prototype.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 Array.prototype.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 Array.prototype.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 Array.prototype.find()找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。 Array.prototype.findIndex()找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。 Array.prototype.keys()返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。12345678910111213141516171819let arr = [\"a\", \"b\", \"c\"];let iterator = arr.keys();// undefinedconsole.log(iterator);// Array Iterator &#123;&#125;console.log(iterator.next());// Object &#123;value: 0, done: false&#125;console.log(iterator.next());// Object &#123;value: 1, done: false&#125;console.log(iterator.next());// Object &#123;value: 2, done: false&#125;console.log(iterator.next());// Object &#123;value: undefined, done: true&#125; Array.prototype.map()返回一个由回调函数的返回值组成的新数组。 Array.prototype.reduce()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。123456789var total = [0, 1, 2, 3].reduce(function(sum, value) &#123; return sum + value;&#125;, 0);// total is 6var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b);&#125;, []);// flattened is [0, 1, 2, 3, 4, 5] 将二维数组转化为一维12345678910111213ar flattened = [[0, 1], [2, 3], [4, 5]].reduce( function(a, b) &#123; return a.concat(b); &#125;, []);// flattened is [0, 1, 2, 3, 4, 5]// 你也可以写成箭头函数的形式：var flattened = [[0, 1], [2, 3], [4, 5]].reduce( ( acc, cur ) =&gt; acc.concat(cur), []); 数组去重12345678et arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];let result = arr.sort().reduce((init, current)=&gt;&#123; if(init.length===0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1,2,3,4,5] Array.prototype.reduceRight()从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.values()返回一个数组迭代器对象，该迭代器会包含所有数组元素的值。 Array.prototype@@iterator和上面的 values() 方法是同一个函数。 4.通用方法在 JavaScript 中，很多的数组方法被故意设计成是通用的。也就是说，那些看起来像是数组的对象（类数组对象），即拥有一个 length 属性，以及对应的索引属性（也就是数字类型的属性，比如 obj[5] )的非数组对象也是可以调用那些数组方法的。 其中一些数组方法，比如说 join 方法，它们只会单纯的读取当前对象的 length 属性和索性属性的值，并不会尝试去改变这些属性的值。 而另外一些数组方法，比如说 reverse 方法，它们会尝试修改那些属性的值，因此，如果当前对象是个 String 对象，那么这些方法在执行时就会报错，因为字符串对象的 length 属性和索引属性都是只读的。","tags":[{"name":"数组","slug":"数组","permalink":"https://mhynet.cn/tags/数组/"}]},{"title":"CSS3动画--转不停的骰子","date":"2017-11-16T12:26:37.000Z","path":"CSS3-rotate-dice.html","text":"最终效果 参考代码按照以下步骤就可以实现。 1.建立\b容器和6个面:最外面的 &lt;div class=&quot;wrap&quot;&gt;&lt;/div&gt; \b用于整个结构在页面中的布局，以及设置\b观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;是6个面的父容器，限制6个面的大小和位置。同时，旋转动画也设置在该容器上。 12345678910&lt;div class=\"wrap\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"box front\"&gt;&lt;/div&gt; &lt;div class=\"box left\"&gt;&lt;/div&gt; &lt;div class=\"box right\"&gt;&lt;/div&gt; &lt;div class=\"box back\"&gt;&lt;/div&gt; &lt;div class=\"box top\"&gt;&lt;/div&gt; &lt;div class=\"box bottom\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 设置样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546.wrap&#123; width: 200px; height: 200px; position: relative; margin: 100px auto; perspective: 1200px;&#125;.content&#123; position: absolute; width: 100%; height: 100%; backface-visibility: hidden; transform: translateZ(100px) rotateY(45deg) rotateZ(45deg) rotateX(90deg);&#125;.box&#123; display: block; position: absolute; width: 200px; height: 200px; border-radius:50px; transform-style: preserve-3d;&#125;.front&#123; transform: translateZ(100px); background: #7FFF00;&#125;.back&#123; transform: rotateY(180deg) translateZ(100px); background: #00FFFF;&#125;.left&#123; transform: rotateY(-90deg) translateZ(100px); background: #DC143C;&#125;.right&#123; transform: rotateY(90deg) translateZ(100px); background: #808000;&#125;.top&#123; transform: rotateX(90deg) translateZ(100px); background: #EE82EE;&#125;.bottom&#123; transform: rotateX(-90deg) translateZ(100px); background: #FFFF00;&#125; 2.容器设置旋转动画：123456789101112.content&#123; /* ... */ animation: rotating 4s linear infinite;&#125;@keyframes rotating&#123; 0%&#123; transform:translateZ(100px) rotateY(0deg) rotateZ(0deg) rotateX(0deg); &#125; 100%&#123; transform:translateZ(100px) rotateY(360deg) rotateZ(360deg) rotateX(360deg); &#125;&#125; 3.\b各个面设置点数\b按1~6的顺序给对应的面的div加入点数。完成后的html\b应该是这样的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;div class=\"wrap\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"box front\"&gt; &lt;div class=\"item-ct\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box left\"&gt; &lt;div class=\"item-ct\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box right\"&gt; &lt;div class=\"item-ct\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box back\"&gt; &lt;div class=\"item-ct\"&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box top\"&gt; &lt;div class=\"item-ct\"&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"box bottom\"&gt; &lt;div class=\"item-ct\"&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"column\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对应的样式如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879.item&#123; width:50px; height:50px; border-radius: 50%;&#125;.item-ct&#123; position:absolute; left:20px; top:20px; right:20px; bottom:20px; display:flex; transform-style:preserve-3d;&#125;.front .item-ct&#123; justify-content:center; align-items:center;&#125;.left .item-ct&#123; justify-content:space-between; align-items:flex-start;&#125;.left .item:nth-child(2)&#123; align-self:flex-end;&#125;.right .item-ct&#123; justify-content:space-between;&#125;.right .item:nth-child(2)&#123; align-self:center;&#125;.right .item:nth-child(3)&#123; align-self:flex-end;&#125;.back .item-ct&#123; flex-wrap:wrap; align-content:space-between;&#125;.column&#123; display: flex; flex-basis: 100%;&#125;.back .column:nth-child(1)&#123; align-items:flex-start; justify-content:space-between;&#125;.back .column:nth-child(2)&#123; justify-content:space-between; align-items:flex-end;&#125;.top .item-ct&#123; flex-wrap:wrap; align-content:space-between;&#125;.top .column:nth-child(1)&#123; justify-content:space-between; align-items:flex-start;&#125;.top .column:nth-child(2)&#123; justify-content:center; align-items:center; height:20px;&#125;.top .column:nth-child(3)&#123; justify-content:space-between; align-items:flex-end;&#125;.bottom .item-ct&#123; flex-wrap:wrap; align-content:space-between;&#125;.bottom .column:nth-child(1)&#123; justify-content:space-between; align-items:flex-start;&#125;.bottom .column:nth-child(2)&#123; justify-content:space-between; align-items:flex-end;&#125; 设置点数部分的css布局使用的是flex，如果使用grid布局，html结构可能会更简洁一些，你可以试一下。 4.给每个点数设置颜色渐变动画这部分代码只有\bcss：123456789101112131415161718.item&#123; /* ... */ animation: shineChange 4s linear infinite;&#125;@keyframes shineChange &#123; from &#123; background-color: #4169E1 ; box-shadow:inset 0 0 25px #416981; &#125; 50% &#123; background-color: #FFA500; box-shadow: inset 0 0 70px #ddA590; &#125; to &#123; background-color: #4169E1 ; box-shadow:inset 0 0 25px #416981; &#125;&#125; 以上就是使用CSS3\b实现旋的介绍，\b文中的方案使用的是固定尺寸、flex布局，还有\b优化的空间。","tags":[{"name":"css","slug":"css","permalink":"https://mhynet.cn/tags/css/"},{"name":"动画","slug":"动画","permalink":"https://mhynet.cn/tags/动画/"},{"name":"transform","slug":"transform","permalink":"https://mhynet.cn/tags/transform/"}]},{"title":"使用wepy框架开发微信小程序","date":"2017-11-16T07:25:51.000Z","path":"wechat-app-of-wepy.html","text":"微信小程序是仅使用于微信平台. 安装开发者工具 开发微信小程序之前需要安装微信开发者工具，前往微信公众平台下载微信开发者工具，根据所使用的操作系统选择\b对应的版本下载安装即可使用。 新建项目 使用命令行新建\b项目目录如： myxhc， \u001b然后进入\b该目录1mkdir myxhc 1cd myxhc 然后使用npm或yarn全局安装 wepy-cli工具:1npm install wepy-cli -g 安装好wepy-cli工具且新建\b好项目文件夹后，在该文件夹下使用以下命令生成项目：1wepy new myproject 安装依赖，项目需要的\b依赖可以单独使用npm安装，或者先配置好package.json文件后统一安装。1npm install 开启实时编译：1wepy build --watch 现在，可以把项目导入微信开发者工具进行实时预览调试了。 把项目导入开发者工具 注意：使用wepy框架生成的项目，需要导入的是项目中的dist目录；使用原生微信小程序\b开发则需要导入整个项目目录。 微信开发者工具的使用说明这里不在赘述，遇到问题请\b查阅使用文档或者\b搜索相关问题寻找解决办法。 wepy框架的使用 wepy框架使用请\b查阅wepy官方文档wepy框架和Vue很相似，如果你有Vue使用经验，学习wepy框架应该没什么难度。","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://mhynet.cn/tags/微信小程序/"},{"name":"wepy","slug":"wepy","permalink":"https://mhynet.cn/tags/wepy/"}]},{"title":"this、原型、继承总结","date":"2017-10-29T05:16:13.000Z","path":"this-protoype-inherit.html","text":"this 相关问题问题1： apply、call 、bind有什么作用，什么区别 Function.prototype.bind: bind，返回一个新函数，并且使函数内部的this为传入的第一个参数 12var fn3 = obj1.fn.bind(obj1);fn3(); 使用call和apply设置this call apply，调用一个函数，传入函数执行上下文及参数 12fn.call(context, param1, param2...)fn.apply(context, paramArray) 语法很简单，第一个参数都是希望设置的this对象，不同之处在于call方法接收参数列表，而apply接收参数数组 12fn2.call(obj1);fn2.apply(obj1); 它们的不同之处： apply： 最多只能有两个参数——新this对象和一个数组 argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里面。如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj，并且无法被传递任何参数。 call： 则是直接的参数列表，主要用在js对象各方法互相调用的时候，使当前this实例指针保持一致,或在特殊情况下需要改变this指针。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 更简单地说，apply和call功能一样，只是传入的参数列表形式不同：如 func.call(func1,var1,var2,var3) 对应的apply写法为：func.apply(func1,[var1,var2,var3])也就是说：call调用的为单个，apply调用的参数为数组 1234567function sum(a,b)&#123; console.log(this === window);//true console.log(a + b);&#125;sum(1,2);sum.call(null,1,2);sum.apply(null,[1,2]); 作用 * 调用函数 12345678910111213141516var info = 'tom';function foo()&#123; //this指向window var info = 'jerry'; console.log(this.info); //tom console.log(this===window) //true&#125;foo();foo.call();foo.apply();call和apply可以改变函数中this的指向 var obj = &#123; info:'spike'&#125;foo.call(obj); //这里foo函数里面的this就指向了objfoo.apply(obj); * 借用别的对象的方法 eg:求数组中的最大值 1234567891011var arr = [123,34,5,23,3434,23];//方法一var arr1 = arr.sort(function(a,b)&#123; return b-a;&#125;);console.log(arr1[0]);//方法二var max = Math.max.apply(null,arr) //借用别的对象的方法console.log(max);fn.call(context, param1, param2...)fn.apply(context, paramArray) 问题2： 以下代码输出什么?12345678910var john = &#123; firstName: \"John\"&#125;function func() &#123; alert(this.firstName + \": hi!\")&#125;john.sayHi = funcjohn.sayHi()//输出结果：join：hi！//此时，this是join对象； 问题3： 下面代码输出什么，为什么1234567func()function func() &#123; alert(this)&#125;//输出： Window//原因：func()等价于func.call(undefined);//而undefined会被浏览器默认为全局对象window; 问题4：下面代码输出什么123456789document.addEventListener('click', function(e)&#123; console.log(this); setTimeout(function()&#123; console.log(this); &#125;, 200);&#125;, false);//输出为：#document; window;//在事件处理程序中this代表事件源DOM对象//(setTimeout、setInterval这两个方法执行的函数this也是全局对象) 问题5：下面代码输出什么，why123456789var john = &#123; firstName: \"John\"&#125;function func() &#123; alert( this.firstName )&#125;func.call(john)//输出： john//解释：call（）中第一个参数表示定义的this值，即func（）中的this代表join。 问题6： 以下代码有什么问题，如何修改123456789101112var module= &#123; bind: function()&#123; $btn.on('click', function()&#123; console.log(this) //this指？ this.showMsg(); &#125;) &#125;, showMsg: function()&#123; console.log('饥人谷'); &#125;&#125;//this指什么$btn 修改后123456789101112var module= &#123; bind: function()&#123; var _this = this; $btn.on('click', function()&#123; console.log(_this) //_this指的是module； _this.showMsg();//饥人谷 &#125;) &#125;, showMsg: function()&#123; console.log('饥人谷'); &#125;&#125; 原型链相关问题问题7：有如下代码，解释Person、 prototype、proto、p、constructor之间的关联。12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log('My name is :' + this.name);&#125;var p = new Person(\"若愚\")p.sayName(); 我们通过函数定义了类Person，类（函数）自动获得属性prototype; 每个类的实例都会有一个内部属性 __proto__，指向类的prototype属性 p是构造函数Person的一个实例，p的 __proto__ 指向了Person的prototype属性， prototype是构造函数内部的原型对象，所以拥有contructor和__proto__属性，其中contructor属性指向构造函数Person，__proto__指向该对象的原型. 问题8： 上例中，对对象 p可以这样调用 p.toString()。toString是哪里来的? 画出原型图?并解释什么是原型链。 p.toString()方法是继承构造函数Object的原型对象里定义的toString方法，首先p会找自己的toString方法，如果没有找到，会沿着__proto__ 属性继续到构造函数Person的prototype里找toString方法，如果还未找到，再继续往Person.prototype的__proto__即Object.prototype找toString方法，最后找到toString()方法。 原型链：由于原型对象本身也是对象，而每个javascript对象都有一个原型对象，每个对象都有一个隐藏的proto属性，原型对象也有自己的原型，而它自己的原型对象又可以有自己的原型，这样就组成了一条链，这个就是原型链。在访问对象的属性时，如果在对象本身中没有找到，则会去原型链中查找，如果找到，直接返回值，如果整个链都遍历且没有找到属性，则返回undefined。原型链一般实现为一个链表，这样就可以按照一定的顺序来查找。 问题9：对String做扩展，实现如下方式获取字符串中频率最高的字符123var str = 'ahbbccdeddddfg';var ch = str.getMostOften();console.log(ch); //d , 因为d 出现了5次 12345678910111213141516171819202122232425262728293031323334353637383940414243//方法一：String.prototype.getMostOften = function()&#123; var obj = &#123;&#125;; for(var i=0,k;i&lt;this.length;i++)&#123; k = this[i]; if(obj[k])&#123; obj[k]++ &#125;else&#123; obj[k] = 1 &#125; &#125; var max = 0,key; for(var k in obj)&#123; if(obj[k]&gt;max)&#123; max = obj[k]; key = k; &#125; &#125; return key;&#125;//方法二：String.prototype.getMostOften = function()&#123; var arr = this.split(\"\"); var result = arr.reduce(function(allLetters,letter)&#123; if(allLetters[letter])&#123; allLetters[letter]++ &#125;else&#123; allLetters[letter] = 1 &#125; return allLetters; &#125;,&#123;&#125;); var max = 0,k; for(var key in result)&#123; if (result[key]&gt;max)&#123; max = result[key]; k = key &#125; &#125; return k;&#125;var str = 'ahbbccdeddddfg';var ch = str.getMostOften();console.log(ch); //d 问题10： instanceOf有什么作用？内部逻辑是如何实现的？ instanceOf：判断一个对象是否为另一个对象的实例 123456789101112function isInstanceOf(obj,fn)&#123; var oldProto = obj.__proto__; do&#123; if(oldProto === fn.prototype)&#123; //prototype是小写的！ return true; &#125;else&#123; oldProto = oldProto.__proto__; &#125; &#125;while(oldProto)&#123; return false; &#125;&#125; 继承相关问题问题11：继承有什么作用? 继承是指一个对象直接使用另一对象的属性和方法。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。这就意味着，JS对象可以使用所有其原型的所有方法，如果我们在原型上添加新的方法，那么实例也会拥有该方法，能够大大减少冗余代码。 问题12： 下面两种写法有什么区别?1234567891011121314151617181920//方法1function People(name, sex)&#123; this.name = name; this.sex = sex; this.printName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new People('饥人谷', 2)//方法2function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;var p1 = new Person('若愚', 27); 区别: 方法一是将printName作为构造函数的方法，实例在进行调用的时候是调用的自身的方法，较为消耗内存。方法二是将printName作为构造函数原型的方法，所有实例共享这个方法。 问题13： Object.create 有什么作用？兼容性如何？12345678910111213141516171819202122function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;function Male(name, age, sex)&#123; Person.call(this, name, age); this.sex = sex;&#125;Male.prototype = new Person();//该方法同下，代替不兼容Object.create()的使用场景Male.prototype = Object.create(Person.prototype);Male.prototype.constructor = Male;Male.prototype.sayAge = function()&#123; console.log(this.age);&#125;;var p1 = new Male('hunger', 20, 'nan');p1.sayName();//hungerp1.sayAge();//20 兼容性： 问题14： hasOwnProperty有什么作用？ 如何使用？hasOwnPerperty是Object.prototype的一个方法，可以判断一个对象是否包含自定义属性而不是原型链上的属性，hasOwnProperty是JavaScript中唯一一个处理属性但是不查找原型链的函数123m.hasOwnProperty('name'); // truem.hasOwnProperty('printName'); // falseMale.prototype.hasOwnProperty('printAge'); // true 问题15：如下代码中call的作用是什么?12345678function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;function Male(name, sex, age)&#123; Person.call(this, name, sex); //这里的 call 有什么作用 this.age = age;&#125; 问题16： 补全代码，实现继承123456789101112131415161718192021222324252627function Person(name, sex)&#123; // todo ... this.name = name; this.sex = sex;&#125;Person.prototype.getName = function()&#123; // todo ... console.log(this.name);&#125;;function Male(name, sex, age)&#123; //todo ... Person.call(this,name, sex); this.age = age;&#125;//todo ...Male.prototype = Object.create(Person.prototype);Male.prototype.constructor = Male;Male.prototype.getAge = function()&#123; //todo ... console.log(this.age);&#125;;var ruoyu = new Male('若愚', '男', 27);ruoyu.printName();//若愚","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"继承","slug":"继承","permalink":"https://mhynet.cn/tags/继承/"},{"name":"this","slug":"this","permalink":"https://mhynet.cn/tags/this/"},{"name":"原型","slug":"原型","permalink":"https://mhynet.cn/tags/原型/"}]},{"title":"前端模块化常用规范","date":"2017-10-05T12:03:21.000Z","path":"FE-module.html","text":"JavaScript在发展初期，仅仅用于实现简单的页面交互逻辑。如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀。随着vue、react和angular三大框架以及nodejs的广泛应用，模块化和工程化已成为前端开发中不可缺少的重要角色。 模块化JavaScript在设计时没有提供模块化的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，称为模块化。一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了。前端模块化发展经历了几个阶段，今天有ADM、CMD、CmmonJS以及ES Module等模块化规范来辅助开发大型前端应用。 CommonJS我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。 定义模块 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 模块输出： 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 加载模块： 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 看个例子12345678910111213141516171819202122//模块定义 myModel.jsvar name = 'Byron';function printName()&#123; console.log(name);&#125;function printFullName(firstName)&#123; console.log(firstName + name);&#125;module.exports = &#123; printName: printName, printFullName: printFullName&#125;//加载模块var nameModule = require('./myModel.js');nameModule.printName(); 不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块） 尴尬的浏览器仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。 这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多。 浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。 解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。 另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧： AMDAMD， 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 requireJS主要解决两个问题 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 看一个使用requireJS的例子1234567891011121314151617// 定义模块 myModule.jsdefine(['dependency'], function()&#123; var name = 'Byron'; function printName()&#123; console.log(name); &#125; return &#123; printName: printName &#125;;&#125;);// 加载模块require(['myModule'], function (my)&#123; my.printName();&#125;); 语法 requireJS定义了一个函数 define，它是全局变量，用来定义模块1define(id?, dependencies?, factory); id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） dependencies：是一个当前模块依赖的模块名称数组 factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 在页面上使用require函数加载模块1require([dependencies], function()&#123;&#125;); require()函数接受两个参数 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 CMDCMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同语法 Sea.js 推崇一个模块一个文件，遵循统一的写法define1define(id?, deps?, factory) 因为CMD推崇 一个文件一个模块，所以经常就用文件名作为模块id CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写 factory有三个参数1function(require, exports, module) require require 是 factory 函数的第一个参数1require(id) require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口 exports exports 是一个对象，用来向外提供模块接口 module module 是一个对象，上面存储了与当前模块相关联的一些属性和方法 demo12345678910// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;); AMD与CMD区别关于这两个的区别网上可以搜出一堆文章，简单总结一下 最明显的区别就是在模块定义时对依赖的处理不同 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require 这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法 AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同 很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略 为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因） 同样都是异步加载模块，AMD在加载模块完成后就会执行该模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行 CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的 这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因. ES ModuleES Module伴随着ES6的发展，已被广泛应用于前端应用中。 export 语句ES Module使用export语句导出模块，export语句有很多种灵活的用法，这里列出几种简单的用法仅做参考。1234567891011121314151617181920// 申明时直接导出变量export var name = 'Tom';export var year = 2012;// 先申明，后导出变量var name = 'Tom';var year = 2012;export &#123; name, year &#125;;// 导出函数export function multiply(x, y) &#123; return x * y;&#125;;// 导出对象export var setting = &#123; env: 'production', debug: false, url: 'https://mhynet.cn'&#125; import 语句12345import &#123; stat, exists, readFile &#125; from 'fs';import Vue from 'vue'import * as Setting from 'setting' export default12345678910export default &#123; env: 'production', debug: false, url: 'https://mhynet.cn'&#125;export default function foo() &#123; console.log('export default')&#125; export 与 import 的复合写法在一个模块中，先输入再输出，可以使用该写法。12345export &#123; foo, bar &#125; from 'my_module';// 可以简单理解为import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;; Javascript模块化编程（一）：模块的写法Javascript模块化编程（二）：AMD规范Module 的语法","tags":[{"name":"模块化","slug":"模块化","permalink":"https://mhynet.cn/tags/模块化/"},{"name":"工程化","slug":"工程化","permalink":"https://mhynet.cn/tags/工程化/"},{"name":"前端","slug":"前端","permalink":"https://mhynet.cn/tags/前端/"}]},{"title":"【转】javascript的self和this使用小结","date":"2017-09-18T12:12:14.000Z","path":"self-and-this-in-js.html","text":"一、self这个非常简单。我们知道，打开任何一个网页，浏览器会首先创建一个窗口，这个窗口就是一个window对象，也是js运行所依附的全局环境对象和全局作用域对象。self 指窗口本身，它返回的对象跟window对象是一模一样的。也正因为如此，window对象的常用方法和函数都可以用self代替window。举个例子，常见的写法如“self.close();”，把它放在标记中：“关闭窗口”，单击“关闭窗口”链接，当前页面关闭。 二、this关键字在讲this之前，看下面的一段代码： 1234567891011121314151617181920212223242526&lt;body&gt;&lt;script type=\"text/javascript\"&gt;function thisTest() &#123; this.textValue = 'this的dom测试'; this.element= document.createElement('span'); this.element.innerHTML = this.textValue; this.element.style.color = \"blue\"; this.element.style.cursor = \"pointer\"; this.element.attachEvent('onclick', this.ToString); &#125; thisTest.prototype.RenderDom = function() &#123; document.body.appendChild(this.element); &#125; thisTest.prototype.ToString = function() &#123; alert(\"单击我：\"+this.textValue); &#125;; var test= new thisTest(); test.RenderDom(); //test.ToString();&lt;/script&gt;&lt;/body&gt; 本来的目的是想在body中添加一个span元素，对于这个span元素，制定了它的字体颜色，悬浮在它上面的鼠标样式和单击触发事件。问题就出现在它的单击事件上（弹出”单击我:undefined”）。也许有人会说你丫傻呀，写这么多sb代码还不就是为了实现下面这个东东吗？1&lt;span style='cursor:pointer;color:blue;' onclick=\"alert(this.innerHTML)\"&gt;this的dom测试&lt;/span&gt; 你看多简单直观，而且还不容易出错？！kao，我晕。我正要讲的是您正在使用的this.innerHTML中的this呀。1、this到底指什么？我们熟悉的c#有this关键字，它的主要作用就是指代当前对象实例（参数传递和索引器都要用到this）。在javascript中，this通常指向的是我们正在执行的函数本身，或者是指向该函数所属的对象（运行时）。2、常见使用方式（1）、直接在dom元素中使用1&lt;input id=\"btnTest\" type=\"button\" value=\"提交\" onclick=\"alert(this.value))\" /&gt; 分析：对于dom元素的一个onclick（或其他如onblur等）属性，它为所属的html元素所拥有，直接在它触发的函数里写this，this应该指向该html元素。（2）、给dom元素注册js函数a、不正确的方式 1234567&lt;script type=\"text/javascript\"&gt; function thisTest()&#123; alert(this.value); // 弹出undefined, this在这里指向??&#125;&lt;/script&gt;&lt;input id=\"btnTest\" type=\"button\" value=\"提交\" onclick=\"thisTest()\" /&gt; 分析：onclick事件直接调用thisTest函数，程序就会弹出undefined。因为thisTest函数是在window对象中定义的，所以thisTest的拥有者（作用域）是window，thisTest的this也是window。而window是没有value属性的，所以就报错了。b、正确的方式12345678&lt;input id=\"btnTest\" type=\"button\" value=\"提交\" /&gt;&lt;script type=\"text/javascript\"&gt; function thisTest()&#123; alert(this.value);&#125;document.getElementById(\"btnTest\").onclick=thisTest; //给button的onclick事件注册一个函数&lt;/script&gt; 分析：在前面的示例中，thisTest函数定义在全局作用域（这里就是window对象），所以this指代的是当前的window对象。而通过document.getElementById(“btnTest”).onclick=thisTest;这样的形式，其实是将btnTest的onclick属性设置为thisTest函数的一个副本，在btnTest的onclick属性的函数作用域内，this归btnTest所有，this也就指向了btnTest。其实如果有多个dom元素要注册该事件，我们可以利用不同的dom元素id，用下面的方式实现：document.getElementById(“domID”).onclick=thisTest; //给button的onclick事件注册一个函数。因为多个不同的HTML元素虽然创建了不同的函数副本，但每个副本的拥有者都是相对应的HTML元素，各自的this也都指向它们的拥有者，不会造成混乱。为了验证上述说法，我们改进一下代码，让button直接弹出它们对应的触发函数：1234567891011121314&lt;input id=\"btnTest1\" type=\"button\" value=\"提交1\" onclick=\"thisTest()\" /&gt;&lt;input id=\"btnTest2\" type=\"button\" value=\"提交2\" /&gt;&lt;script type=\"text/javascript\"&gt;function thisTest()&#123;this.value=\"提交中\";&#125;var btn=document.getElementById(\"btnTest1\");alert(btn.onclick); //第一个按钮函数var btnOther=document.getElementById(\"btnTest2\");btnOther.onclick=thisTest;alert(btnOther.onclick); //第二个按钮函数&lt;/script&gt; 其弹出的结果是：123456789//第一个按钮function onclick()&#123; thisTest()&#125;//第二个按钮function thisTest()&#123; this.value=\"提交中\";&#125; 从上面的结果你一定理解的更透彻了。By the way，每新建一个函数的副本，程序就会为这个函数副本分配一定的内存。而实际应用中，大多数函数并不一定会被调用，于是这部分内存就被白白浪费了。所以我们通常都这么写：12345678910&lt;input id=\"btnTest1\" type=\"button\" value=\"提交1\" onclick=\"thisTest(this)\" /&gt;&lt;input id=\"btnTest2\" type=\"button\" value=\"提交2\" onclick=\"thisTest(this)\" /&gt;&lt;input id=\"btnTest3\" type=\"button\" value=\"提交3\" onclick=\"thisTest(this)\" /&gt;&lt;input id=\"btnTest4\" type=\"button\" value=\"提交4\" onclick=\"thisTest(this)\" /&gt;&lt;script type=\"text/javascript\"&gt; function thisTest(obj)&#123; alert(obj.value);&#125;&lt;/script&gt; 这是因为我们使用了函数引用的方式，程序就只会给函数的本体分配内存，而引用只分配指针。这样写一个函数，调用的地方给它分配一个（指针）引用，这样效率就高很多。当然，如果你觉得这样注册事件不能兼容多种浏览器，可以写下面的注册事件的通用脚本：12345678910111213141516171819202122232425262728293031323334353637//js事件 添加 EventUtil.addEvent(dom元素,事件名称,事件触发的函数名) 移除EventUtil.removeEvent(dom元素,事件名称,事件触发的函数名)var EventUtil = new eventManager();//js事件通用管理器 dom元素 添加或者移除事件function eventManager() &#123; //添加事件 //oDomElement:dom元素,如按钮,文本,document等; ****** oEventType:事件名称(如:click,如果是ie浏览器,自动将click转换为onclick);****** oFunc:事件触发的函数名 this.addEvent = function(oDomElement, oEventType, oFunc) &#123; //ie if (oDomElement.attachEvent) &#123; oDomElement.attachEvent(\"on\" + oEventType, oFunc); &#125; //ff,opera,safari等 else if (oDomElement.addEventListener) &#123; oDomElement.addEventListener(oEventType, oFunc, false); &#125; //其他 else &#123; oDomElement[\"on\" + oEventType] = oFunc; &#125; &#125; this.removeEvent = function(oDomElement, oEventType, oFunc) &#123; //ie if (oDomElement.detachEvent) &#123; oDomElement.detachEvent(\"on\" + oEventType, oFunc); &#125; //ff,opera,safari等 else if (oDomElement.removeEventListener) &#123; oDomElement.removeEventListener(oEventType, oFunc, false); &#125; //其他 else &#123; oDomElement[\"on\" + oEventType] = null; &#125; &#125;&#125; 正像注释写的那样，要注册dom元素事件，用EventUtil.addEvent(dom元素,事件名称,事件触发的函数名)即可， 移除时可以这样写：EventUtil.removeEvent(dom元素,事件名称,事件触发的函数名)。这是题外话，不说了。(3)、类定义中使用this关键字这个其实再常见不过，看示例：12345678910function thisTest() &#123; var tmpName = 'jeff wong'; this.userName= 'jeff wong'; &#125;var test= new thisTest();alert(test.userName==test.tmpName);//falsealert(test.userName); //jeff wongalert(test.tmpName); //undefined 分析一下结果，其实这里的this和c#里的是类似的。（4）、为脚本对象添加原形方法理解这里的前提是你必须了解js里的原型概念（说道这里，kao，我还真的需要面壁一下）：js中对象的prototype属性，是用来返回对象类型原型的引用的。所有js内部对象都有只读的prototype属性，可以向其原型中动态添加功能(属性和方法)，但该对象不能被赋予不同的原型。但是对于用户定义的对象可以被赋给新的原型。看个简单的示例：12345678910111213141516171819202122232425262728293031//js的内部对象String,向其原型中动态添加功能(属性和方法)//去掉字符串两端的空白字符String.prototype.Trim = function() &#123; return this.replace(/(^\\s+)|(\\s+$)/g, \"\");&#125;function thisTest() &#123; var tmpName = 'jeff wong'; this.userName= ' jeff wong '; &#125;//给用户定义的对象添加原型方法thisTest.prototype.ToString = function() &#123; alert(this.userName); //jeff wong(*有空格*) alert(this.userName.Trim()); //jeff wong (*无空格*) //alert(tmpName); //脚本错误,tmpName未定义 &#125;var test= new thisTest();test.ToString(); //调用原型的ToString()function myTest()&#123; this.userName= ' test ';&#125;var test1=new myTest();//test1.ToString(); //这里暂时不支持调用ToString()方法//用户定义的对象被赋给新的原型myTest.prototype = new thisTest();test1.ToString(); //调用原型的ToString() 测试结果显示，这里的this指代的是被添加原形（方法或属性）的类的实例，和（3）中的定义基本相似。（5）、在函数的内部函数中使用this关键字这个你要是理解作用域和闭包，问题就迎刃而解。看最典型的示例：123456789101112function thisTest() &#123; this.userName= 'outer userName'; function innerThisTest()&#123; var userName=\"inner userName\"; alert(userName); //inner userName alert(this.userName); //outer userName &#125; return innerThisTest; &#125;thisTest()(); 分析：thisTest()调用内部的innerThisTest函数，形成一个闭包。innerThisTest执行时，第一次弹出innerUserName，是因为innerThisTest函数作用域内有一个变量叫userName，所以直接弹出当前作用域下变量的指定值；第二次弹出outer userName是因为innerThisTest作用域内没有userName属性（示例中的this.userName）,所以它向上一级作用域中找userName属性，这次在thisTest中找到（示例中的this.userName= ‘outer userName’;），所以弹出对应值。（6）通过Function的call和apply函数指定特定的this这个指定来指定去，this就有可能造成“你中有我，我中有你”的局面，不想把自己弄晕了的话，了解一下就可以了。改变this指定对象对于代码维护也是一件很不好的事情。贴出旧文中的示例代码结束吧：1234567891011121314151617181920212223function myFuncOne() &#123; this.p = \"myFuncOne-\"; this.A = function(arg) &#123; alert(this.p + arg); &#125;&#125;function myFuncTwo() &#123; this.p = \"myFuncTwo-\"; this.B = function(arg) &#123; alert(this.p + arg); &#125;&#125;function test() &#123; var obj1 = new myFuncOne(); var obj2 = new myFuncTwo(); obj1.A(\"testA\"); //显示myFuncOne-testA obj2.B(\"testB\"); //显示myFuncTwo-testB obj1.A.apply(obj2, [\"testA\"]); //显示myFuncTwo-testA,其中[ testA”]是仅有一个元素的数组 obj2.B.apply(obj1, [\"testB\"]); //显示myFuncOne-testB,其中[ testB”]是仅有一个元素的数组 obj1.A.call(obj2, \"testA\"); //显示myFuncTwo-testA obj2.B.call(obj1, \"testB\"); //显示myFuncOne-testB&#125; 总结：到这里，对于开篇中的span弹出undefined的问题你是不是已经豁然开朗？如果你还在懵懂中，给个可有可无的提示：当前的这个span元素有没有textValue属性啊！？三、void1、定义javascript中void是一个操作符，该操作符指定要计算一个表达式但是不返回值。2、语法void 操作符用法格式如下： （1）. javascript:void (expression) （2）. javascript:void expression注意：expression是一个要计算的js标准的表达式。表达式外侧的圆括号是可选的，但是写上去你可以一眼就知道括弧内的是一个表达式（这和typeof后面的表达式语法是一样的）。3、实例代码12345678910111213function voidTest() &#123; void (alert(\"it is a void test\")); //执行函数 var oTestNum = 1; void (oTestNum++); //整数自加 alert(oTestNum); oTestNum = 1; void (oTestNum += \" void test\"); //整数加字符串 alert(oTestNum);&#125;voidTest(); 4、在a元素下使用void(0)（1）适用情况在网页中，我们经常看到html里的a标签不需要它导航到某一个页面时，href属性设置的写法：12&lt;a href=\"#\"&gt;link1&lt;/a&gt;&lt;a href=\"javascript:void(0);\"&gt;link2&lt;/a&gt; 注意：第一种“#”的写法（其实#可以是多个，通常都是1个），当a元素所在的链接在浏览器一屏以下时，会导致页面回滚到顶部；所以当我们需要a标签不导航到其他页面，不需要网页位置的回滚，都会采取void(0)那种写法。（2）ie6下void(0)造成的诡异问题这个问题网上有很多讨论，个人认为“落叶满长沙”总结的很有代表性，这里就不再赘述了。 本文摘自 javascript的self和this使用小结","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"this","slug":"this","permalink":"https://mhynet.cn/tags/this/"},{"name":"self","slug":"self","permalink":"https://mhynet.cn/tags/self/"}]},{"title":"事件处理程序","date":"2017-09-04T02:36:21.000Z","path":"event-of-javascript.html","text":"JavaScript和HTML的交互是通过事件实现的。JavaScript采用异步事件驱动编程模型，当文档、浏览器、元素或与之相关对象发生特定事情时，浏览器会产生事件。如果JavaScript关注特定类型事件，那么它可以注册当这类事件发生时要调用的句柄 事件是某个行为或者触发，比如点击、鼠标移动 当用户点击鼠标时 当网页已加载时 当图像已加载时 当鼠标移动到元素上时 当用户触发按键时... 事件流事件流描述的是从页面中接收事件的顺序，比如有两个嵌套的div，点击了内层的div，这时候是内层的div先触发click事件还是外层先触发？目前主要有三种模型 IE的事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的元素 Netscape的事件捕获：不太具体的节点更早接收事件，而最具体的元素最后接收事件，和事件冒泡相反 DOM事件流：DOM2级事件规定事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段，首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接收事件，最后是冒泡阶段 这种分歧在日常生活中也很常见，举个例子，某个地方出了抢劫事件，我们有多种处理方式 村里先发现，报告给乡里，乡里报告到县城，县城报告给市里 市里先知道这事儿，然后交代给县城怎么处理，县城交给到乡里处理，乡里交给村里处理 Opera、Firefox、Chrome、Safari都支持DOM事件流，IE不支持事件流，只支持事件冒泡 如有以下html1234567891011&lt;!DOCTYPE html &gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;Test Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; Click Here&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 点击div区域 事件冒泡模型 事件捕获模型 DOM事件流 事件处理程序我们也称之为事件侦听器（listener），事件就是用户或浏览器自身执行的某种动作。比如click、load、mouseover等，都是事件类型（俗称事件名称），而响应某个事件的方法就叫做事件处理程序或者事件监听器 也就是我们需要提前定义好某些事件发生了该怎么处理，这个过程叫做绑定事件处理程序，了解了这些，我们看看如何给元素添加事件处理程序HTML内联方式 元素支持的每个事件都可以使用一个相应事件处理程序同名的HTML属性指定。这个属性的值应该是可以执行的JavaScript代码，我们可以为一个button添加click事件处理程序 1&lt;input type=\"button\" value=\"Click Here\" onclick=\"alert('Clicked!');\" /&gt; 在HTML事件处理程序中可以包含要执行的具体动作，也可以调用在页面其它地方定义的脚本,刚才的例子可以写成这样 1&lt;input type=\"button\" value=\"Click Here\" onclick=\"showMessage();\" /&gt; 在HTML中指定事件处理程序书写很方便，但是有两个缺点。 存在加载顺序问题，如果事件处理程序在html代码之后加载，用户可能在事件处理程序还未加载完成时就点击按钮之类的触发事件，存在时间差问题 这样书写html代码和JavaScript代码紧密耦合，维护不方便 JavaScript指定事件处理程序通过JavaScript指定事件处理程序就是把一个方法赋值给一个元素的事件处理程序属性。 每个元素都有自己的事件处理程序属性，这些属性名称通常为小写，如onclick等，将这些属性的值设置为一个函数，就可以指定事件处理程序，如下12345678&lt;input id=\"btnClick\" type=\"button\" value=\"Click Here\" /&gt;&lt;script type=\"text/javascript\"&gt; var btnClick = document.getElementById('btnClick'); btnClick.onclick = function showMessage() &#123; alert(this.id); &#125;;&lt;/script&gt; 这样处理，事件处理程序被认为是元素的方法，事件处理程序在元素的作用域下运行，this就是当前元素，所以点击button结果是：btnClick 这样还有一个好处，我们可以删除事件处理程序，只需把元素的onclick属性赋为null即可 DOM2事件处理程序DOM2级事件定义了两个方法用于处理指定和删除事件处理程序的操作：12addEventListenerremoveEventListener 所有的DOM节点都包含这两个方法，并且它们都接受三个参数： 事件类型 事件处理方法 布尔参数，如果是true表示在捕获阶段调用事件处理程序，如果是false，则是在事件冒泡阶段处理 刚才的例子我们可以这样写12345678&lt;input id=\"btnClick\" type=\"button\" value=\"Click Here\" /&gt;&lt;script type=\"text/javascript\"&gt; var btnClick = document.getElementById('btnClick'); btnClick.addEventListener('click', function() &#123; alert(this.id); &#125;, false);&lt;/script&gt; 上面代码为button添加了click事件的处理程序，在冒泡阶段触发，与上一种方法一样，这个程序也是在元素的作用域下运行，不过有一个好处，我们可以为click事件添加多个处理程序12345678910111213&lt;input id=\"btnClick\" type=\"button\" value=\"Click Here\" /&gt;&lt;script type=\"text/javascript\"&gt; var btnClick = document.getElementById('btnClick'); btnClick.addEventListener('click', function() &#123; alert(this.id); &#125;, false); btnClick.addEventListener('click', function() &#123; alert('Hello!'); &#125;, false);&lt;/script&gt; 这样两个事件处理程序会在用户点击button后按照添加顺序依次执行。 通过addEventListener添加的事件处理程序只能通过removeEventListener移除，移除时参数与添加的时候相同，这就意味着刚才我们添加的匿名函数无法移除，因为匿名函数虽然方法体一样，但是句柄却不相同，所以当我们有移除事件处理程序的时候可以这样写123456789101112&lt;input id=\"btnClick\" type=\"button\" value=\"Click Here\" /&gt;&lt;script type=\"text/javascript\"&gt; var btnClick = document.getElementById('btnClick'); var handler=function() &#123; alert(this.id); &#125; btnClick.addEventListener('click', handler, false); btnClick.removeEventListener('click', handler, false);&lt;/script&gt; IE兼容性下面就是老生常谈的IE兼容性问题了。。。 IE并不支持addEventListener和removeEventListener方法，而是实现了两个类似的方法123attachEventdetachEvent 这两个方法都接收两个相同的参数 事件处理程序名称 事件处理程序方法 由于IE指支持事件冒泡，所以添加的程序会被添加到冒泡阶段，使用attachEvent添加事件处理程序可以如下123456789&lt;input id=\"btnClick\" type=\"button\" value=\"Click Here\" /&gt;&lt;script type=\"text/javascript\"&gt; var btnClick = document.getElementById('btnClick'); var handler=function() &#123; alert(this.id); &#125; btnClick.attachEvent('onclick', handler);&lt;/script&gt; 结果是undefined，很奇怪，一会儿我们会介绍到 使用attachEvent添加的事件处理程序可以通过detachEvent移除，条件也是相同的参数，匿名函数不能被移除。123456789101112&lt;input id=\"btnClick\" type=\"button\" value=\"Click Here\" /&gt;&lt;script type=\"text/javascript\"&gt; var btnClick = document.getElementById('btnClick'); var handler=function() &#123; alert(this.id); &#125; btnClick.attachEvent('onclick', handler); btnClick.detachEvent('onclick', handler);&lt;/script&gt; 跨浏览器的事件处理程序前面内容我们可以看到，在不同的浏览器下，添加和移除事件处理程序方式不相同，要想写出跨浏览器的事件处理程序，首先我们要了解不同的浏览器下处理事件处理程序的区别 在添加事件处理程序事addEventListener和attachEvent主要有几个区别 参数个数不相同，这个最直观，addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理（我们一般为了浏览器兼容性都设置为冒泡阶段） 第一个参数意义不同，addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload） 事件处理程序的作用域不相同，addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window，所以刚才例子才会返回undefined，而不是元素id 为一个事件添加多个事件处理程序时，执行顺序不同，addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律(添加的方法少的时候大多是按添加顺序的反顺序执行的，但是添加的多了就无规律了)，所以添加多个的时候，不依赖执行顺序的还好，若是依赖于函数执行顺序，最好自己处理，不要指望浏览器 了解了这四点区别后我们可以尝试写一个浏览器兼容性比较好的添加事件处理程序方法 123456789101112function addEvent(node, type, handler) &#123; if (!node) return false; if (node.addEventListener) &#123; node.addEventListener(type, handler, false); return true; &#125; else if (node.attachEvent) &#123; node.attachEvent('on' + type, handler, ); return true; &#125; return false;&#125; 这样，首先我们解决了第一个问题参数个数不同，现在三个参数，采用事件冒泡阶段触发 第二个问题也得以解决，如果是IE，我们给type添加上on 第四个问题目前还没有解决方案，需要用户自己注意，一般情况下，大家也不会添加很多事件处理程序 试试这个方法感觉很不错，但是我们没有解决第三个问题，由于处理程序作用域不同，如果handler内有this之类操作，那么就会出错。在IE下，实际上大多数函数都会有this操作123456789101112function addEvent(node, type, handler) &#123; if (!node) return false; if (node.addEventListener) &#123; node.addEventListener(type, handler, false); return true; &#125; else if (node.attachEvent) &#123; node.attachEvent('on' + type, function() &#123; handler.apply(node); &#125;); return true; &#125; return false;&#125; 这样处理就可以解决this的问题了，但是新的问题又来了，我们这样等于添加了一个匿名的事件处理程序，无法用detachEvent取消事件处理程序，有很多解决方案，我们可以借鉴大师的处理方式，jQuery创始人John Resig是这样做的12345678910111213141516function addEvent(node, type, handler) &#123; if (!node) return false; if (node.addEventListener) &#123; node.addEventListener(type, handler, false); return true; &#125; else if (node.attachEvent) &#123; node['e' + type + handler] = handler; node[type + handler] = function() &#123; node['e' + type + handler](window.event); &#125;; node.attachEvent('on' + type, node[type + handler]); return true; &#125; return false;&#125; 在取消事件处理程序的时候123456789101112function removeEvent(node, type, handler) &#123; if (!node) return false; if (node.removeEventListener) &#123; node.removeEventListener(type, handler, false); return true; &#125; else if (node.detachEvent) &#123; node.detachEvent('on' + type, node[type + handler]); node[type + handler] = null; &#125; return false;&#125; John Resig很巧妙地利用了闭包，看起来很不错。 事件对象在触发DOM上的某个事件的时候会产生一个事件对象event，这个对象包含着所有与事件有关的信息，包括产生事件的元素、事件类型等相关信息。所有浏览器都支持event对象，但支持方式不同。 DOM中的事件对象兼容DOM的浏览器会产生一个event对象传入事件处理程序中。应用一下刚才我们写的addEvent方法12var btnClick = document.getElementById('btnClick'); addEvent(btnClick, 'click', handler); 点击button的时候我们可以看到弹出内容是click的弹窗 event对象包含与创建它的特定事件有关的属性和方法，触发事件的类型不同，可用的属性和方法也不同，但是所有事件都会包含 属性/方法 类型 读/写 说明 bubbles Boolean 只读 事件是否冒泡 cancelable Boolean 只读 是否可以取消事件的默认行为 currentTarget Element 只读 事件处理程序当前处理元素 detail Integer 只读 与事件相关细节信息 eventPhase Integer 只读 事件处理程序阶段：1 捕获阶段，2 处于目标阶段，3 冒泡阶段 preventDefault() Function 只读 取消事件默认行为 stopPropagation() Function 只读 取消事件进一步捕获或冒泡 target Element 只读 事件的目标元素 type String 只读 被触发的事件类型 view AbstractView 只读 与事件关联的抽象视图，等同于发生事件的window对象 在事件处理程序内部，this始终等同于currentTarget，而target是事件的实际目标。 要阻止事件的默认行为，可以使用preventDefault()方法，前提是cancelable值为true，比如我们可以阻止链接导航这一默认行为123document.querySelector('#btn').onclick = function (e) &#123; e.preventDefault();&#125; stopPropagation()方法可以停止事件在DOM层次的传播，即取消进一步的事件捕获或冒泡。我们可以在button的事件处理程序中调用stopPropagation()从而避免注册在body上的事件发生12345678var handler = function (e) &#123; alert(e.type); e.stopPropagation();&#125;addEvent(document.body, 'click', function () &#123; alert('Clicked body')&#125;);var btnClick = document.getElementById('btnClick');addEvent(btnClick, 'click', handler); 若是注释掉e.stopPropagation(); 在点击button的时候，由于事件冒泡，body的click事件也会触发，但是调用这句后，事件会停止传播IE中的事件对象 访问IE中的event对象有几种不同的方式，取决于指定事件处理程序的方法。直接为DOM元素添加事件处理程序时，event对象作为window对象的一个属性存在123456var handler = function () &#123; var e = window.event; alert(e.type);&#125;var btnClick = document.getElementById('btnClick');btnClick.onclick = handler; 我们通过window.event取得了event对象，并检测到了其类型，可是如果事件处理程序是通过attachEvent添加的，那么就会有一个event对象被传入事件处理程序中12345var handler = function (e) &#123; alert(e.type);&#125;var btnClick = document.getElementById('btnClick');attachEvent(btnClick, handler); 当然这时候也可以通过window对象访问event，方便起见，我们一般会传入event对象，IE中所有的事件都包含以下属性方法 属性/方法 类型 读/写 说明 cancelBubble Boolean 读/写 默认为false，设置为true后可以取消事件冒泡 returnValue Boolean 读/写 默认为true，设为false可以取消事件默认行为 srcElement Element 只读 事件的目标元素 type String 只读 被触发的事件类型 跨浏览器的事件对象虽然DOM和IE的event对象不同，但基于它们的相似性，我们还是可以写出跨浏览器的事件对象方案123456789101112131415161718192021function getEvent(e) &#123; return e || window.event;&#125;function getTarget(e) &#123; return e.target || e.scrElement;&#125;function preventDefault(e) &#123; if (e.preventDefault) e.preventDefault(); else e.returnValue = false;&#125;function stopPropagation(e) &#123; if (e.stopPropagation) e.stopPropagation(); else e.cancelBubble = true;&#125; 常用HTML事件有一些HTML事件我们会经常用到，这些事件不一定与用户操作有关，这里只是简单提及，详细用法大家就得百度谷歌了123456789101112131415161718192021load：当页面完全加载后在window上触发，当图像加载完成后在img元素上触发，或当嵌入内容加载完成时，在object元素上触发unload：页面完全卸载后在window上触发，或嵌入内容卸载后在object元素触发select：用户选择文本框中的字符时触发change：文本框焦点变化后其值改变时触发submit：用户提交表单的时候触发resize：窗口或框架大小变化的时候在window上触发scroll：用户滚动带滚动条的元素时，在该元素上触发focus：页面或元素获得焦点时在window及相应元素上触发blur：页面或元素失去焦点时在window及相应元素上触发beforeunload：页面卸载前在window上触发mousewheel：不算HTML的，当用户通过鼠标滚轮与页面交互，在垂直方向滚动页面时触发","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://mhynet.cn/tags/DOM/"},{"name":"事件","slug":"事件","permalink":"https://mhynet.cn/tags/事件/"}]},{"title":"【转】REM和EM","date":"2017-08-29T02:36:21.000Z","path":"REM-vs-EM.html","text":"网页字体排版的最佳实践之一就是使用相对单位，如rem和em. 问题是，你应该使用哪一个呢?一直以来，rem支持者和em支持者之间都存在着争辩，认为应该使用自己支持的那个。在这篇文章中，你会找到我如何在rem和em之间做抉择.你也将了解rem和em到底是什么以及如何使用它们来构建模块化组件。 什么是EM？ EM 是字体排印的一个单位，等同于当前指定的point-size。-维基百科 此语句在网页上并不能说得过去，因为我们不使用point-size.如果我们用point-size取代font-size的话，这句话就完全行得通。 意思就是，如果存在一个选择器的font-size属性的值为 20px,那么1em=20px12h1 &#123; font-size: 20px &#125; /* 1em = 20px */p &#123; font-size: 16px &#125; /* 1em = 16px */ 值，但这种情况的发生，纯粹是因为继承。** em单位可以被用来声明字体的大小。实际上，最佳做法是使用相对单位，如用em指定font-size。 考虑如下代码:1h1 &#123; font-size: 2em &#125; 这里h1选择器的真正大小是多少呢？ 我们要根据&lt;h1&gt;的父元素来计算font-size。它的父元素是&lt;html&gt;,并且它的font-size被设置为16px。 通过这种方式，我们可以计算出h1的值为32px,或者说2 * 16px.12html &#123; font-size: 16px &#125;h1 &#123; font-size: 2em &#125; /* 16px * 2 = 32px */ 虽然也可以实现，但是这并不被认为是一个好主意，通过在&lt;html&gt;中设置font-size的像素值将影响用户浏览器所设置的值。 取而代之，你可以使用percentage值，或者完全摒弃font-size。 注意:如果你完全摒弃font-size,它的值将被默认为100%.1html &#123; font-size: 100% &#125; /*这里的意思是默认值为16px*/ 对于大多数的用户(和浏览器)，font-size的值为100%，就会默认为16px，除非用户通过浏览器设置来改变font-size的默认值。但是很少有人这么做。 好了，让我们回到em。 em也可以用来指定除了font-size的其它属性值。margin和padding属性也经常用em设置大小。 这里是很多人开始对em的值产生困惑的地方。 考虑下面的代码。&lt;h1&gt;和&lt;p&gt;元素的margin-bottom的值应该是多少？(假设&lt;html&gt;的font-size被设置为100%).123456789h1 &#123; font-size: 2em; /* 1em = 16px */ margin-bottom: 1em; /* 1em = 32px */&#125;p &#123; font-size: 1em; /* 1em = 16px */ margin-bottom: 1em; /* 1em = 16px */&#125; 你是不是很吃惊两种状况下的margin-bottom的1em值不同？ 这种现象的发生在于1em等同于它当前的font-size。因为&lt;h1&gt;中的font-size被设置为了2em。其他用在&lt;h1&gt;内的em来计算的属性，就为1em = 32px。 在不同的代码中，1em就会有不同的取值，这就是经常迷惑人们的地方。如果你也是刚刚接触em，你也会产生迷惑。 不管怎么说，这就是em.接下来，让我们认识rem。 什么是REM？ rem指根em。它的产生是为了帮助人们解决em所带来的计算问题。 它是字体排版的一个单位，等同于根font-size。这意味着1rem等同于&lt;html&gt;中的font-size。 考虑相同的用rem表示的代码。现在margin-bottom计算出来的值为多少呢？123456789h1 &#123; font-size: 2rem; margin-bottom: 1rem; /* 1rem = 16px */&#125;p &#123; font-size: 1rem; margin-bottom: 1rem; /* 1rem = 16px */&#125; 正如您看到的，无论您在哪里设置它，1rem的取值均为16px。 这是十分可靠的，很容易去理解。 这就是rem。一旦你知道了什么是em，就很容易去理解，你是不是也同意这个观点？ 现在让我们步入这篇文章的正题，rem 还是 em? REMs or EMs?这是极具争议的问题。 一些开发人员完全避免使用rem,声称使用rem会使他们的组件缺少模块化。另外一些人则什么都使用rem,因为喜欢rem所带来的便捷。 奇怪的是，在我的职业生涯中，我掉进了在不同的地方是使用rem或者em的陷阱中。我喜欢em帮助我完成模块化组件，但是讨厌它所带来的代码复杂性。我喜欢rem计算的便捷，但是讨厌他是我模块化组件的阻碍。 事实证明。rem 和 em 均有各自的优缺点。应给根据实际情况来判断其使用方式。 这里我有两个简单的规则： 如果这个属性根据它的font-size进行测量，则使用em(当有属性需要用它的字体大小(font-size)进行大小声明时，这时em就相当有用。) 其他的一切事物均使用rem. 有一个比较普遍的误解，认为 em 单位是相对于父元素的字体大小。 事实上，根据W3标准 ，它们是相对于使用em单位的元素的字体大小。父元素的字体大小可以影响 em(默认情况下浏览器通常有字体大小 16px，但这可以被用户更改为从 9px 到 72px的任何值。) 根 html 元素将继承浏览器中设置的字体大小，除非显式设置固定值去覆盖。 所以 html 元素的字体大小虽然是直接确定 rem 值，但字体大小可能首先来自浏览器设置。 因此浏览器的字体大小设置可以影响每个使用 rem 单元以及每个通过 em 单位继承的值。 rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位。 em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位。 rem 和 em 单位是由浏览器基于你的设计中的字体大小计算得到的像素值。 em 单位基于使用他们的元素的字体大小。 rem 单位基于 html 元素的字体大小。 em 单位可能受任何继承的父元素字体大小影响 rem 单位可以从浏览器字体设置中继承字体大小。 使用 em 单位应根据组件的字体大小而不是根元素的字体大小。 在不需要使用em单位，并且需要根据浏览器的字体大小设置缩放的情况下使用rem。 使用rem单位，除非你确定你需要 em 单位，包括对字体大小。 媒体查询中使用 rem 单位 不要在多列布局中使用 em 或 rem ,改用%。 不要使用 em 或 rem，如果缩放会不可避免地导致要打破布局元素。 更多区别及配合使用请看原文实例。 本文参考自这里 扩展阅读 何时使用 Em 与 Rem","tags":[{"name":"css","slug":"css","permalink":"https://mhynet.cn/tags/css/"},{"name":"rem","slug":"rem","permalink":"https://mhynet.cn/tags/rem/"},{"name":"em","slug":"em","permalink":"https://mhynet.cn/tags/em/"}]},{"title":"【转】jQuery之.extend()方法使用","date":"2017-08-22T02:36:21.000Z","path":"jquery-extend-use.html","text":"jQuery 的 API 手册中，extend 方法挂载在 jQuery 和 jQuery.fn 两个不同的对象上，但在 jQuery 内部代码实现的是相同的，只是功能各不相同。 先看看官方给出的解释： jQuery.extend Merge the contents of two or more objects together into the first object. 把两个或者多个对象合并到第一个对象当中； jQuery.fn.extend Merge the contents of an object onto the jQuery prototype to provide new jQuery instance methods. 把对象挂载到 jQuery 的 prototype 上以扩展一个新的 jQuery 实例方法 。 虽然官方对 jQuery.extend 的扩展方法功能只字未提，但是它也同样具有扩展 jQuery 类方法 的功能。 合并对象 首先，我先来介绍一下 extend 函数在 合并对象 方面的用法。1jQuery.extend(target [, object1] [, objectN]) 合并 object1 … objectN 到 target 对象，如果只有一个参数，则该 target 对象会被合并到 jQuery 对象中。1234567891011121314var obj1 = &#123; name: 'Tom', age: 21&#125;var obj2 = &#123; name: 'Jerry', sex: 'boy'&#125;$.extend(obj1, obj2); // &#123;name: \"Jerry\", age: 21, sex: \"boy\"&#125;obj1 // &#123;name: \"Jerry\", age: 21, sex: \"boy\"&#125;obj2 // &#123;name: \"Jerry\", sex: \"boy\"&#125; 上述代码展示的是将 obj2 对象合并到 obj1 对象中，这种方法会 改变 obj1 对象的结构。如果你 不想改变 合并目标对象的结构，你可以这么做。 1234567891011121314var obj1 = &#123; name: 'Tom', age: 21&#125;var obj2 = &#123; name: 'Jerry', sex: 'boy'&#125;$.extend(&#123;&#125;, obj1, obj2); // &#123; name: \"Jerry\", age: 21, sex: \"boy\" &#125;obj1 // &#123; name: \"Tom\", age: 21 &#125;obj2 // &#123; name: \"Jerry\", sex: \"boy\" &#125; 深浅拷贝 1jQuery.extend([deep], target, object1 [, objectN]) 和上面的讲述的不同的是，该方法多了一个类型为 boolean 的 [deep] 传参，当其为 true 时，将 object1 , objectN 深度复制 后合并到 target 中。 首先，我们理解一下什么叫做 深度复制 。看看其和 浅度复制 有什么区别。12345678910111213141516171819var obj1 = &#123; name: \"John\", location: &#123; city: \"Boston\", county: \"USA\" &#125;&#125;var obj2 = &#123; last: \"Resig\", location: &#123; state: \"MA\", county: \"China\" &#125;&#125;$.extend(false, &#123;&#125;, obj1, obj2); // &#123; name: \"John\", last: \"Resig\", location: &#123; state: \"MA\", county: \"China\" &#125;&#125;$.extend(true, &#123;&#125;, obj1, obj2); // &#123; name: \"John\", last: \"Resig\", location: &#123; city: \"Boston\", state: \"MA\", county: \"China\" &#125;&#125; 由此可见，执行 深度复制 会递归遍历每个对象中含有复杂对象（如：数组、函数、json对象等）的属性值进行复制，而且 浅度复制 便不会这么做。 方法扩展 上述的 extend 方法中的 target 参数是可以省略的。如果省略了，则该方法就只能传入一个 object 参数，该方法功能是将该 object 合并到调用 extend 方法的对象中。 我们通常会使用这种方式来对 jQuer进行一些方法上的扩展。 jQurey 提供了两种方法扩张方式，分别为jQuery.fn.extend(object)和jQuery.extend(object). 想要搞清楚两种扩展方式之间的区别的话，先要了解什么是jQuery.fn. 本猿参考了 jQuery 的源码，发现其中玄机：12345jQuery.fn = jQuery.prototype = &#123; init: function(selector, context) &#123; // ... &#125;;&#125; jQuery.fn = jQuery.prototype这句代码明确指出jQuery.fn指代的就是 jQuery 的原型。 其次，我们要引入两个概念 类方法 和 实例方法 。 类方法 是直接可以使用类引用，不需要实例化就可以使用的方法。一般在项目中 类方法 都是被设置为工具类使用； 实例方法 必须先创建实例，然后才能通过实例调用该 实例方法 。 jQuery可以看做是这个封装得非常好的类，而我们可以使用jQuery选择器来创建 jQuery 的实例。比如：使 id 选择器$(‘#btn’)来创建一个实例。 区别 jQuery.extend(object)相当于对 类方法 的扩展。12345678910111213jQuery.extend(&#123; /* 返回两个元素中较小的值 */ min: function(a, b) &#123; return a &lt; b ? a : b; &#125;, /* 返回两个元素中较大的值 */ max: function(a, b) &#123; return a &gt; b ? a : b; &#125;&#125;);jQuery.min(2, 3); // 2jQuery.max(4, 5); // 5 jQuery.fn.extend(object)是对jQuery.prototype上的扩展。1jQuery.fn.extend = jQuery.prototype.extend 这种方式相当对 实例方法 的扩展。 举个栗子：开发一个简单的小功能，使用该方法可以使选定元素内的文字变红。1234567$.fn.extend(&#123; setRed: function() &#123; $(this).css(\"color\", \"red\"); &#125;&#125;);$('.tip').setRed(); $(&quot;.tip&quot;)创建了一个jQuery实例，通过它可以调用成员方法setRed. 上述代码可以实现预想的扩展，但最好返回this 以满足 jQuery 链式操作 的需要。 改良之后，代码如下：12345$.fn.extend(&#123; red: function() &#123; return $(this).css(\"color\", \"red\"); &#125;&#125;); 本文摘自：https://segmentfault.com/a/1190000004082170","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://mhynet.cn/tags/jquery/"}]},{"title":"javascript正则表达式","date":"2017-08-13T02:36:21.000Z","path":"javascript-regexp-note.html","text":"转载地址 网上正则表达式的教程够多了，但由于javascript的历史比较悠久，也比较古老，因此有许多特性是不支持的。我们先从最简单地说起，文章所演示的正则基本都是perl方式。 元字符( [ { \\ ^ $ | ) ? * + . 预定义的特殊字符 字符 正则 描述 \\t /\\t/ 制表符 \\n /\\n/ 制表符 \\r /\\r/ 回车符 \\f /\\f/ 换页符 \\a /\\a/ alert字符 \\e /\\e/ escape字符 \\cX /\\cX/ 与X相对应的控制字符 \\b /\\b/ 与回退字符 \\v /\\v/ 垂直制表符 \\0 /\\0/ 空字符 字符类简单类 原则上正则的一个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。如12345alert(/ruby/.test(\"ruby\"));//truealert(/[abc]/.test(\"a\"));//truealert(/[abc]/.test(\"b\"));//truealert(/[abc]/.test(\"c\"));//truealert(\"a bat ,a Cat,a fAt bat ,a faT cat\".match(/[bcf]at/gi));//bat,Cat,fAt,bat,faT,cat 使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。 负向类 也是在那个括号里做文章，前面加个元字符进行取反，表示匹配不能为括号里面的字符。1234alert(/[^abc]/.test(\"a\"));//falsealert(/[^abc]/.test(\"b\"));//falsealert(/[^abc]/.test(\"6\"));//truealert(/[^abc]/.test(\"gg\"));//true 范围类 还是在那个中括号里面做文章。有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以用它。特征就是在中间加了个横线。 组合类 还是在那个中括号里面做文章。允许用中括号匹配不同类型的单个字符。12345678910111213alert(/[a-f]/.test(\"b\"));//truealert(/[a-f]/.test(\"k\"));//falsealert(/[a-z]/.test(\"h\"));//truealert(/[A-Z]/.test(\"gg\"));//falsealert(/[^H-Y]/.test(\"G\"));//truealert(/[0-9]/.test(\"8\"));//truealert(/[^7-9]/.test(\"6\"));//truealert(/[a-m1-5\\n]/.test(\"a\"))//truealert(/[a-m1-5\\n]/.test(\"3\"))//truevar a = \"\\n\\ \"alert(/[a-m1-5\\n]/.test(a))//truealert(/[a-m1-5\\n]/.test(\"r\"))//false 预定义类 还是在那个中括号里面做文章，不过它好像已经走到尽头了。由于是中括号的马甲，因此它们还是对应一个字符。| 字符 | 等同于 | 描述 ||—–|——————|—————-|| . | [^\\n\\r] | 除了换行和回车之外的任意字符 || \\d | [0-9] | 数字字符 || \\D | [^0-9] | 非数字字符 || \\s | [ \\t\\n\\x0B\\f\\r] | 空白字符 || \\S | [^ \\t\\n\\x0B\\f\\r] | 非空白字符 || \\w | [a-zA-Z_0-9] | 单词字符(所有的字母) || \\W | [^a-zA-Z_0-9] | 非单词字符 | 1234567891011121314alert(/\\d/.test(\"3\"))//truealert(/\\d/.test(\"w\"))//falsealert(/\\D/.test(\"w\"))//truealert(/\\w/.test(\"w\"))//truealert(/\\w/.test(\"司\"))//falsealert(/\\W/.test(\"徒\"))//truealert(/\\s/.test(\" \"))//truealert(/\\S/.test(\" \"))//falsealert(/\\S/.test(\"正\"))//truealert(/./.test(\"美\"))//truealert(/./.test(\" \"))//truevar a = \"\\n\\ \"alert(/./.test(a))//true 量词由于元字符与特殊字符或字符类或者它们的组合（中括号）甚至它们的马甲（预定义类）都是一对一进行匹配。我们要匹配“司徒正美这个词”，最简单都要/…./，如果长到50多个字符岂不是要死人。因此我们逼切需要一个简单的操作，来处理这数量关系。 简单量词| 代码 | 类型 | 描述 | ||——-|——|—————|———|| ? | 软性量词 | | 出现零次或一次 || * | 软性量词 | 出现零次或多次(任意次) | || + | 软性量词 | 出现一次或多次（至道一次） | || {n} | 硬性量词 | 对应零次或者n次 | || {n,m} | 软性量词 | 至少出现n次但不超过m次 | || {n,} | 软性量词 | 至少出现n次(+的升级版) | | 12345678910alert(/..../.test(\"司徒正美\"))//truealert(/司徒正美/.test(\"司徒正美\"))//truealert(/[\\u4e00-\\u9fa5]&#123;4&#125;/.test(\"司徒正美\"))//truealert(/[\\u4e00-\\u9fa5]&#123;4&#125;/.test(\"司徒正美55\"))//truealert(/^[\\u4e00-\\u9fa5]+$/.test(\"正则表达式\"))//truealert(/^[\\u4e00-\\u9fa5]+$/.test(\"正则表达式&amp;*@@\"))//falsealert(/\\d&#123;6&#125;/.test(\"123456\"))//truealert(/[ruby]&#123;2&#125;/.test(\"rr\"))//truealert(/[ruby]&#123;2&#125;/.test(\"ru\"))//truealert(/[ruby]&#123;2&#125;/.test(\"ry\"))//true /[\\u4e00-\\u9fa5]/用于匹配单个汉字。 贪婪量词，惰性量词与支配性量词 贪婪量词，上面提到的所有简单量词。就像成语中说的巴蛇吞象那样，一口吞下整个字符串，发现吞不下（匹配不了），再从后面一点点吐出来（去掉最后一个字符，再看这时这个整个字符串是否匹配，不断这样重复直到长度为零） 隋性量词，在简单量词后加问号。由于太懒了，先吃了前面第一个字符，如果不饱再捏起多添加一个（发现不匹配，就读下第二个，与最初的组成一个有两个字符串的字符串再尝试匹配，如果再不匹配，再吃一个组成拥有三个字符的字符串……）。其工作方式与贪婪量词相反。 支配性量词，在简单量词后加加号。上面两种都有个不断尝试的过程，而支配性量词却只尝试一次，不合口味就算了。就像一个出身高贵居支配地位的公主。但你也可以说它是最懒量词。由于javascript不支持，所以它连出场的机会也没有了。 12345678910var re1 = /.*bbb/g;//贪婪var re2 = /.*?bbb/g;//惰性// var re3 = /.*+bbb/g;//支配性,javascript不支持，IE与所有最新的标准浏览器都报错alert(re1.test(\"abbbaabbbaaabbbb1234\")+\"\");//truealert(re1.exec(\"abbbaabbbaaabbbb1234\")+\"\");//nullalert(\"abbbaabbbaaabbbb1234\".match(re1)+\"\");//abbbaabbbaaabbbbalert(re2.test(\"abbbaabbbaaabbbb1234\")+\"\");//truealert(re2.exec(\"abbbaabbbaaabbbb1234\")+\"\");//aabbbalert(\"abbbaabbbaaabbbb1234\".match(re2)+\"\");//abbb,aabbb,aaabbb 分组到目前为止，我们只能一个字符de匹配，虽然量词的出现，能帮助我们处理一排密紧密相连的同类型字符。但这是不够的，下面该轮到小括号出场了，中括号表示范围内选择，大括号表示重复次数。小括号允许我们重复多个字符。123456//分组+量词alert(/(dog)&#123;2&#125;/.test(\"dogdog\"))//true//分组+范围alert(\"baddad\".match(/([bd]ad?)*/))//baddad,dad//分组+分组alert(\"mon and dad\".match(/(mon( and dad)?)/))//mon and dad,mon and dad, and dad 反向引用反向引用标识由正则表达式中的匹配组捕获的子字符串。每个反向引用都由一个编号或名称来标识，并通过“\\编号”表示法进行引用。123456789var color = \"#990000\";/#(\\d+)/.test(color);alert(RegExp.$1);//990000alert(/(dog)\\1/.test(\"dogdog\"))//truevar num = \"1234 5678\";var newNum = num.replace(/(\\d&#123;4&#125;) (\\d&#123;4&#125;)/,\"$2 $1\");alert(newNum) 候选继续在分组上做文章。在分组中插入管道符（“|”），把它划分为两个或多个候多项。1234var reg = /(red|black|yellow)!!/;alert(reg.test(\"red!!\"))//truealert(reg.test(\"black!!\"))//truealert(reg.test(\"yellow!!\"))//true 非捕获性分组并不是所有分组都能创建反向引用，有一种特别的分组称之为非捕获性分组，它是不会创建反向引用。反之，就是捕获性分组。要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就行了。123var color = \"#990000\";/#(?:\\d+)/.test(color);alert(RegExp.$1);//\"\" 题目，移除所有标签，只留下innerText!123var html = \"&lt;p&gt;&lt;a href='http://www.cnblogs.com/rubylouvre/'&gt;Ruby Louvre&lt;/a&gt;by &lt;em&gt;司徒正美&lt;/em&gt;&lt;/p&gt;\";var text = html.replace(/&lt;(?:.|\\s)*?&gt;/g, \"\");alert(text) 注意：javascript不存在命名分组前瞻 继续在分组内做文章。前瞻与后瞻其实都属于零宽断言，但javascript不支持后瞻。 零宽断言| 正则 | 名称 | 描述 ||———-|——|—————–|| (?=exp) | 正向前瞻 | 匹配exp前面的位置 || (?!exp) | 负向前瞻 | 匹配后面不是exp的位置 || (?&lt;=exp) | 正向后瞻 | 匹配exp后面的位置不支持 || (?&lt;!exp) | 负向后瞻 | 匹配前面不是exp的位置不支持 | 正向前瞻用来检查接下来的出现的是不是某个特定的字符集。而负向前瞻则是检查接下来的不应该出现的特定字符串集。零宽断言是不会被捕获的。123456789101112var str1 = \"bedroom\";var str2 = \"bedding\";var reBed = /(bed(?=room))///在我们捕获bed这个字符串时，抢先去看接下来的字符串是不是roomalert(reBed.test(str1));//truealert(RegExp.$1)//bedalert(RegExp.$2 === \"\")//truealert(reBed.test(str2))//falsevar str1 = \"bedroom\";var str2 = \"bedding\";var reBed = /(bed(?!room))/ //要来它后面不能是roomalert(reBed.test(str1))//falsealert(reBed.test(str2))//true 题目，移除hr以外的所有标签，只留下innerText!123var html = \"&lt;p&gt;&lt;a href='http://www.cnblogs.com/rubylouvre/'&gt;Ruby Louvre&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;by &lt;em&gt;司徒正美&lt;/em&gt;&lt;/p&gt;\";var text = html.replace(/&lt;(?!hr)(?:.|\\s)*?&gt;/ig,\"\")alert(text)//Ruby Louvre&lt;hr/&gt;by 司徒正美 边界 一个要与字符类合用的东西。| 正则 | 名称 | 描述 ||—–|——-|——————–|| ^ | 开头 | 注意不能紧跟于左中括号的后面 || $ | 结尾 | || \\b | 单词边界 | 指[a-zA-Z_0-9]之外的字符 || \\B | 非单词边界 | | 题目，设计一个字符串原型方法，实现首字母大写！1234567var a = \"ruby\"; String.prototype.capitalize = function () &#123; return this.replace(/^\\w/, function (s) &#123; return s.toUpperCase(); &#125;); &#125;alert(a.capitalize())//Ruby 单词边界举例。要匹配的东西的前端或未端不能为英文字母阿拉伯字数字或下横线。12var str = \"12w-eefd&amp;efrew\";alert(str.match(/\\b\\w+\\b/g))//12w,eefd,efrew 实例属性 描述 global 是当前表达式模式首次匹配内容的开始位置，从0开始计数。其初始值为-1，每次成功匹配时，index属性都会随之改变。 ignoreCase 返回创建RegExp对象实例时指定的ignoreCase标志（i）的状态。如果创建RegExp对象实例时设置了i标志，该属性返回True，否则返回False，默认值为False。 lastIndex 是当前表达式模式首次匹配内容中最后一个字符的下一个位置，从0开始计数，常被作为继续搜索时的起始位置，初始值为-1， 表示从起始位置开始搜索，每次成功匹配时，lastIndex属性值都会随之改变。(只有使用exec()或test()方法才会填入，否则为0) multiLine 返回创建RegExp对象实例时指定的multiLine标志（m）的状态。如果创建RegExp对象实例时设置了m标志，该属性返回True，否则返回False，默认值为False。 source 返回创建RegExp对象实例时指定的表达式文本字符串。 12345678910var str = \"JS's Louvre\";var reg = /\\w/g;alert(reg.exec(str));//Jalert(reg.lastIndex);//1alert(reg.exec(str));//Salert(reg.lastIndex);//2alert(reg.exec(str));//salert(reg.lastIndex);//4alert(reg.exec(str));//Lalert(reg.lastIndex);//6","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://mhynet.cn/tags/正则表达式/"}]},{"title":"DOM操作总结","date":"2017-08-02T02:36:21.000Z","path":"DOM-operate-note.html","text":"文档对象模型 (DOM) 是HTML和XML文档的编程接口。它给文档（结构树）提供了一个结构化的表述并且定义了一种方式—程序可以对结构树进行访问，以改变文档的结构，样式和内容。 DOM 提供了一种表述形式将文档作为一个结构化的节点组以及包含属性和方法的对象。从本质上说，它将web 页面和脚本或编程语言连接起来了。 要改变页面的某个东西，JavaScript就需要获得对HTML文档中所有元素进行访问的入口。这个入口，连同对 HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过DOM来获得的 document 对象每个载入浏览器的HTML文档都会成为document对象。document对象包含了文档的基本信息，我们可以通过JavaScript对HTML页面中的所有元素进行访问、修改。 document对象常用属性document对象有很多属性来描述文档信息，介绍几个常用的 doctype 在书写HTML文档的时候第一句一般都是doctype声明，可以通过document对象获取，没有则返回null12document.doctype; // &lt;!DOCTYPE html&gt;document.doctype.name; // \"html\" head、body12document.head;document.body; 通过这两个属性何以分别获取文档的head，body节点 activeElementactiveElement属性返回当前文档中获得焦点的那个元素。 用户通常可以使用tab键移动焦点，使用空格键激活焦点，比如如果焦点在一个链接上，此时按一下空格键，就会跳转到该链接documentURI、domain、lastModified - documentURI属性返回当前文档的网址 - domain属性返回文档域名 - lastModified返回当前文档的最后修改时间 location location属性返回一个只读对象，提供了当前文档的URL信息123456789101112131415161718192021222324// 假定当前网址为http://user:passwd@www.example.com:4097/path/a.html?x=111#part1document.location.href // \"http://user:passwd@www.example.com:4097/path/a.html?x=111#part1\"document.location.protocol // \"http:\"document.location.host // \"www.example.com:4097\"document.location.hostname // \"www.example.com\"document.location.port // \"4097\"document.location.pathname // \"/path/a.html\"document.location.search // \"?x=111\"document.location.hash // \"#part1\"document.location.user // \"user\"document.location.password // \"passed\"// 跳转到另一个网址document.location.assign('http://www.google.com')// 优先从服务器重新加载document.location.reload(true)// 优先从本地缓存重新加载（默认值）document.location.reload(false)// 跳转到另一个网址，但当前文档不保留在history对象中，// 即无法用后退按钮，回到当前文档document.location.assign('http://www.google.com')// 将location对象转为字符串，等价于document.location.hrefdocument.location.toString() 虽然location属性返回的对象是只读的，但是可以将URL赋值给这个属性，网页就会自动跳转到指定网址。 document.location = ‘http://www.example.com&#39;;// 等价于document.location.href = ‘http://www.example.com&#39;; title、characterSet title属性返回当前文档的标题，该属性是可写的 characterSet属性返回渲染当前文档的字符集 readyState readyState属性返回当前文档的状态，共有三种可能的值 loading：加载HTML代码阶段，尚未完成解析 interactive：加载外部资源阶段 complete：全部加载完成 compatMode compatMode属性返回浏览器处理文档的模式，可能的值为 BackCompat：向后兼容模式，也就是没有添加DOCTYPE CSS1Compat：严格模式，添加了DOCTYPE cookie cookie是存储在客户端的文本，后续在客户端存储章节会介绍到 innerText innerText是一个可写属性，返回元素内包含的文本内容，在多层次的时候会按照元素由浅到深的顺序拼接其内容123456&lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 外层div的innerText返回内容是 &quot;123456&quot; innerHTML、outerHTMLinnerHTML属性作用和innerText类似，但是不是返回元素的文本内容，而是返回元素的HTML结构，在写入的时候也会自动构建DOM123456&lt;div&gt; &lt;p&gt; 123 &lt;span&gt;456&lt;/span&gt; &lt;/p&gt;&lt;/div&gt; 外层div的innerHTML返回内容是 &quot;&lt;p&gt;123&lt;span&gt;456&lt;/span&gt;&lt;/p&gt;&quot;outerHTML 返回内容还包括本身 document对象常用方法open()、close()document.open方法用于新建一个文档，供write方法写入内容。它实际上等于清除当前文档，重新写入内容document.close方法用于关闭open方法所新建的文档。一旦关闭，write方法就无法写入内容了。write()document.write方法用于向当前文档写入内容。只要当前文档还没有用close方法关闭，它所写入的内容就会追加在已有内容的后面。1234document.open();document.write(\"hello\");document.write(\"world\");document.close(); 如果页面已经渲染完成再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。如果在页面渲染过程中调用write方法，并不会调用open方法。需要注意的是，虽然调用close方法之后，无法再用write方法写入内容，但这时当前页面的其他DOM节点还是会继续加载。除了某些特殊情况，应该尽量避免使用document.write这个方法。 Element除了document对象，在DOM中最常用的就是Element对象了，Element对象表示HTML元素。 Element 对象可以拥有类型为元素节点、文本节点、注释节点的子节点，DOM提供了一系列的方法可以进行元素的增、删、改、查操作 Element有几个重要属性 nodeName：元素标签名，还有个类似的tagName nodeType：元素类型 className：类名 id：元素id children：子元素列表（HTMLCollection） childNodes：子元素列表（NodeList） firstChild：第一个子元素 lastChild：最后一个子元素 nextSibling：下一个兄弟元素 previousSibling：上一个兄弟元素 parentNode、parentElement：父元素 查询元素 getElementById() getElementById方法返回匹配指定ID属性的元素节点。如果没有发现匹配的节点，则返回null。这也是获取一个元素最快的方法1var elem = document.getElementById(\"test\"); getElementsByClassName() getElementsByClassName方法返回一个类似数组的对象（HTMLCollection类型的对象），包括了所有class名字符合指定条件的元素（搜索范围包括本身），元素的变化实时反映在返回结果中。这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。12345var elements = document.getElementsByClassName(names);getElementsByClassName方法的参数，可以是多个空格分隔的class名字，返回同时具有这些节点的元素。document.getElementsByClassName('red test'); getElementsByTagName() getElementsByTagName方法返回所有指定标签的元素（搜索范围包括本身）。返回值是一个HTMLCollection对象，也就是说，搜索结果是一个动态集合，任何元素的变化都会实时反映在返回的集合中。这个方法不仅可以在document对象上调用，也可以在任何元素节点上调用。1var paras = document.getElementsByTagName(\"p\"); 上面代码返回当前文档的所有p元素节点。注意，getElementsByTagName方法会将参数转为小写后，再进行搜索。 getElementsByName() getElementsByName方法用于选择拥有name属性的HTML元素，比如form、img、frame、embed和object，返回一个NodeList格式的对象，不会实时反映元素的变化。123// 假定有一个表单是&lt;form name=\"x\"&gt;&lt;/form&gt;var forms = document.getElementsByName(\"x\");forms[0].tagName // \"FORM\" 注意，在IE浏览器使用这个方法，会将没有name属性、但有同名id属性的元素也返回，所以name和id属性最好设为不一样的值。 querySelector() querySelector方法返回匹配指定的CSS选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。12var el1 = document.querySelector(\".myclass\");var el2 = document.querySelector('#myParent &gt; [ng-click]'); querySelector方法无法选中CSS伪元素。 querySelectorAll() querySelectorAll方法返回匹配指定的CSS选择器的所有节点，返回的是NodeList类型的对象。NodeList对象不是动态集合，所以元素节点的变化无法实时反映在返回结果中。1elementList = document.querySelectorAll(selectors); querySelectorAll方法的参数，可以是逗号分隔的多个CSS选择器，返回所有匹配其中一个选择器的元素。1var matches = document.querySelectorAll(\"div.note, div.alert\"); 上面代码返回class属性是note或alert的div元素。 elementFromPoint() elementFromPoint方法返回位于页面指定位置的元素。1var element = document.elementFromPoint(x, y); 上面代码中，elementFromPoint方法的参数x和y，分别是相对于当前窗口左上角的横坐标和纵坐标，单位是CSS像素。 elementFromPoint方法返回位于这个位置的DOM元素，如果该元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值），则返回null。 创建元素 createElement() createElement方法用来生成HTML元素节点。1var newDiv = document.createElement(\"div\"); createElement方法的参数为元素的标签名，即元素节点的tagName属性。如果传入大写的标签名，会被转为小写。如果参数带有尖括号（即&lt;和&gt;）或者是null，会报错。 createTextNode() createTextNode方法用来生成文本节点，参数为所要生成的文本节点的内容。12var newDiv = document.createElement(\"div\");var newContent = document.createTextNode(\"Hello\"); 上面代码新建一个div节点和一个文本节点 createDocumentFragment() createDocumentFragment方法生成一个DocumentFragment对象。1var docFragment = document.createDocumentFragment(); DocumentFragment对象是一个存在于内存的DOM片段，但是不属于当前文档，常常用来生成较复杂的DOM结构，然后插入当前文档。这样做的好处在于，因为DocumentFragment不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的DOM有更好的性能表现。修改元素 appendChild() 在元素末尾添加元素123var newDiv = document.createElement(\"div\");var newContent = document.createTextNode(\"Hello\");newDiv.appendChild(newContent); insertBefore() 在某个元素之前插入元素123var newDiv = document.createElement(\"div\");var newContent = document.createTextNode(\"Hello\");newDiv.insertBefore(newContent, newDiv.firstChild); replaceChild() replaceChild()接受两个参数：要插入的元素和要替换的元素1newDiv.replaceChild(newElement, oldElement); 删除元素 删除元素使用removeChild()方法即可1parentNode.removeChild(childNode); clone元素 cloneNode()方法用于克隆元素，方法有一个布尔值参数，传入true的时候会深复制，也就是会复制元素及其子元素（IE还会复制其事件），false的时候只复制元素本身1node.cloneNode(true); 属性操作 getAttribute() getAttribute()用于获取元素的attribute值1node.getAttribute('id'); createAttribute() createAttribute()方法生成一个新的属性对象节点，并返回它。1attribute = document.createAttribute(name); createAttribute方法的参数name，是属性的名称。 setAttribute() setAttribute()方法用于设置元素属性12var node = document.getElementById(\"div1\");node.setAttribute(\"my_attrib\", \"newVal\"); 等同于1234var node = document.getElementById(\"div1\");var a = document.createAttribute(\"my_attrib\");a.value = \"newVal\";node.setAttributeNode(a); romoveAttribute() removeAttribute()用于删除元素属性1node.removeAttribute('id'); element.attributes 当然上面的方法做的事情也可以通过类操作数组属性element.attributes来实现 常见使用方式修改样式 可修改元素的 style 属性，修改结果直接反映到页面元素12document.querySelector('p').style.color = 'red'document.querySelector('.box').style.backgroundColor = '#ccc' 获取样式 getComputedStyle 使用getComputedStyle获取元素计算后的样式，不要通过 node.style.属性 获取123var node = document.querySelector('p')var color = window.getComputedStyle(node).colorconsole.log(color) class 操作123456var nodeBox = document.querySelector('.box')console.log( nodeBox.classList )nodeBox.classList.add('active') //新增 classnodeBox.classList.remove('active') //删除 classnodeBox.classList.toggle('active') //新增/删除切换node.classList.contains('active') // 判断是否拥有 class 样式的改变尽量使用 class 的新增删除来实现 页面宽高 123456document.body.clientHeightdocument.body.offsetHeightdocuemnt.body.style.border = \"10px solid red\"docuemnt.body.clientHeight //变小了document.body.offsetHeight element.scrollHeight 元素滚动内容的总长度。如果元素没出现滚动条， scrollHeight等于 clientHeight1document.body.scrollHeight element.scrollTop 滚动的高度1document.body.scrollTop window.innerHeight 窗口的高度1window.innerHeigh 问题1：如何判断一个元素是否出现在窗口视野中 问题2：如果判断页面滚动到底部 HTMLCollection和NodeList我们知道Element对象表示元素，那么多个元素的集合一般有两种数据类型 NodeList 对象代表一个有顺序的节点列表，HTMLCollection 是一个接口，表示 HTML 元素的集合，它提供了可以遍历列表的方法和属性 以下方法获取的为HTMLCollection对象 document.images //所有img元素document.links //所有带href属性的a元素和area元素document.anchors //所有带name属性的a元素document.forms //所有form元素document.scripts //所有script元素document.applets //所有applet元素document.embeds //所有embed元素document.plugins //document.与embeds相同document.getElementById(“table”).childrendocument.getElementById(“table”).tBodiesdocument.getElementById(“table”).rowsdocument.getElementById(“row”).cellsdocument.getElementById(“Map”).areasdocument.getElementById(“f2”).elements //HTMLFormControlsCollection extends HTMLCollectiondocument.getElementById(“s”).options //HTMLOptionsCollection extends HTMLCollection 以下方法获取的为NodeList对象 document.getElementsByName(“name1”)document.getElementsByClassName(“class1”)document.getElementsByTagName(“a”)document.querySelectorAll(“a”)document.getElementById(“table”).childNodesdocument.styleSheets //StyleSheetList，与NodeList类似 HTMLCollection与NodeList有很大部分相似性 都是类数组对象，都有length属性，可以通过for循环迭代 都是只读的 都是实时的，即文档的更改会立即反映到相关对象上面(有一个例外，document.querySelectorAll返回的NodeList不是实时的) 都有item()方法，可以通过item(index)或item(“id”)获取元素 不同点在于 HTMLCollection对象具有namedItem()方法，可以传递id或name获得元素 HTMLCollection的item()方法和通过属性获取元素(document.forms.f1)可以支持id和name，而NodeList对象只支持id","tags":[{"name":"javascript","slug":"javascript","permalink":"https://mhynet.cn/tags/javascript/"},{"name":"DOM","slug":"DOM","permalink":"https://mhynet.cn/tags/DOM/"}]},{"title":"meta标签总结与属性使用介绍","date":"2017-07-10T02:36:21.000Z","path":"html5-meta-properties.html","text":"英文版w3school中,meta的解释为“元数据”，元数据在Google就有详细解释。 The &lt;meta&gt; tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable. 不难看出，其中的关键是metadata，中文名叫元数据，是用于描述数据的数据。它不会显示在页面上，但是机器却可以识别。这么一来meta标签的作用方式就很好理解了。 用处 Meta elements are typically used to specify page description, keywords, author of the document, last modified, and other metadata. The metadata can be used by browsers (how to display content or reload page), search engines (keywords), or other web services 这句话对meta标签用处的介绍，简洁明了。翻译过来就是：meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。 组成meta标签共有两个属性，分别是http-equiv属性和name属性。 1. name属性name属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。meta标签中name属性语法格式是：1&lt;meta name=\"参数\" content=\"具体的描述\"&gt; 其中name属性共有以下几种参数。(A-C为常用属性) A. keywords(关键字)说明：用于告诉搜索引擎，你网页的关键字。举例：1&lt;meta name=\"keywords\" content=\"博客，前端\"&gt; B. description(网站内容的描述)说明：用于告诉搜索引擎，你网站的主要内容。举例：1&lt;meta name=\"description\" content=\"这是我的博客\"&gt; C. viewport(移动端的窗口)说明：这个概念较为复杂,这个属性常用于设计移动端网页。在用bootstrap,AmazeUI等框架时候都有用过viewport。 举例（常用范例）：1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; D. robots(定义搜索引擎爬虫的索引方式)说明：robots用来告诉爬虫哪些页面需要索引，哪些页面不需要索引。content的参数有all,none,index,noindex,follow,nofollow。默认是all。 举例：1&lt;meta name=\"robots\" content=\"none\"&gt; 具体参数如下： none : 搜索引擎将忽略此网页，等价于noindex，nofollow。 noindex : 搜索引擎不索引此网页。 nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。 all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。 index : 搜索引擎索引此网页。 follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。 author(作者) 说明：用于标注网页作者举例：1&lt;meta name=\"author\" content=\"mhy, dsz9258@163.com\"&gt; F. generator(网页制作软件)说明：用于标明网页是什么软件做的举例: (不知道能不能这样写)：1&lt;meta name=\"generator\" content=\"Sublime Text3\"&gt; G. copyright(版权)说明：用于标注版权信息举例：12&lt;!-- 代表该网站为mhy个人版权所有。 --&gt;&lt;meta name=\"copyright\" content=\"mhy\"&gt; H. revisit-after(搜索引擎爬虫重访时间)说明：如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问。举例：1&lt;meta name=\"revisit-after\" content=\"7 days\" &gt; I. renderer(双核浏览器渲染方式)说明：renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。比如说360浏览器。举例：123456&lt;!-- 默认webkit内核 --&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;!-- 默认IE兼容模式 --&gt;&lt;meta name=\"renderer\" content=\"ie-comp\"&gt;&lt;!-- 默认IE标准模式 --&gt;&lt;meta name=\"renderer\" content=\"ie-stand\"&gt; 2. http-equiv属性介绍之前，先说个小插曲。看文档和博客关于http-equiv的介绍时，有这么一句。 http-equiv顾名思义，相当于http的文件头作用。 一开始看到这句话的时候，我是迷糊的。因为我看各类技术名词，都会习惯性的去记住它的英文全称。equiv的全称是”equivalent”，意思是相等，相当于。然后我脑子里出现了大大的迷惑：“HTTP相等？” 后来还准备去Segmentfault提问来着。结果在写问题的时候，突然反应出equivalent还有相当于的意思。意思就是相当于http的作用。至于文件头是哪儿出来的，估计是从其作用来分析的。我认为顾名思义并不能得出”相当于http的文件头作用”这个论断。 这个我所认为的http-equiv意思的简介。相当于HTTP的作用，比如说定义些HTTP参数啥的。 meta标签中http-equiv属性语法格式是：1&lt;meta http-equiv=\"参数\" content=\"具体的描述\"&gt; 其中http-equiv属性主要有以下几种参数： A. content-Type(设定网页字符集)(推荐使用HTML5的方式)说明：用于设定网页字符集，便于浏览器解析与渲染页面举例：1234&lt;!-- 旧的HTML，不推荐 --&gt;&lt;meta http-equiv=\"content-Type\" content=\"text/html;charset=utf-8\"&gt;&lt;!-- HTML5设定网页字符集的方式，推荐使用UTF-8 --&gt;&lt;meta charset=\"utf-8\"&gt; B. X-UA-Compatible(浏览器采取何种版本渲染当前页面)说明：用于告知浏览器以何种版本来渲染页面。（一般都设置为最新模式，在各大框架中这个设置也很常见。）举例：12&lt;!-- 指定IE和Chrome使用最新版本渲染当前页面 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; C. cache-control(指定请求和响应遵循的缓存机制)用法1. 说明：指导浏览器如何缓存某个响应以及缓存多长时间。这一段内容我在网上找了很久，但都没有找到满意的。最后终于在Google Developers中发现了我想要的答案。 举例:1&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt; 共有以下几种用法： no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。 no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施） public: 缓存所有响应，但并非必须。因为max-age也可以做到相同效果 private: 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应） maxage: 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。 用法2.(禁止百度自动转码) 说明：用于禁止当前页面在移动端浏览时，被百度自动转码。虽然百度的本意是好的，但是转码效果很多时候却不尽人意。所以可以在head中加入例子中的那句话，就可以避免百度自动转码了。举例：1&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; D. expires(网页到期时间)说明:用于设定网页的到期时间，过期后网页必须到服务器上重新传输。举例：1&lt;meta http-equiv=\"expires\" content=\"Sunday 26 October 2016 01:00 GMT\" /&gt; E. refresh(自动刷新并指向某页面)说明：网页将在设定的时间内，自动刷新并调向设定的网址。举例:12&lt;!-- 意思是2秒后跳转向我的博客 --&gt;&lt;meta http-equiv=\"refresh\" content=\"2；URL=http://www.lxxyx.win/\"&gt; F. Set-Cookie(cookie设定)说明：如果网页过期。那么这个网页存在本地的cookies也会被自动删除。1234&lt;!-- 格式 --&gt;&lt;meta http-equiv=\"Set-Cookie\" content=\"name, date\"&gt;&lt;!-- 具体范例 --&gt;&lt;meta http-equiv=\"Set-Cookie\" content=\"User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT\"&gt; 移动设备通用meta标签1&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; 设定是否将网页中的手机号码显示为拨号的超链接，iphone上默认为yes。\b该属性设置为yes时，使用手机设备打开页面后点击页面\b上的手机号码可以拨打电话。1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=0, viewport-fit=cover\"/&gt; viewport属性用于设置移动端页面是否可以缩放，具体配置项有以下几个: width: viewport的宽度 height: viewport的高度 initial-scale: 初始的缩放比例 minimum-scale: 允许用户缩放到的最小比例 maxmum-scale: 允许用户缩放的最大比例 user-scalable: 用户是否可以\b手动缩放 viewport-fit: 处理iphone X 刘海部位的白条，设置该meta属性可以把网页拓展至整个屏幕（或者给body设置background-color） IOS设备\b的私有属性12&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt; 这两个会让网页内容以应用程序风格显示，并使状态栏透明。 参考1参考2","tags":[{"name":"html5","slug":"html5","permalink":"https://mhynet.cn/tags/html5/"},{"name":"meta","slug":"meta","permalink":"https://mhynet.cn/tags/meta/"}]}]