<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>shanks的学习日志</title><subtitle>shanks的学习日志</subtitle><link href="/atom.xml" rel="self"/><link href="https://mhynet.cn/"/><updated>2020-01-13T04:05:08.194Z</updated><id>https://mhynet.cn/</id><author><name>shanks</name></author><generator uri="http://hexo.io/">Hexo</generator><entry><title>cssText批量修改dom的样式</title><link href="https://mhynet.cn/cssText-operate-style.html"/><id>https://mhynet.cn/cssText-operate-style.html</id><published>2019-11-26T03:09:34.000Z</published><updated>2020-01-13T04:05:08.194Z</updated><content type="html"><![CDATA[<p>之前用js修改dom的样式一般都是采用以下的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="keyword">this</span>.$refs.target;</span><br><span class="line">element.style.width = <span class="string">'200px'</span>;</span><br><span class="line">element.style.height = <span class="string">'100px'</span>;</span><br><span class="line">element.style.color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure></p><p>样式不多的话，性能还可以，但是如果样式特别多，或者涉及到动画的时候，性能会不太理想。前者每一次设置都会reflow一次，后者之后reflow一次。<br>早上阅读某开源框架的源码时发现了一种用js覆写css的方式，查阅之后发现兼容性和性能都超级棒，这里记录一下以加深记忆。</p><h2 id="功能和语法"><a href="#功能和语法" class="headerlink" title="功能和语法"></a>功能和语法</h2><p>MDN介绍:</p><blockquote><p>The cssText property of the CSSStyleDeclaration interface returns or sets the text of the element’s inline style declaration only. To be able to set a stylesheet rule dynamically, see Using dynamic styling information.</p></blockquote><p>语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="keyword">this</span>.$refs.target;</span><br><span class="line"><span class="comment">// 获取内联样式,好像只能获取到内联样式，写在style标签和css文件中的样式需要使用 window.getComputedStyle 获取</span></span><br><span class="line">alert(element.style.cssText)</span><br><span class="line"><span class="comment">// 覆写样式</span></span><br><span class="line">element.style.cssText = <span class="string">'width:200px;height:100px;color:red;'</span>;</span><br></pre></td></tr></table></figure></p><p>使用<code>cssText</code>会覆盖之前的所有样式，所以如果要保留之前的样式，则需要先获取到已有样式，然后追加新样式。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>各浏览器目前都兼容（包括IE6,7,8）<code>cssText</code>的方式设置样式，但是在IE下，累加的时候回丢失之前的样式中最后一个<code>;</code>， 所有需要做一下兼容，可以采用正则的方式对获取到的已有样式进行匹配。<br>获取已有属性可以用<code>window.getComputedStyle</code>，IE浏览器用<code>document.currentStyle</code>，此API仅用来覆写样式即可。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取原有样式, IE 用 dom元素.currentStyle 火狐谷歌用window.getComputedStyle(dom, null)</span></span><br><span class="line"><span class="keyword">const</span> getStyle = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.document.currentStyle) &#123;</span><br><span class="line"><span class="keyword">return</span><span class="function">(<span class="params">dom, attr</span>) =&gt;</span> dom.currentStyle[attr];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span><span class="function">(<span class="params">dom, attr</span>) =&gt;</span> getComputedStyle(dom, <span class="literal">false</span>)[attr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.querySelecter(<span class="string">'#target'</span>);</span><br><span class="line"><span class="keyword">let</span> widthExists = getStyle(element, <span class="string">'width'</span>);</span><br><span class="line"><span class="comment">// 去除px</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="built_in">Number</span>(widthExists.replace(<span class="regexp">/\%/g</span>, <span class="string">''</span>));</span><br><span class="line">element.style.cssText += <span class="string">`;width: <span class="subst">$&#123;widthExists + <span class="number">200</span>&#125;</span>px;`</span></span><br></pre></td></tr></table></figure><p>这里用到了<code>getComputedStyle和currentStyle</code>，其中<code>currentStyle</code>是IE浏览器的API，<code>getComputedStyle</code>是google等主流浏览器都支持的获取已有样式的接口。<br>该方法有两个参数，第一个参数是要获取样式的dom节点，第二个参数一般可设置为 <code>null</code>或<code>fasle</code>，仅在获取伪类元素时传入伪类的值，返回值是一个只读的对象，里面包含了该dom元素的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">h3</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">        content: "rocks!";</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>generated content<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> h3 = <span class="built_in">document</span>.querySelector(<span class="string">'h3'</span>),</span></span><br><span class="line"><span class="actionscript">    result = getComputedStyle(h3, <span class="string">'::after'</span>).content;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">`the generated content is: <span class="subst">$&#123;result&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">`the generated content is: <span class="subst">$&#123;result&#125;</span>`</span>);</span></span><br><span class="line"><span class="actionscript"><span class="comment">// the generated content is: "rocks!"</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content><summary type="html">
    
      使用cssText批量修改dom样式, 性能和兼容性都超级棒！
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="css" scheme="https://mhynet.cn/tags/css/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/></entry><entry><title>vps搭建指南</title><link href="https://mhynet.cn/vps-deploy-guide.html"/><id>https://mhynet.cn/vps-deploy-guide.html</id><published>2019-09-23T08:00:56.000Z</published><updated>2020-01-13T04:05:08.200Z</updated><content type="html"><![CDATA[<p>上周发现我的vps又被禁了，又得重新部署。<br>每次部署vps都要google搜索相关命令，特别麻烦，这里记录一下搭建vps的简单步骤吧。</p><a id="more"></a><p>安装shadowsocks命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure></p><p>安装过程中根据命令行交互选择服务器类型（如Shadowsocks-libev）、端口、密码、加密方法等。<br>如Shadowsocks-libev类型的服务的配置文件在 <code>/etc/shadowsocks-libev/config.json</code>，可以编辑配置。</p><p>查看状态<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d<span class="regexp">/shadowsocks-libev status</span></span><br></pre></td></tr></table></figure></p><p>重启服务<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d<span class="regexp">/shadowsocks-libev restart</span></span><br></pre></td></tr></table></figure></p><p>关闭服务<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-libev <span class="built_in">stop</span></span><br></pre></td></tr></table></figure></p><p>开启服务<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d<span class="regexp">/shadowsocks-libev start</span></span><br></pre></td></tr></table></figure></p><p>参考:<br><a href="https://zoomyale.com/2016/vultr_and_ss/" target="_blank" rel="noopener">科学上网的终极姿势：在 Vultr VPS 上搭建 Shadowsocks</a><br><a href="https://www.vps234.com/hostwinds-purchase-tutorial/" target="_blank" rel="noopener">美国 VPS Hostwinds 购买流程新手教程</a><br><a href="https://teddysun.com/489.html" target="_blank" rel="noopener">一键安装最新内核并开启 BBR 脚本</a><br><a href="https://teddysun.com/276.html" target="_blank" rel="noopener">新购VPS后的设置及网站迁移步骤</a><br><a href="https://www.10besty.com/best-vps-hosting-services/" target="_blank" rel="noopener">2019年最好的国外VPS推荐</a></p>]]></content><summary type="html">
    
      vps搭建指南，实现科学上网
    
    </summary><category term="vps" scheme="https://mhynet.cn/categories/vps/"/><category term="vps" scheme="https://mhynet.cn/tags/vps/"/></entry><entry><title>vue+element后台管理搜索表单缓存</title><link href="https://mhynet.cn/vue-element-admin-search-query-cache.html"/><id>https://mhynet.cn/vue-element-admin-search-query-cache.html</id><published>2019-06-22T02:41:53.000Z</published><updated>2020-01-13T04:05:08.200Z</updated><content type="html"><![CDATA[<p>在后台管理系统中经常会有这样的需求，从列表页跳转到详情页再返回列表后希望保持之前的查询条件，此类需求一般有以下几种处理方式可以参考。</p><a id="more"></a><h2 id="新页面打开详情页"><a href="#新页面打开详情页" class="headerlink" title="新页面打开详情页"></a>新页面打开详情页</h2><p>偷懒的做法是打开详情页时在新窗口打开，这样就可以保持列表页的搜索参数了，但是这样往往会打开很多的新页面，用户需要在多个页面直接来回切换操作繁琐，而且有个关键的问题是切换到列表页标签后数据并不是最新的，因为刚才在详情页已经编辑过数据了。我负责开发维护的后台管理系统在新建和编辑时是在不同的路由下调用同一个详情页组件来实现的，所以在编辑和新建请求完成之后详情页是否直接关闭还是让用户手动关闭是一个问题，新建页如果留给用户处理会连续创建多条相同数据的情况发生。而且连续打开多个页面标签页违背了单页面应用的初衷， 基于这些问题，我放弃了这种方式。<br>基于vue技术栈，在新标签页打开详情页主要有两种实现方式，一种是 <code>router-link</code>标签加<code>target=&quot;_blank&quot;</code>属性，其原理是<code>a</code>标签的<code>target</code>属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span><span class="attr">:to</span>=<span class="string">"&#123;name: 'detail'&#125;"</span><span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>另一种方式是js控制，其绑定的DOM元素渲染之后不再是<code>a</code>标签，而是一个<code>button</code>，页面跳转主要是基于<code>window</code>对象的功能实现的。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"handleToDetail(params)"</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span><span class="keyword">default</span>&#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript"><span class="comment">// 参数可以自定义,一般包含主键id等性质的参数</span></span></span><br><span class="line">    handleToDetail(params) &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> routerData = <span class="keyword">this</span>.$router.resolve(&#123;name: <span class="string">'detail'</span>, query: &#123;params: params&#125;&#125;)</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.open(routerData.href, <span class="string">"_blank"</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中的<code>vue-router</code>特性不多说，具体可以查阅<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="query携带查询参数"><a href="#query携带查询参数" class="headerlink" title="query携带查询参数"></a>query携带查询参数</h2><p>另一种实现方式是在路由跳转时在路由的<code>query</code>中把参数携带过去，返回时再带回来，列表页在<code>mounted</code>生命周期内对<code>query</code>进行处理，如果<code>query</code>中携带了查询参数则使用该查询参对数据进行赋值然后查询即可。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form</span><span class="attr">:model</span>=<span class="string">"params"</span><span class="attr">inline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-from-item</span><span class="attr">prop</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"params.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-from-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-from-item</span><span class="attr">prop</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"params.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-from-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-from-item</span><span class="attr">prop</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"params.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-from-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"handleToDetail"</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> &#123;</span></span><br><span class="line">      params: &#123;</span><br><span class="line"><span class="actionscript">        id: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        title: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        desc: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        imgUrl: <span class="string">''</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.getSearchQueryIfExists()</span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.handleSearch()</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript"><span class="comment">// 路由跳转时把搜索表单参数转换成字符串赋值给searchQuyery携带过去 ，跳转回来时直接带回来</span></span></span><br><span class="line">    handleToDetail() &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">const</span> params = <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.params)</span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$router.push(&#123;name: <span class="string">'detail'</span>, query: &#123; id: <span class="keyword">this</span>.params.id, searchQuyery: params &#125;&#125;)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 进入列表时，如果query中含有searchQuyery字段，则转换成对象赋值给查询对象参数即可</span></span></span><br><span class="line">    getSearchQueryIfExists() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">const</span> &#123; query = &#123;&#125; &#125; = <span class="keyword">this</span>.$router.query</span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span>(query.hasOwnProperty(<span class="string">'searchQuyery'</span>)) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> stashQuery = <span class="built_in">JSON</span>.parse(query.searchQuyery)</span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.params = stashQuery</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">// 发送查询http请求</span></span></span><br><span class="line">  handleSearch() &#123;</span><br><span class="line"><span class="actionscript"><span class="comment">// 。。。。</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这种实现方式可以基本满足要求，在页面较少或者项目中没有引入vuex时可以使用。缺点是需要缓存的页面较多时，需要重复进行处理，比较繁琐。</p><h2 id="使用vuex缓存查询参数"><a href="#使用vuex缓存查询参数" class="headerlink" title="使用vuex缓存查询参数"></a>使用vuex缓存查询参数</h2><p>如果需要缓存的页面较多，且系统中已经引入了<code>vuex</code>，则可以使用<code>vuex</code>缓存的方式来实现查询参数缓存。<br>首先需要把查询参数写入<code>vuex</code>中, 在<code>store</code>目录下创建一个用于缓存路由查询参数的文件，例如<code>routerCache.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routerCache.js</span></span><br><span class="line"><span class="keyword">const</span> routeCache = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    cachedRoutes: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    SET_CACHED_ROUTES: <span class="function">(<span class="params">state, route</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; name, query &#125; = route</span><br><span class="line">      state.cachedRoutes[name] = query</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    setCachedRoutes(&#123; commit &#125;, route) &#123;</span><br><span class="line">      commit(<span class="string">'SET_CACHED_ROUTES'</span>, route)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> routeCache</span><br></pre></td></tr></table></figure></p><p>在<code>getter</code>中引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getter.js</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  cachedRoutes: <span class="function"><span class="params">state</span> =&gt;</span> state.routeCache.cachedRoutes,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> getters</span><br></pre></td></tr></table></figure></p><p>其中，<code>name</code>是路由的<code>name</code>属性值，查询参数<code>query</code>保存在<code>name</code>中，当然也可以使用路由的<code>path</code>做为键，区别在于是否区分动态路由。<code>query</code>可以是对象，也可以是JSON化的字符串，建议使用JSON字符串进行保存。<br>接下来是在查询时调用<code>actions</code>中的<code>setCachedRoutes()</code>方法保存页面查询参数和进入页面后获取<code>getter</code>中缓存的值。这部分涉及<code>vuex</code>的使用方式，不太清楚可以查阅<a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">官方文档</a>。这部分我们可以使用<code>mixin</code>进行封装，暴露出两个方法来保存和获取缓存即可。如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins/queryCache.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions, mapGetters &#125; <span class="keyword">from</span><span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">      searchKey: <span class="string">''</span><span class="comment">// 每个页面查询表单`model`绑定的值可能不一样，使用此变量来接收查询对象的 key 值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">'cachedRoutes'</span>])</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([<span class="string">'setCachedRoutes'</span>]),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置路由缓存相关配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: queryKey 页面搜索表单对象的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setSearchQuery(queryKey) &#123;</span><br><span class="line"><span class="keyword">const</span> name = <span class="keyword">this</span>.$route.name</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span><span class="keyword">this</span>.setCachedRoutes === <span class="string">'function'</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.setCachedRoutes(&#123; <span class="attr">name</span>: name, <span class="attr">query</span>: <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[queryKey]) &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取路由缓存相关配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: queryKey 页面搜索表单对象的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getSearchQuery(queryKey) &#123;</span><br><span class="line"><span class="comment">// 如果使用 路由 的 name属性缓存的话，这里就取当前页面路由的 name值，如果使用了 path 缓存替换即可</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="keyword">this</span>.$route.name</span><br><span class="line"><span class="keyword">const</span> cachedRoutes = <span class="keyword">this</span>.cachedRoutes || &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (cachedRoutes.hasOwnProperty(name)) &#123;</span><br><span class="line"><span class="keyword">const</span> target = <span class="built_in">JSON</span>.parse(cachedRoutes[name])</span><br><span class="line"><span class="keyword">this</span>[queryKey] = <span class="built_in">Object</span>.assign(&#123;&#125;, target）</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果需要缓存查询参数对象之外的方法，则需要在<code>getSearchQuery</code>和<code>setSearchQuery</code>中添加特殊情况下的判断逻辑即可。其中<code>setSearchQuery</code>可以在点击搜索按钮或发送查询请求时进行调用，区别在是否需要缓存分页查询相关参数。<code>getSearchQuery</code>必须在<code>created</code>或<code>mounted</code>生命周期中掉用，将缓存的数据赋值给查询对象之后调用页面的查询请求，这样就实现了路由跳转的查询数据缓存。<br>页面中调用方法代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CacheQuery <span class="keyword">from</span><span class="string">'../mixins/queryCache'</span><span class="comment">// 具体路径按项目实际路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    reutrn &#123;</span><br><span class="line"><span class="comment">// 查询表单数据对象</span></span><br><span class="line">      params: &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  mounted() &#123;</span><br><span class="line"><span class="comment">// 获取vuex中的缓存，赋值</span></span><br><span class="line"><span class="keyword">this</span>.getSearchQuery(<span class="string">'params'</span>)</span><br><span class="line"><span class="comment">// 然后按缓存的参数查询</span></span><br><span class="line"><span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="comment">// 搜索点击事件监听</span></span><br><span class="line">    handleSearch() &#123;</span><br><span class="line"><span class="comment">// 缓存搜索参数</span></span><br><span class="line"><span class="keyword">this</span>.setSearchQuery(<span class="string">'params'</span>)</span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"><span class="keyword">this</span>.getList()</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="keyword">async</span> getList() &#123;</span><br><span class="line"><span class="comment">// 获取数据发送请求</span></span><br><span class="line"><span class="keyword">let</span> resp = <span class="keyword">await</span> axios.get(<span class="string">'/api/get/list'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，如果要缓存分页参数，可能会发现一个问题。示例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询参数对象:</span></span><br><span class="line">searchParams: &#123;</span><br><span class="line">  id: <span class="string">''</span>,</span><br><span class="line">  title: <span class="string">''</span>,</span><br><span class="line">  status: <span class="string">''</span>,</span><br><span class="line">  current_page: <span class="number">1</span>, <span class="comment">// 当前页</span></span><br><span class="line">  page_size: <span class="number">10</span>， <span class="comment">// 每页多少数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分页组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag"><span class="attr">:total</span>=<span class="string">"page.total"</span></span></span><br><span class="line"><span class="tag"><span class="attr">:current-page</span>=<span class="string">"searchParams.page_index"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">current-change</span>=<span class="string">"handleCurrentChange"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果查询参数中包含了分页组件中的两个参数，在调用了<code>getSearchQuery</code>方法对其进行赋值之后，即便发送请求时的<code>current_page</code>是2，<code>el-pagination</code>组件中显示的仍然是在页面的<code>data</code>中初始化时的默认值，研究了element分页组件的源码，发现其改变<code>current-page</code>只能通过监听<code>current-change</code>来实现，而在上文中缓存了数据之后直接赋值是无法实现响应的, 如下图:</p><p><img style="height: 200px; text-align: left" src="https://camo.githubusercontent.com/4374fd8950b1b788fe9642b70b36e9e9ef2b7627/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f363731393838352d373435666433626362366637306337302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"></p><p>分享告一段落啦，如果您有其他的实现方式可以留言交流啊，感谢！</p>]]></content><summary type="html">
    
      vue + element后台管理系统，搜索表达缓存实现方案，再也不用担心页面跳转之后需要重新填写大量搜索表单了
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/><category term="vue" scheme="https://mhynet.cn/tags/vue/"/><category term="element" scheme="https://mhynet.cn/tags/element/"/></entry><entry><title>pynongo使用笔记</title><link href="https://mhynet.cn/pynongo-notes.html"/><id>https://mhynet.cn/pynongo-notes.html</id><published>2019-06-11T03:38:12.000Z</published><updated>2020-01-13T04:05:08.199Z</updated><content type="html"><![CDATA[<p>前段时间学习了python爬虫，然后爬取了必应壁纸、拉钩、小红唇视频和评论等，其中也使用了mongodb数据库存储数据。</p><p>工作电脑和家里电脑都实现了壁纸每分钟实时更新，海量的背景图片，基本不重复，每天中午休息时喜欢盯着屏幕发呆，哈哈😁。其中除了用到的除了基本的爬虫至少，还有pymongo将爬取的数据存储到数据库，不会因为官方更新而丢失早期的图片信息，也用到了shell脚本和crontab定时任务，每周一中午定时爬取，然后下载图片，非常nice啊。<br><a id="more"></a><br>更多脚本可以去<a href="https://github.com/mhy-web/python_demo" target="_blank" rel="noopener">github</a>看到，自动执行的shell脚本为项目目录下的 <code>wallpaper.sh</code>文件。</p><p>这里记录一下pymongo使用笔记，避免下次使用时再去找文档。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入pymongo</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">client = pymongo.Conection(<span class="string">'127.0.0.1'</span>, <span class="number">27017</span>)</span><br><span class="line">client = pymongo.Conection(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">27017</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">db = client.bing</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">db = client[<span class="string">'bing'</span>]</span><br><span class="line"><span class="comment"># 其中的`bing`是所创建的数据库的名称。</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">dbName = <span class="string">'xhc'</span></span><br><span class="line">db = client[dbName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接集合</span></span><br><span class="line">collection = db.video</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">collection = db[<span class="string">'video'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看全部集合名称</span></span><br><span class="line">db.collection_names()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找集合的记录</span></span><br><span class="line">db.bing.find()</span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> db.test.find():</span><br><span class="line">  print(doc)</span><br><span class="line">db.bing.find_one(&#123;x: <span class="number">1</span>&#125;)</span><br><span class="line">db.bing.find_mangy(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">db.bing.count_document(&#123;x: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">db.bing.insert_one(&#123;x: <span class="number">1</span>&#125;)</span><br><span class="line">db.bing.insert_many([&#123;<span class="string">'x'</span>: i&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">db.bing.replace_one(&#123;x: <span class="number">1</span>&#125;, &#123;y: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line"><span class="comment"># update 后面的操作符同 mongodb 原生的操作符</span></span><br><span class="line">db.bing.update_one(&#123;x: <span class="number">1</span>&#125;, &#123;<span class="string">'$inc'</span>: &#123;x: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">db.bing.find_one_and_update(&#123;<span class="string">'_id'</span>: <span class="number">665</span>&#125;, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'count'</span>: <span class="number">1</span>&#125;, <span class="string">'$set'</span>: &#123;<span class="string">'done'</span>: <span class="literal">True</span>&#125;&#125;)</span><br><span class="line">db.bing.find_one_and_update(&#123;<span class="string">'_exists'</span>: <span class="literal">False</span>&#125;, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'count'</span>: <span class="number">1</span>&#125;&#125;)</span><br><span class="line">db.bing.find_one_and_update(</span><br><span class="line">  &#123; <span class="string">'_id'</span>: <span class="string">'userid'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'$inc'</span>: &#123;<span class="string">'seq'</span>: <span class="number">1</span>&#125;&#125;,</span><br><span class="line">  projection=&#123;<span class="string">'seq'</span>: <span class="literal">True</span>, <span class="string">'_id'</span>: <span class="literal">False</span>&#125;,</span><br><span class="line">  upsert=<span class="literal">True</span>,</span><br><span class="line">  return_document=ReturnDocument.AFTER</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">db.bing.delete_one(&#123;x: <span class="number">1</span>&#125;)</span><br><span class="line">db.bing.delete_many(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">db.bing.find_one_and_delete(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">db.bing.find_one_and_delete(&#123;<span class="string">'x'</span>: <span class="number">1</span>&#125;, sort=[(<span class="string">'_id'</span>, pymongo.DESCENDING)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建索引</span></span><br><span class="line">db.bing.create_index(<span class="string">"mike"</span>)</span><br></pre></td></tr></table></figure></p><p>更多内容可以参考官方文档。<br>参考文档： <a href="http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.delete_one" target="_blank" rel="noopener">http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.delete_one</a></p>]]></content><summary type="html">
    
      使用pymongo操作数据库，python爬虫常用数据库操作语句
    
    </summary><category term="后端" scheme="https://mhynet.cn/categories/%E5%90%8E%E7%AB%AF/"/><category term="python" scheme="https://mhynet.cn/tags/python/"/><category term="mongodb" scheme="https://mhynet.cn/tags/mongodb/"/></entry><entry><title>elementUI表单使用自定义组件并获取子组件验证</title><link href="https://mhynet.cn/elementUI-component-validate.html"/><id>https://mhynet.cn/elementUI-component-validate.html</id><published>2019-04-20T03:04:54.000Z</published><updated>2020-01-09T06:58:58.346Z</updated><content type="html"><![CDATA[<p>最近工作中很多次遇到一种情况，表单元素中某个字段是对象组成的数组，需要使用自定义组件来遍历数组，每个数组元素对象中的许多字段需要单独封装成自定义组件，在父组件中使用<code>v-model</code>方式来实现响应式的调用。这样做的好处是可以利于组件独立运行环境的特性，有效的区分了父组件表单中数组字段下各个对象的独立。<br><a id="more"></a></p><p>假如父组件中的表单数据是这种格式的：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> &#123;</span></span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="actionscript">        id: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        start_time: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        end_time: <span class="string">''</span>,</span></span><br><span class="line">        items: [&#123;</span><br><span class="line"><span class="actionscript">          title: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          desc: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          type: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          img_url: <span class="string">''</span></span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line"><span class="actionscript">          title: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          desc: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          type: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          img_url: <span class="string">''</span></span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>要使用elementUI的 <code>form</code>组件来实现表单的数据渲染，其中items部分最合理的方式是抽离出单独的组件，在父组件中遍历该数组字段，每一项单独渲染该子组件。</p><h2 id="子组件定义"><a href="#子组件定义" class="headerlink" title="子组件定义"></a>子组件定义</h2><p>假设子组件这样定义：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form</span><span class="attr">ref</span>=<span class="string">"item"</span><span class="attr">:model</span>=<span class="string">"content"</span><span class="attr">:rules</span>=<span class="string">"rules"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span><span class="attr">prop</span>=<span class="string">"title"</span><span class="attr">label</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"content.title"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span><span class="attr">prop</span>=<span class="string">"desc"</span><span class="attr">label</span>=<span class="string">"desc"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"content.desc"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span><span class="attr">prop</span>=<span class="string">"type"</span><span class="attr">label</span>=<span class="string">"type"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"content.type"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span><span class="attr">prop</span>=<span class="string">"img_url"</span><span class="attr">label</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"content.img_url"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'Child'</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="actionscript"><span class="keyword">default</span>() &#123;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            title: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            desc: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            type: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            img_url: <span class="string">''</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    index: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="actionscript"><span class="keyword">default</span>: <span class="literal">null</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> &#123;</span></span><br><span class="line">      content: &#123; ...this.value &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line"><span class="actionscript">        title: [&#123;required: <span class="literal">true</span>, trigger: <span class="string">'blur'</span>&#125;],</span></span><br><span class="line"><span class="actionscript">        desc: [&#123;required: <span class="literal">true</span>, trigger: <span class="string">'blur'</span>&#125;],</span></span><br><span class="line"><span class="actionscript">        type: [&#123;required: <span class="literal">true</span>, trigger: <span class="string">'blur'</span>&#125;],</span></span><br><span class="line"><span class="actionscript">        img_url: [&#123;required: <span class="literal">true</span>, trigger: <span class="string">'blur'</span>&#125;],</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line"><span class="actionscript"><span class="comment">// 定义该变量是为了便于监听对象的变化，特别是多层嵌套的对象非常有效</span></span></span><br><span class="line">    contentStr() &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">return</span><span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.content)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line"><span class="actionscript"><span class="comment">// 监听对象每个字段的改变，另一种方法是使用deep属性，具体可以查阅vue文档</span></span></span><br><span class="line">    contentStr(value) &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.update()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update() &#123;</span><br><span class="line"><span class="actionscript"><span class="comment">// input 事件父组件可以监听到，具体下文会介绍，这里是把子组件的变更通过事件告诉父组件，实现子组件向父组件的数据传递</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.content)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    formValidate() &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">let</span> flag = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">this</span>.$refs[<span class="string">'item'</span>].validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span></span><br><span class="line">        flag = valid</span><br><span class="line"><span class="actionscript"><span class="comment">// 如果需要进行信息提示</span></span></span><br><span class="line">        if (!valid) &#123;</span><br><span class="line"><span class="javascript"><span class="keyword">this</span>.$message(<span class="string">`第<span class="subst">$&#123;index&#125;</span>条数据未填写完!`</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> flag</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>自定义组件中props中的value属性是vue默认的，可以接收调用时绑定在<code>v-model</code>上的属性，子组件中给<code>value</code>设置默认值可以避免一些初始化时缺少字段的报错。<br>为了让<code>v-model</code>正常工作，这个组件内必须：</p><ul><li>将其<code>value</code>特性绑定到一个名为<code>value</code>的prop上</li><li>将其<code>input</code>事件触发时，将新的值通过自定义的<code>input</code>事件抛出<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span><span class="attr">v-model</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span><span class="attr">v-bind:value</span>=<span class="string">"title"</span><span class="attr">v-on:input</span>=<span class="string">"title = $event.target.value"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>子组件需要实时的把数据的变化告诉父组件，所以需要wath数据的变化，如果传给子组件的数据只是简单的对象类型，即对象的字段都是简单类型，可以直接使用vue中watch的高级用法，<br>定义handler方法，使用immediaate和deep属性，具体可以参考<a href="https://juejin.im/post/5ae91fa76fb9a07aa7677543" target="_blank" rel="noopener">Vue.js中 watch 的高级用法</a>,更标准的使用方式可以查阅官方文档。在本文例子中可以这样使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    content:&#123;</span><br><span class="line">      handler(newVal, oldVal) &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.content)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      deep: <span class="literal">true</span><span class="comment">// deep属性默认为false, 表示十分深度监听</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>介绍完了子组件中数据的处理，接下来说一下父组件中如何使用。</p><h2 id="父组件调用自定义组件"><a href="#父组件调用自定义组件" class="headerlink" title="父组件调用自定义组件"></a>父组件调用自定义组件</h2><p>前面已经定义了自定义组件，可以支持数据的双向绑定，父组件调用自定义子组件时可以像elementUI中的表单组件一样使用，示例如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form</span><span class="attr">:model</span>=<span class="string">"info"</span><span class="attr">ref</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 为简化类型，这里无关的字段都使用el-input --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span><span class="attr">prop</span>=<span class="string">"start_time"</span><span class="attr">lable</span>=<span class="string">"start time"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"info.start_time"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span><span class="attr">prop</span>=<span class="string">"end_time"</span><span class="attr">lable</span>=<span class="string">"end time"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-input</span><span class="attr">v-model</span>=<span class="string">"info.end_time"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 遍历数组，循环调用自定义子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span><span class="attr">v-for</span>=<span class="string">"(content, index) in info.items"</span><span class="attr">v-show</span>=<span class="string">"(currentIndex - 1) === index"</span><span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span><span class="attr">prop</span>=<span class="string">"item"</span><span class="attr">lable</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">st-item</span><span class="attr">v-model</span>=<span class="string">"info.items[index]"</span><span class="attr">:index</span>=<span class="string">"index"</span><span class="attr">:ref</span>=<span class="string">"index + '_item'"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Item <span class="keyword">from</span><span class="string">'./item.vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'Parents'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line"><span class="actionscript"><span class="string">'st-item'</span>: Item</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      currentIndex: <span class="number">0</span>, <span class="comment">// 控制显示当前的是哪个item</span></span></span><br><span class="line">      info: &#123;</span><br><span class="line"><span class="actionscript">        id: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        start_time: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        end_time: <span class="string">''</span>,</span></span><br><span class="line">        items: [&#123;</span><br><span class="line"><span class="actionscript">          title: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          desc: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          type: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          img_url: <span class="string">''</span></span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line"><span class="actionscript">          title: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          desc: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          type: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          img_url: <span class="string">''</span></span></span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="子组件表单验证"><a href="#子组件表单验证" class="headerlink" title="子组件表单验证"></a>子组件表单验证</h3><p>接下来说如何在父组件提交数据时验证子组件的是否已通过验证。<br>刚才子组件中定义了一个方法 <code>formValidate</code>, 该方法会将子组件的验证结果返回，在父组件中调用该方法即可获得子组件的验证结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  submit() &#123;</span><br><span class="line"><span class="comment">// 调用子组件验证，验证结果赋值给isValid变量</span></span><br><span class="line"><span class="keyword">let</span> isValid = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.info.item).every(<span class="function"><span class="params">key</span> =&gt;</span><span class="keyword">this</span>.$refs[key + <span class="string">'_item'</span>].formValidate())</span><br><span class="line"><span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line"><span class="keyword">return</span><span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考文献： <a href="https://blog.csdn.net/ligang2585116/article/details/79475652" target="_blank" rel="noopener">https://blog.csdn.net/ligang2585116/article/details/79475652</a></p>]]></content><summary type="html">
    
      &lt;p&gt;最近工作中很多次遇到一种情况，表单元素中某个字段是对象组成的数组，需要使用自定义组件来遍历数组，每个数组元素对象中的许多字段需要单独封装成自定义组件，在父组件中使用&lt;code&gt;v-model&lt;/code&gt;方式来实现响应式的调用。这样做的好处是可以利于组件独立运行环境的特性，有效的区分了父组件表单中数组字段下各个对象的独立。&lt;br&gt;
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/><category term="vue" scheme="https://mhynet.cn/tags/vue/"/><category term="element" scheme="https://mhynet.cn/tags/element/"/></entry><entry><title>linux学习笔记(5)</title><link href="https://mhynet.cn/linux-note-5.html"/><id>https://mhynet.cn/linux-note-5.html</id><published>2019-03-14T05:15:31.000Z</published><updated>2020-01-13T04:05:08.198Z</updated><content type="html"><![CDATA[<h2 id="at-一次性定时任务"><a href="#at-一次性定时任务" class="headerlink" title="at 一次性定时任务"></a>at 一次性定时任务</h2><p>at服务是否安装</p><blockquote><p>chkconfig –list | grep atd</p></blockquote><p>at服务重启</p><blockquote><p>service atd restart</p></blockquote><p>at的访问控制</p><blockquote><p>/etc/at.allow 白名单<br>/etc/at.deny 黑名单 （对root不起作用）</p></blockquote><p>白名单比黑名单优先级高。<br>如果这两个文件都不存在，那么只有root用户可以使用at命令<br><a id="more"></a></p><p>at使用方法:</p><blockquote><p>at [选项] 时间</p></blockquote><p>选项：</p><ul><li>-m: 当at工作完成后，无论是否命令有输出，都用email通知执行at命令的用户</li><li>-c：工作号：显示该at工作的实际内容</li></ul><p>时间：<br>HH:MM  03:23<br>HH:MM: YYYY-MM=DD 02:32 2018-09-21<br>…</p><p>eg:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在2分钟后执行脚本hello.sh</span></span><br><span class="line">at now +2 minutes</span><br><span class="line">at &gt; /home/mhy/work/hello.sh &gt;&gt; /home/mhy/work/log_hello.log</span><br></pre></td></tr></table></figure></p><blockquote><p>atq #查询当前服务器上的at工作、</p></blockquote><blockquote><p>atrm [工作号] # 删除指定的at任务</p></blockquote><h2 id="crontab-循环定时任务"><a href="#crontab-循环定时任务" class="headerlink" title="crontab 循环定时任务"></a>crontab 循环定时任务</h2><h3 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h3><ul><li>操作crond服务<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /sbin/service</span></span><br><span class="line">service crond start <span class="comment">#启动服务</span></span><br><span class="line">service crond stop <span class="comment">#关闭服务</span></span><br><span class="line">service crond restart <span class="comment">#重启服务</span></span><br><span class="line">service crond reload <span class="comment">#重新载入配置</span></span><br><span class="line">service crond stats <span class="comment"># 查看crontab服务状态</span></span><br></pre></td></tr></table></figure></li></ul><p>操作crond服务需要root权限</p><ul><li><p>查看crond服务是否在运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list | grep cron</span><br></pre></td></tr></table></figure></li><li><p>加入开机自动启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看crond服务是否已设置为开机启动</span></span><br><span class="line">ntsysv</span><br><span class="line"><span class="comment"># 加入开机自动启动</span></span><br><span class="line">chkconfig --level 35 crond on</span><br></pre></td></tr></table></figure></li></ul><h3 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h3><blockquote><p>crontab [选项] (参数)</p></blockquote><p>选项：</p><ul><li>-e: 编辑当前用户crontab定时任务</li><li>-l: 查询当前用户crontab定时任务</li><li>-r: 删除当前用户所有的crontab定时任务</li><li>-u&lt;用户名&gt;: 指定要设定时任务的用户名称</li></ul><p>参数：</p><ul><li>crontab文件： 指定包含待执行任务的crontab文件</li></ul><p>绑定当前登录用户，要确保没有超出当前用户权限。</p><p>linux下的任务调度分为两类：系统任务调度和用户任务调度。<br><strong>注意</strong>: 因为用户的定时任务是和用户绑定的，所有使用<code>crontab -e</code>来设置，系统定时任务(root权限)是编辑<code>/etc/crontab</code>来设置的， 而且必须指定用户。</p><h3 id="系统任务调度"><a href="#系统任务调度" class="headerlink" title="系统任务调度"></a>系统任务调度</h3><p>系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在<code>/etc</code>目录下有个crontab文件，这个就是系统任务调度的配置文件。<br><code>/etc/crontab</code>默认有以下内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">HOME=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></p><p>eg:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br><span class="line">02 4 * * * root run-parts /etc/cron.daily</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly</span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly</span><br></pre></td></tr></table></figure></p><p>前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。<br>通过/etc/crontab配置文件来设置定时任务是比较好的方式。</p><ul><li>执行系统的定时任务的方法有两种：</li></ul><ol><li>把需要定时执行的脚步复制到<code>/etc/cron.{daily,weekly,montyly}</code>目录的任意一个</li><li>修改<code>/etc/crontab</code>配置文件</li></ol><h3 id="用户任务调度"><a href="#用户任务调度" class="headerlink" title="用户任务调度"></a>用户任务调度</h3><p>用户定期执行的工作，比如数据备份、定时邮件提醒等。 用户可以使用crontab工具来定制自己的计划任务。所有永不定义crontab文件都保存在<code>/var/spool/cron</code>目录中。其文件名与用户名一致，使用者权限文件如下：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/</span>cron.deny 该文件中所有用户不允许使用crontab命令（黑名单）</span><br><span class="line"><span class="regexp">/etc/</span>cron.allow 该文件中所列用户允许使用crontab命令 （白名单）</span><br><span class="line"><span class="regexp">/etc/</span>spool<span class="regexp">/cron/</span> 所有用户crontab文件存放的目录，以用户名命名</span><br></pre></td></tr></table></figure></p><p><strong>白名单比黑名单优先级高</strong>， 白名单的用户一定有权限，黑名单的用户如果在白名单，则有权限；如果黑名单的用户不在白名单，则没有权限。<br>所以只需要把需要限制权限的用户加入到黑名单就可以了，白名单不需要单独添加用户，除了优先级外，有权限的用户一般都比限制权限的用户多，加黑名单比较方便。</p><h3 id="crontab文件的含义"><a href="#crontab文件的含义" class="headerlink" title="crontab文件的含义"></a>crontab文件的含义</h3><p>用户所建立的crontab文件中，每一行都代表一条任务，每行的每个字段代表一项设置，它的格式一共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * [执行的任务]</span><br></pre></td></tr></table></figure></p><p>顺序： <code>miniute hour day month week command</code><br>其中：</p><ul><li>minute:  一小时当中的第几分钟, 范围0-59之间的任意整数</li><li>hour: 一天当中的第几个小时, 范围是0-23之间的任意整数</li><li>day: 一个月当中的第几天, 范围是1-31之间的任意整数</li><li>month: 一年当中的第几个月, 范围是1-12之间的任意整数</li><li>week: 一周当中的星期几, 范围是0-7(0和7都代表星期日)之间的任意整数</li><li>command: 要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</li></ul><p>以上各个字段中， 还可以使用以下特殊字符：</p><ul><li>星号<code>*</code>: 代表所有可能的值，比如minute字段为<code>*</code>代表每分钟执行一次</li><li>逗号<code>,</code>: 逗号隔开的值指定一个列表范围，比如: <code>1,2,3,5,6</code>,列表中的每个时间点执行一次</li><li>中杠<code>-</code>: 可以用整数之间的中杠表示一个整数范围，如：<code>2-5</code>表示<code>2,3,4,5</code></li><li>正斜线<code>/</code>: 正斜线指定时间的间隔频率， 如<code>0-23/2</code>表示每两个小时执行一次，minute字段的<code>*/10</code>表示每十分钟执行一次</li></ul><p><strong>使用以下命令设置定时任务:</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="comment">#进入crontab编辑界面。会打开vim编辑，按刚才的格式设置定时任务</span></span><br></pre></td></tr></table></figure></p><p>crontab定时任务实例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* * * * * <span class="built_in">command</span><span class="comment"># 每一分钟执行一次</span></span><br><span class="line">3,15 * * * * <span class="built_in">command</span><span class="comment"># 每小时内在第3和第5分钟执行</span></span><br><span class="line">3,15 8-11 * * * <span class="built_in">command</span><span class="comment"># 上午8点到11点的第3和第15分钟执行</span></span><br><span class="line">3，15 8-11 */2 * * <span class="built_in">command</span><span class="comment">#每隔两天的上午8点到11点的第3和第5分钟执行</span></span><br><span class="line">3，15 8-11 * * 1 <span class="built_in">command</span><span class="comment">#每个星期一的上午8点到11点的第3和第5分钟执行</span></span><br><span class="line">30 21 * * * service /etc/init.d/smb restart <span class="comment">#每晚的21:30重启smb</span></span><br><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart  <span class="comment">#每月的1、10、22日重启smb</span></span><br><span class="line">30 4 * * 6,7 /etc/init.d/nginx restart <span class="comment">#没周六日的4:30重启nginx</span></span><br><span class="line">0,30 18-23 * * *  /etc/init.d/nginx restart  <span class="comment">#每天18:00至23:00之间每隔30分钟重启nginx, 注意，minute的范围是0-59，每隔30分钟的写法*/30和0,30的区别</span></span><br><span class="line">0 23 * * 6 /etc/init.d/nginx restart <span class="comment">#每周六晚11:00重启nginx</span></span><br><span class="line">0 */1 * * * /etc/init.d/nginx restart <span class="comment">#每一小时重启nginx</span></span><br><span class="line">0 23-7 * * * /etc /init.d/nginx restart <span class="comment">#晚上11点到早上7点之间，每隔一小时重启nginx</span></span><br><span class="line">0 11 4 * 1-3 /etc/init.d/nginx restart <span class="comment">#每月的4号与每周一到周三的11点重启nginx</span></span><br><span class="line">0 * * * * root run-parts /etc/cron.hourly <span class="comment">#每小时执行/etc/cron.hourly目录内的脚本</span></span><br></pre></td></tr></table></figure></p><p>其他命令：</p><blockquote><p>crontab -l # 查询crontab任务</p></blockquote><blockquote><p>crontab -r # 清除当前用户的所有crontab任务</p></blockquote><p>注意事项：</p><ul><li>六个选项都不能为空，必须填写，如果不确定使，用<code>*</code>代替任意时间</li><li>crontab定时任务，最小有效时间是分钟，最大时间范围是月</li><li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为他们都是以天为单位，不利于管理员管理</li><li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都用绝对路径</li></ul><h2 id="anacron配置"><a href="#anacron配置" class="headerlink" title="anacron配置"></a>anacron配置</h2><p>anacron会自动执行因为关机等故障没有执行的定时任务，只会检测<code>/etc/cron.{daily,weekly,montyly}</code>目录，而不会检测<code>crontab -e</code>设置的定时任务</p><h3 id="anacron检测周期"><a href="#anacron检测周期" class="headerlink" title="anacron检测周期"></a>anacron检测周期</h3><ul><li>anacron会使用一天，七天，一个月作为检测周期</li><li>在系统的<code>/var/spool/anacron</code>目录中存在<code>cron.{daily,weekly,montyly}</code>文件，用于记录上次执行crontab的时间</li><li>和当前时间做比较，如果两个时间的差值超过了anacron的指定时间差值，证明有cron任务呗漏执行</li></ul><h4 id="etc-anacrontab配置文件"><a href="#etc-anacrontab配置文件" class="headerlink" title="/etc/anacrontab配置文件"></a><code>/etc/anacrontab</code>配置文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/anacrontab: configuration file for anacron</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See anacron(8) and anacrontab(5) for details.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="comment"># the maximal random delay added to the base delay of the jobs</span></span><br><span class="line">RANDOM_DELAY=45</span><br><span class="line"><span class="comment"># the jobs will be started during the following hours only</span></span><br><span class="line">START_HOURS_RANGE=3-22</span><br><span class="line"></span><br><span class="line"><span class="comment">#period in days   delay in minutes   job-identifier   command</span></span><br><span class="line">1   5   cron.daily      nice run-parts /etc/cron.daily</span><br><span class="line">7   25  cron.weekly     nice run-parts /etc/cron.weekly</span><br><span class="line">@monthly 45 cron.monthly        nice run-parts /etc/cron.monthly</span><br></pre></td></tr></table></figure><h4 id="cron-daily工作执行过程"><a href="#cron-daily工作执行过程" class="headerlink" title="cron.daily工作执行过程"></a>cron.daily工作执行过程</h4><ul><li>首先读取<code>/var/spool/anacron/cron.daily</code>中的上一次anacron执行的时间</li><li>和当前时间做比较，如果两个时间的差值超过一天，就执行cron.daily工作</li><li>执行这个工作只能在03:00-22:00之间</li><li>执行工作时强制延迟时间为5分钟，再随机延迟0-45分钟时间</li><li>使用<code>nice</code>命令指定默认优先级，使用<code>run-parts</code>脚本执行<code>/etc/cron.daily</code>目录中的所有可执行文件</li></ul><h3 id="crontab实例"><a href="#crontab实例" class="headerlink" title="crontab实例"></a>crontab实例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查crond服务是否安装</span></span><br><span class="line">yum list cronie &amp;&amp; systemctl status crond</span><br><span class="line"><span class="comment"># 检查crontab工具是否安装</span></span><br><span class="line">yum list crontabs &amp;&amp; <span class="built_in">which</span> crontab &amp;&amp; crontab -l</span><br></pre></td></tr></table></figure><p><em>systemctl 是类似service的一个命令，可以代替</em></p><ul><li>cron日志<br>cron日志保存在<code>/var/log/cron</code><br>查看日志：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 2 /var/<span class="built_in">log</span>/cron</span><br></pre></td></tr></table></figure></li></ul><p>清理日志系统<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定时任务清理日志</span></span><br><span class="line">/dev/null &gt; /var/<span class="built_in">log</span>/shadowsocks.log</span><br></pre></td></tr></table></figure></p>]]></content><summary type="html">
    
      linux学习之定时任务
    
    </summary><category term="后端" scheme="https://mhynet.cn/categories/%E5%90%8E%E7%AB%AF/"/><category term="linux" scheme="https://mhynet.cn/tags/linux/"/><category term="bash" scheme="https://mhynet.cn/tags/bash/"/><category term="crontab" scheme="https://mhynet.cn/tags/crontab/"/></entry><entry><title>[转载]mongodb常用查询语句</title><link href="https://mhynet.cn/mongodb-searchs.html"/><id>https://mhynet.cn/mongodb-searchs.html</id><published>2019-01-04T03:36:21.000Z</published><updated>2020-01-13T04:05:08.199Z</updated><content type="html"><![CDATA[<p>记录一下MongoDB常用语句，顺带与SQL做个简单的对比。</p><a id="more"></a><p>1、查询(find)</p><p>（1）查询所有结果<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> article</span><br><span class="line">db.article.<span class="builtin-name">find</span>()</span><br></pre></td></tr></table></figure></p><p>（2）指定返回哪些键<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select title, author <span class="keyword">from</span> article</span><br><span class="line">db.article.<span class="builtin-name">find</span>(&#123;&#125;, &#123;<span class="string">"title"</span>: 1, <span class="string">"author"</span>: 1&#125;)</span><br></pre></td></tr></table></figure></p><p>（3）where条件<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title = <span class="string">"mongodb"</span></span><br><span class="line">db.article.find(&#123;<span class="string">"title"</span>: <span class="string">"mongodb"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>（4）and条件<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title = <span class="string">"mongodb"</span> and author = <span class="string">"god"</span></span><br><span class="line">db.article.find(&#123;<span class="string">"title"</span>: <span class="string">"mongodb"</span>, <span class="string">"author"</span>: <span class="string">"god"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>（5）or条件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> article where title = <span class="string">"mongodb"</span><span class="keyword">or</span> author = <span class="string">"god"</span></span><br><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"<span class="variable">$or</span>"</span>: [&#123;<span class="string">"title"</span>: <span class="string">"mongodb"</span>&#125;, &#123;<span class="string">"author"</span>: <span class="string">"god"</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure></p><p>（6）比较条件<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span><span class="keyword">read</span> &gt;= <span class="number">100</span>;</span><br><span class="line">db.article.find(&#123;"read": &#123;"$gt": <span class="number">100</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>$gt(&gt;)、$gte(&gt;=)、$lt(&lt;)、$lte(&lt;=)<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span><span class="keyword">read</span> &gt;= <span class="number">100</span><span class="keyword">and</span><span class="keyword">read</span> &lt;= <span class="number">200</span></span><br><span class="line">db.article.find(&#123;"read": &#123;"$gte": <span class="number">100</span>, "lte": <span class="number">200</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>（7）in条件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> article where author <span class="keyword">in</span> (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"author"</span>: &#123;<span class="string">"<span class="variable">$in</span>"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>（8）like<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title <span class="keyword">like</span> "%mongodb%"</span><br><span class="line">db.article.find(&#123;"title": /mongodb/&#125;)</span><br></pre></td></tr></table></figure></p><p>（9）count<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="built_in">count</span>(*) <span class="keyword">from</span> article</span><br><span class="line">db.article.<span class="built_in">count</span>()</span><br></pre></td></tr></table></figure></p><p>（10）不等于<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> article where author != <span class="string">"a"</span></span><br><span class="line">db.article.<span class="builtin-name">find</span>(&#123; <span class="string">"author"</span>: &#123; <span class="string">"<span class="variable">$ne</span>"</span>: <span class="string">"a"</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>（11）排序<br>升序：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> article where<span class="built_in"> type </span>= <span class="string">"mongodb"</span> order by read desc</span><br><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"type"</span>: <span class="string">"mongodb"</span>&#125;).sort(&#123;<span class="string">"read"</span>: -1&#125;)</span><br></pre></td></tr></table></figure></p><p>降序：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> article where<span class="built_in"> type </span>= <span class="string">"mongodb"</span> order by read asc</span><br><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"type"</span>: <span class="string">"mongodb"</span>&#125;).sort(&#123;<span class="string">"read"</span>: 1&#125;)</span><br></pre></td></tr></table></figure></p><p>findOne()：除了只返回一个查询结果外，使用方法与find()一样。<br>2、创建（insert）<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span><span class="keyword">into</span> article(title, author, content) <span class="keyword">values</span>("mongodb", "tg", "haha")</span><br><span class="line">db.article.<span class="keyword">insert</span>(&#123;"title": "mongodb", "author": "tg", "content": "haha"&#125;)</span><br></pre></td></tr></table></figure></p><p>3、更新（update）</p><p>（1）update()</p><p>语法：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.collecion.<span class="keyword">update</span>(<span class="keyword">query</span>, <span class="keyword">update</span>[, options] )</span><br></pre></td></tr></table></figure></p><p>query : 必选，查询条件，类似find中的查询条件。<br>update : 必选，update的对象和一些更新的操作符（如$,$inc…）等<br>options：可选，一些更新配置的对象。<br>upsert：可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。<br>multi：可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。<br>writeConcern：可选，抛出异常的级别。</p><p>简单更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update article <span class="built_in">set</span> title = <span class="string">"mongodb"</span><span class="built_in">where</span><span class="built_in">read</span> &gt; 100</span><br><span class="line">db.article.update(&#123;<span class="string">"read"</span>: &#123;<span class="string">"<span class="variable">$gt</span>"</span>: 100&#125;&#125;, &#123;<span class="string">"<span class="variable">$set</span>"</span>: &#123; <span class="string">"title"</span>: <span class="string">"mongodb"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>（2）save()<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.article</span><span class="selector-class">.save</span>(&#123;<span class="attribute">_id</span>: <span class="number">123</span>, title: <span class="string">"mongodb"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>执行上面的语句，如果集合中已经存在一个_id为123的文档，则更新对应字段;否则插入。</p><p>注：如果更新对象不存在_id，系统会自动生成并作为新的文档插入。</p><p>（3）更新操作符</p><p>MongoDB提供一些强大的更新操作符。</p><p>更新特定字段（$set）：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> game <span class="built_in">set</span><span class="built_in">count</span> = <span class="number">10000</span><span class="built_in">where</span> _id = <span class="number">123</span></span><br><span class="line">db.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: <span class="number">123</span>&#125;, &#123; <span class="string">"$set"</span>: &#123;<span class="string">"count"</span>: <span class="number">10000</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>删除特定字段（$unset）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>:123&#125;, &#123;<span class="string">"$unset"</span>: &#123;<span class="string">"author"</span>:1&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>注：$unset指定字段的值只需是任意合法值即可。</p><p>递增或递减（$inc）<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123; <span class="string">"$inc"</span>: &#123;<span class="string">"count"</span>: 10&#125;&#125;) <span class="comment">// 每次count都加10</span></span><br></pre></td></tr></table></figure></p><p>注意：$inc对应的字段必须是数字，而且递增或递减的值也必须是数字。</p><p>数组追加（$push）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123; <span class="string">"$push"</span>: &#123;<span class="string">"score"</span>: 123&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>还可以一次追加多个元素：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123;<span class="string">"$push"</span>: &#123;<span class="string">"score"</span>: [12,123]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>注：追加字段必须是数组。如果数组字段不存在，则自动新增，然后追加。</p><p>一次追加多个元素（$pushAll）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123;<span class="string">"$pushAll"</span>: &#123;<span class="string">"score"</span>: [12,123]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>追加不重复元素（$addToSet）：<br>$addToSet类似集合Set，只有当这个值不在元素内时才增加：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123;<span class="string">"$addToSet"</span>: &#123;<span class="string">"score"</span>: 123&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>删除元素（$pop）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123;<span class="string">"$pop"</span>: &#123;<span class="string">"score"</span>: 1&#125;&#125;)  <span class="comment">// 删除最后一个元素</span></span><br><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123;<span class="string">"$pop"</span>: &#123;<span class="string">"score"</span>: -1&#125;&#125;)  <span class="comment">// 删除第一个元素</span></span><br></pre></td></tr></table></figure></p><p>注：$pop每次只能删除数组中的一个元素，1表示删除最后一个，-1表示删除第一个。</p><p>删除特定元素（$pull）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123;<span class="string">"$pull"</span>: &#123;<span class="string">"score"</span>: 123&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>上面的语句表示删除数组score内值等于123的元素。</p><p>删除多个特定元素（$pullAll）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: 123&#125;, &#123;<span class="string">"$pullAll"</span>: &#123;<span class="keyword">score</span>: [123,12]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>上面的语句表示删除数组内值等于123或12的元素。</p><p>更新嵌套数组的值：</p><p>使用数组下标（从0开始）：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  addres<span class="variable">s:</span> [&#123;place: <span class="string">"nanji"</span>, <span class="keyword">te</span><span class="variable">l:</span><span class="number">123</span>&#125;, &#123;place: <span class="string">"dongbei"</span>, <span class="keyword">te</span><span class="variable">l:</span><span class="number">321</span>&#125;]</span><br><span class="line">&#125;</span><br><span class="line">db.game.<span class="keyword">update</span>(&#123;<span class="string">"_id"</span>: <span class="number">123</span>&#125;, &#123;<span class="string">"$set"</span>: &#123;<span class="string">"address.0.tel"</span>: <span class="number">213</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>如果你不知道要更新数组哪项，我们可以使用$操作符（ $表示自身，也就是按查询条件找出的数组里面的项自身，而且只会应用找到的第一条数组项）：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;<span class="string">"address.place"</span>: <span class="string">"nanji"</span>&#125;, &#123;<span class="string">"<span class="variable">$set</span>"</span>: &#123;<span class="string">"address.<span class="variable">$</span>.tel"</span>: <span class="number">123</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>在上面的语句中，$就是查询条件<code>{&quot;address.place&quot;: &quot;nanji&quot;}</code>的查询结果，也就是<code>{place: &quot;nanji&quot;, tel: 123}</code>，所以<code>{&quot;address.$.tel&quot;: 123}</code>也就是<code>{&quot;address.{place: &quot;nanji&quot;, tel: 123}.tel&quot;: 123}</code></p><p>4、删除（remove）<br>删除所有文档：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete <span class="keyword">from</span> article</span><br><span class="line">db.article.<span class="builtin-name">remove</span>()</span><br></pre></td></tr></table></figure></p><p>删除指定文档：<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">delete</span><span class="meta">from</span> article <span class="meta">where</span><span class="meta">title</span> = <span class="string">"mongodb"</span></span><br><span class="line">db.article.<span class="meta">remove</span>(&#123;<span class="meta">title</span>: <span class="string">"mongodb"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>MongoDB特有的语句</p><ol><li>数组查询<br>（1）数组的普通查询<br>假如type是[“mongodb”, “javascript”]：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"type"</span>: <span class="string">"mongodb"</span>&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>上面的语句可以匹配成功。</p><p>（2）多个元素的查询<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"type"</span>: &#123;<span class="string">"<span class="variable">$all</span>"</span>: [<span class="string">"mongodb"</span>, <span class="string">"javascript"</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>只有type数组同时存在mongodb和javascript才会匹配。</p><p>（3）限制数组长度查询<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"type"</span>: &#123;<span class="string">"<span class="variable">$size</span>"</span>: 2&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>只有数组的长度是2才会匹配</p><p>注：type必须是数组</p><p>（4）返回特定数量</p><p>当$slice的参数是一个时，表示返回的数量;当是一个数组时，第一个参数表示偏移量，第二个表示返回的数量：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="built_in">find</span>(&#123;<span class="string">"type"</span>: &#123;<span class="string">"$slice"</span>: <span class="number">1</span>&#125;&#125;) <span class="comment">// 返回第1个</span></span><br><span class="line">db.article.<span class="built_in">find</span>(&#123;<span class="string">"type"</span>: &#123;<span class="string">"$slice"</span>: <span class="number">-1</span>&#125;&#125;)  <span class="comment">// 返回最后一个</span></span><br><span class="line">db.article.<span class="built_in">find</span>(&#123;<span class="string">"type"</span>: &#123;<span class="string">"$slice"</span>: [<span class="number">20</span>, <span class="number">10</span>]&#125;&#125;)  <span class="comment">// 从第21个开始，返回10个，也就是21～30</span></span><br></pre></td></tr></table></figure></p><p>注：$slice针对的是数组</p><p>（5）元素匹配</p><p>如果文档中有一个字段的值是数组，可以使用$elemMatch来匹配数组内的元素：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">kown:</span><span class="string">[&#123;</span><span class="attr">a:</span><span class="number">2</span><span class="string">,</span><span class="attr">b:</span><span class="number">4</span><span class="string">&#125;,</span><span class="number">10</span><span class="string">,</span><span class="string">&#123;</span><span class="attr">a:</span><span class="number">4</span><span class="string">&#125;,</span><span class="string">&#123;b:10&#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">db.article.find(&#123;"kown":</span><span class="string">&#123;</span><span class="string">"$elemMatch"</span><span class="string">:</span><span class="string">&#123;a:</span><span class="number">1</span><span class="string">,</span><span class="attr">b:</span><span class="string">&#123;"$gt":</span><span class="number">2</span><span class="string">&#125;&#125;&#125;&#125;)</span></span><br></pre></td></tr></table></figure></p><p>只有a=1且b&gt;2才会匹配。</p><ol start="2"><li><p>取模（$mod）<br>比如我们要匹配 read % 5 == 1：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"read"</span>: &#123;<span class="variable">$mod</span>: [5, 1]&#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>是否存在（$exists)<br>如果我们要判断love字段是否存在，可以这样：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="built_in">find</span>(&#123;<span class="string">"love"</span>: &#123;<span class="string">"$exists"</span>: <span class="literal">true</span>&#125;&#125;)  <span class="comment">// 如果存在字段love，就返回</span></span><br></pre></td></tr></table></figure></li></ol><p>我们也可以判断不存在：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="built_in">find</span>(&#123;<span class="string">"love"</span>: &#123;<span class="string">"$exists"</span>: <span class="literal">false</span>&#125;&#125;) <span class="comment">// 如果不存在字段love，就返回</span></span><br></pre></td></tr></table></figure></p><ol start="4"><li>正则表达式</li></ol><p>mongodb支持正则表达式，使用方法与正则字面量一样：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="keyword">find</span>(&#123;<span class="string">"title"</span>: <span class="regexp">/mongodb/i</span>&#125;)  <span class="comment">// i是忽略大小写</span></span><br></pre></td></tr></table></figure></p><ol start="5"><li>类型查询<br>我们可以根据字段类型来返回数据：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"comments"</span>: &#123;<span class="string">"<span class="variable">$type</span>"</span>: 4&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>只有当comments的类型是数组才匹配</p><p>注：更多类型的数值可以参考这里：mongodb $type</p><ol start="6"><li>内嵌文档<br>mongodb是允许内嵌文档的，而且要查询内嵌文档也很简单（使用点语法）：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  address: &#123; name: <span class="string">"nanji"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"address.name"</span>: <span class="string">"nanji"</span>&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>上面的语句是查询comments中的author。</p><p>数组也可以采取点语法:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="symbol">  comments:</span> [&#123;<span class="string">title:</span><span class="string">"mongodb"</span>&#125;, &#123;<span class="string">title:</span><span class="string">"javascript"</span>&#125;]</span><br><span class="line">&#125;</span><br><span class="line">db.article.find(&#123;<span class="string">"comments.title"</span>: <span class="string">"mongodb"</span>&#125;)</span><br></pre></td></tr></table></figure></p><ol start="7"><li>取反<br>$not是元语句，即可以用在任何其他条件之上：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.<span class="builtin-name">find</span>(&#123;<span class="string">"author"</span>: &#123;<span class="string">"<span class="variable">$not</span>"</span>: /mongodb/i&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>只要使用$not操作符，就表示取反。</p><p>MongoDB常用方法</p><ol><li>控制返回数量（limit）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.article</span><span class="selector-class">.find</span>()<span class="selector-class">.limit</span>(10)</span><br></pre></td></tr></table></figure></li></ol><p>返回10条数据</p><ol start="2"><li>略过数量<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.article</span><span class="selector-class">.find</span>()<span class="selector-class">.skip</span>(5)</span><br></pre></td></tr></table></figure></li></ol><p>略过前5条数据，也就是从第6条开始返回。</p><p>可以结合limit()和skip()来达到分页效果：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> article limit <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">db.article.find().skip(<span class="number">10</span>).limit(<span class="number">20</span>)</span><br></pre></td></tr></table></figure></p><ol start="3"><li>统计</li></ol><p>返回匹配数据的长度：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.article</span><span class="selector-class">.find</span>()<span class="selector-class">.count</span>()</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>格式化<br>pretty()方法可以以格式化的方式显示所有文档：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.article</span><span class="selector-class">.find</span>()<span class="selector-class">.pretty</span>()</span><br></pre></td></tr></table></figure></li><li><p>删除集合<br>当你要删除一个集合中的所有文档时，直接删除一个集合效率会更高：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.article</span><span class="selector-class">.drop</span>()</span><br></pre></td></tr></table></figure></li></ol><p>原文: <a href="http://ghmagical.com/article/page/id/Bj7qgmJ3CJUE" target="_blank" rel="noopener">http://ghmagical.com/article/page/id/Bj7qgmJ3CJUE</a></p>]]></content><summary type="html">
    
      mongodb常用查询语句汇总
    
    </summary><category term="数据库" scheme="https://mhynet.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/><category term="mongodb" scheme="https://mhynet.cn/tags/mongodb/"/><category term="数据库" scheme="https://mhynet.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/></entry><entry><title>express之request和response对象</title><link href="https://mhynet.cn/express_request_and_response.html"/><id>https://mhynet.cn/express_request_and_response.html</id><published>2018-12-25T13:37:53.000Z</published><updated>2020-01-13T04:05:08.195Z</updated><content type="html"><![CDATA[<p>express是基于Node搭建web应用的框架，使用express可以快速搭建一个网站，express的和核心功能有以下三点：</p><ul><li>可以设置中间件来响应 HTTP 请求。</li><li>定义了路由表用于执行不同的 HTTP 请求动作。</li><li>可以通过向模板传递参数来动态渲染 HTML 页面。</li></ul><a id="more"></a><h2 id="request-和-response-对象的具体介绍："><a href="#request-和-response-对象的具体介绍：" class="headerlink" title="request 和 response 对象的具体介绍："></a>request 和 response 对象的具体介绍：</h2><h3 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h3><ul><li>request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。</li></ul><p>常见属性有：</p><ul><li>req.app：当callback为外部文件时，用req.app访问express的实例</li><li>req.baseUrl：获取路由当前安装的URL路径</li><li>req.body / req.cookies：获得「请求主体」/ Cookies</li><li>req.fresh / req.stale：判断请求是否还「新鲜」</li><li>req.hostname / req.ip：获取主机名和IP地址</li><li>req.originalUrl：获取原始请求URL</li><li>req.params：获取路由的parameters</li><li>req.path：获取请求路径</li><li>req.protocol：获取协议类型</li><li>req.query：获取URL的查询参数串</li><li>req.route：获取当前匹配的路由</li><li>req.subdomains：获取子域名</li><li>req.accepts()：检查可接受的请求的文档类型<br>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第- 一个可接受字符编码</li><li>req.get()：获取指定的HTTP请求头</li><li>req.is()：判断请求头Content-Type的MIME类型</li></ul><h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><ul><li>response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。</li></ul><p>常见属性有：</p><ul><li>res.app：同req.app一样</li><li>res.append()：追加指定HTTP头</li><li>res.set()在res.append()后将重置之前设置的头</li><li>res.cookie(name，value [，option])：设置Cookie</li><li>opition: domain / expires / httpOnly / maxAge / path / secure / signed</li><li>res.clearCookie()：清除Cookie</li><li>res.download()：传送指定路径的文件</li><li>res.get()：返回指定的HTTP头</li><li>res.json()：传送JSON响应</li><li>res.jsonp()：传送JSONP响应</li><li>res.location()：只设置响应的Location HTTP头，不设置状态码或者close response</li><li>res.redirect()：设置响应的Location HTTP头，并且设置状态码302</li><li>res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的- 页面，这样就不会自动输出了。</li><li>res.send()：传送HTTP响应</li><li>res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定- Content-Type</li><li>res.set()：设置HTTP头，传入object可以一次设置多个头</li><li>res.status()：设置HTTP状态码</li><li>res.type()：设置Content-Type的MIME类型</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  主页输出 "Hello World"</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"主页 GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'Hello GET'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  POST 请求</span></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"主页 POST 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'Hello POST'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  /del_user 页面响应</span></span><br><span class="line">app.get(<span class="string">'/del_user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"/del_user 响应 DELETE 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'删除页面'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  /list_user 页面 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/list_user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"/list_user GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'用户列表页面'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/ab*cd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"/ab*cd GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'正则匹配'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> host = server.address().address</span><br><span class="line"><span class="keyword">var</span> port = server.address().port</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。</p><p>你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure></p><p>假设有一张图片/public/images/logo.png，应用添加处理静态文件的功能实例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> host = server.address().address</span><br><span class="line"><span class="keyword">var</span> port = server.address().port</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>用node启动该文件后，在浏览器中访问 <a href="http://127.0.0.1:8081/images/logo.png，" target="_blank" rel="noopener">http://127.0.0.1:8081/images/logo.png，</a> 即可看到/public/images/logo图片</p><p>使用post请求的实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 application/x-www-form-urlencoded 编码解析</span></span><br><span class="line"><span class="keyword">var</span> urlencodedParser = bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/index.htm'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.sendFile( __dirname + <span class="string">"/"</span> + <span class="string">"index.htm"</span> );</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/process_post'</span>, urlencodedParser, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 JSON 格式</span></span><br><span class="line"><span class="keyword">var</span> response = &#123;</span><br><span class="line"><span class="string">"first_name"</span>:req.body.first_name,</span><br><span class="line"><span class="string">"last_name"</span>:req.body.last_name</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(response);</span><br><span class="line">   res.end(<span class="built_in">JSON</span>.stringify(response));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> host = server.address().address</span><br><span class="line"><span class="keyword">var</span> port = server.address().port</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>使用中间件向node服务器发送cookie的实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express_cookie.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express      = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.use(cookieParser())</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cookies: "</span> + util.inspect(req.cookies));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8081</span>)</span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>express是基于node快速搭建网站的框架，底层实现使用了promise + callback的方式，功能全面。但是比较推荐的是koa2，koa2是koa2.0版本之后的称呼，koa1.0版本使用了generator函数实现，2.0使用了async/await函数实现，非常精简，但是功能并不比Express少，express能做的koa都能做，而且做得更好。不同的是，koa把express的部分功能拆分出去了，使用的时候可以根据需求合理引入中间件，比如koa-router。在上一家公司的时候使用过koa1.0多页面的电商网站，前端项目集成了部分node代码实现页面路由和服务的渲染，体验非常棒，也阅读过公司内部使用koa2.0的后台项目，感觉更友好一些。<br>本篇博客大部分内容都是摘自<a href="http://www.runoob.com/nodejs/nodejs-express-framework.html" target="_blank" rel="noopener">runoob</a>，不是原创，算是一篇介绍express的笔记吧。</p>]]></content><summary type="html">
    
      express是基于Nodejs搭建的web应用框架，使用express可以快速搭建一个网站。
    
    </summary><category term="后端" scheme="https://mhynet.cn/categories/%E5%90%8E%E7%AB%AF/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/><category term="node" scheme="https://mhynet.cn/tags/node/"/></entry><entry><title>hexo+github博客多设备同步</title><link href="https://mhynet.cn/hexo-mutl-device-sync.html"/><id>https://mhynet.cn/hexo-mutl-device-sync.html</id><published>2018-10-19T03:25:59.000Z</published><updated>2020-01-13T04:05:08.196Z</updated><content type="html"><![CDATA[<p>为什么hexo博客需要多设备同步呢？</p><p>很多基于hexo的博客的主题都是引用的第三方的主题项目啊，作为一个第三方的项目，导入到自己博客项目的themes目录下之后，作为一个subproject 是无法commit到自己的项目下的，删除原项目的.git文件把整个主题包嵌入自己项目也行，但是也需要尊重一下主题的开发者呀。<br><a id="more"></a></p><p>这样一来，在一个新设备上<code>git pull</code>了自己的项目后还要去<code>git pull</code>主题目录，直接拉下来的主题包的配置文件<code>_config.yml</code>文件一般都需要修改下吧，如果有google、百度统计相关的代码需要添加到主题中的相关文件中的，就需要改下原来的主题文件了，这些改的第一次改动之后，下一次你还记得怎么改不? 不记得啦！那只好在相关文件里面记录下来，下次直接参考该记录来重新配置下吧，手动配置感觉很麻烦，那就写一个shell脚本，下次直接执行以下该脚本就自动配置好啦！</p><p>这里贴一下我的自动化配置shell脚本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">localRepo=<span class="string">"<span class="variable">$HOME</span>/hexo-theme-BlueLake"</span></span><br><span class="line">floader=<span class="string">"themes/BlueLake"</span></span><br><span class="line">subGitFloader=<span class="string">"themes/BlueLake/.git"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$localRepo</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span><span class="string">"1. local BlueLake theme repostory not exist and start clone from remote......"</span></span><br><span class="line"><span class="built_in">echo</span> $( git <span class="built_in">clone</span> git@github.com:chaooo/hexo-theme-BlueLake.git &amp;&amp; mv <span class="string">"hexo-theme-BlueLake"</span><span class="string">"<span class="variable">$HOME</span>/"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span><span class="string">"1. local BlueLake theme repostory exist!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$floader</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">     rm -rf <span class="string">"<span class="variable">$floader</span>"</span> &amp;&amp; <span class="built_in">echo</span><span class="string">"2.remove themes/BlueLake success!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">cp -Rf <span class="string">"<span class="variable">$HOME</span>/hexo-theme-BlueLake"</span><span class="string">"themes/BlueLake"</span> &amp;&amp; <span class="built_in">echo</span><span class="string">"3. copy thems successed!"</span> || <span class="built_in">echo</span><span class="string">"3. copy thems failed!"</span></span><br><span class="line"></span><br><span class="line">cat <span class="string">"source/_data/BlueLake_theme_config.yml"</span> &gt; <span class="string">"<span class="variable">$floader</span>/_config.yml"</span> &amp;&amp; <span class="built_in">echo</span><span class="string">"4. move _config.yml successed!"</span></span><br><span class="line"></span><br><span class="line">cat <span class="string">"source/_data/baidu_config_script.jade"</span> &gt;&gt; <span class="string">"themes/BlueLake/layout/_partial/after_footer.jade"</span> &amp;&amp; <span class="built_in">echo</span><span class="string">"5. add baidu_config_script success!"</span> || <span class="built_in">echo</span><span class="string">"5. add baidu_config_script failed!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$subGitFloader</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> $( rm -rf <span class="variable">$&#123;subGitFloader&#125;</span> ) &amp;&amp; <span class="built_in">echo</span><span class="string">"6.remove <span class="variable">$&#123;subGitFloader&#125;</span> succsssful!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>自从写好这段脚本后再也不用担心更换新设备后重新部署hexo博客的问题啦。</p><p>为什么需要经常部署博客呢？我爱折腾啊，电脑经常换系统啊，虚拟机ubuntu，Windows，Mac OS X双系统，近一年来重装了好多次系统啊，每次都重新部署开发环境好麻烦，而且换工作之后也会更换电脑啊。</p><p>如果担心主题开发者后续更新了主题导致在新设备上部署时环境不一致，可以把原主题fork到自己的github，然后把仓库URL改成fork过来的URL即可。</p><blockquote><p>注：后续补充，现在我已不再使用以上方案同步博客配置，百度站长和google站长验证使用 html 标签验证方式，相应的识别码已写入配置文件，而且可以把主题中的部分配置项配置到项目的配置下。主题同步采用了 git modules，把原作者的主题fork到自己的github，然后自己维护主题仓库，这样可以在原主题的基础上进行功能和样式的调整和优化。</p></blockquote>]]></content><summary type="html">
    
      多台设备共用同一套配置，换设备快速部署hexo博客开发环境
    
    </summary><category term="博客" scheme="https://mhynet.cn/categories/%E5%8D%9A%E5%AE%A2/"/><category term="hexo" scheme="https://mhynet.cn/tags/hexo/"/><category term="github" scheme="https://mhynet.cn/tags/github/"/><category term="github pages" scheme="https://mhynet.cn/tags/github-pages/"/><category term="博客" scheme="https://mhynet.cn/tags/%E5%8D%9A%E5%AE%A2/"/></entry><entry><title>linux学习笔记(4)</title><link href="https://mhynet.cn/linux-note-4.html"/><id>https://mhynet.cn/linux-note-4.html</id><published>2018-09-22T10:15:31.000Z</published><updated>2020-01-15T07:22:07.428Z</updated><content type="html"><![CDATA[<p>这里记录下linux系统下用户和用户组的管理方面的学习笔记。<br><a id="more"></a><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">用户: 使用操作系统的人</span></span><br><span class="line"><span class="section">用户组: 具有相同系统权限的一组用户</span></span><br></pre></td></tr></table></figure></p><p><code>/etc/group</code> 存储当前系统中所有用户组信息</p><p>格式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">group</span><span class="selector-pseudo">:x</span><span class="selector-pseudo">:123</span><span class="selector-pseudo">:ABC</span>,<span class="selector-tag">def</span>,<span class="selector-tag">xyz</span></span><br><span class="line">组名称:组密码占位符:组编号:组中用户列表</span><br></pre></td></tr></table></figure></p><p>组只有一个用户，用户组合和用户名相同，用户组列表为空,<br>root用户组的组号为0,<br>编号1~499全部是分配给系统的，越早安装的应用组编号越靠前,<br>个人用户编号从500开始计数,<br>组密码占位符全部都是x</p><p><code>/etc/gshadow</code> 存储当前系统中用户组的密码信息<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">group:*: :abc</span></span><br><span class="line"><span class="section">组名称:组密码:组管理者:组中用户列表</span></span><br></pre></td></tr></table></figure></p><p>组密码为*或!或空表示没有组密码</p><p><code>/etc/paswd</code> 存储当前系统所有用户的信息。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user:x:123:456:xxxx:/home/user:/bin/bash</span><br><span class="line">用户名:密码占位符:用户编号:用户组编号:用户注释信息:用户主目录:shell类型</span><br></pre></td></tr></table></figure></p><p><code>/etc/shadow</code> 存储当前系统中所有用户的密码信息。<br><br>用户和用户组的密码保存在单独的文件/etc/gshadow 和/etc/shadow中， 需要的权限要比保存用户和用户组的文件高很多</p><p>管理用户组的命令：</p><ul><li>添加用户组：<br><code>groupadd [用户组名]</code></li><li>修改用户组名：<br><code>groupmod -n [newGroupName] [oldGroupName]</code></li><li>修改用户组编号：<br><code>groupmid -g 666 [groupName]</code></li><li>创建用户组的时候指定编号：<br><code>groupadd -g 888 [groupName]</code></li><li><p>删除用户组(删除用户组之前必须先清空组内用户， 否则这些用户的组信息丢失， 有权限方面的影响)：<br><code>groupdel [groupName]</code></p></li><li><p>组内添加用户(用户目录默认在/home下，默认创建一个和用户名相同的用户组)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd userName</span><br><span class="line">useradd -g groupName -d /home/userName userName</span><br></pre></td></tr></table></figure></li><li><p>给用户添加备注：<br><code>useradd -c 备注内容 userName</code></p></li><li>改用户名：<br><code>usermod -l 新用户名 旧用户名</code></li><li>指定新的用户文件夹：<br><code>usermod -d /home/mhy mhy</code></li><li>修改所属用户组：<br><code>usermod -g 组名 用户名</code></li><li>删除账号：<br><code>userdel 用户名</code></li><li>删除的同时删除用户目录:<br><code>userdel -r 用户名</code></li><li><p>禁止root以外的用户登录服务器（空文件就可以）：<br><code>touch /etc/nologin</code></p></li><li><p>锁定用户账户：<br><code>passwd -l 用户名</code></p></li><li>解锁用户<br><code>passwd -u 用户名</code></li><li>清除用户的密码，无密码登录：<br><code>passwd -d 用户名</code></li></ul><h3 id="主要组和附属组："><a href="#主要组和附属组：" class="headerlink" title="主要组和附属组："></a>主要组和附属组：</h3><p>一个用户可以属于多个组，一个主要组，若干个个附属组, 添加多个，用逗号连接多个附属组名:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -a 用户名  附属组名</span><br></pre></td></tr></table></figure></p><ul><li>创建用户时指定主要组和附属组：<br>`useradd -g 主要组 -G 附属组1,负数组2  用户名</li><li><p>用户组设置密码：<br><code>gpasswd 用户组名</code></p></li><li><p>切换用户身份:<br><code>su 用户名</code></p></li><li><p>我是谁:<br><code>whoami</code></p></li><li>用户信息：<br><code>id 用户名</code></li><li>所属组：<br><code>groups 用户名</code></li></ul>]]></content><summary type="html">
    
      linux学习笔记之用户和用户组管理。
    
    </summary><category term="后端" scheme="https://mhynet.cn/categories/%E5%90%8E%E7%AB%AF/"/><category term="linux" scheme="https://mhynet.cn/tags/linux/"/><category term="bash" scheme="https://mhynet.cn/tags/bash/"/></entry><entry><title>linux学习笔记(3)</title><link href="https://mhynet.cn/linux-note-3.html"/><id>https://mhynet.cn/linux-note-3.html</id><published>2018-09-11T10:12:07.000Z</published><updated>2020-01-15T07:22:03.946Z</updated><content type="html"><![CDATA[<p>linux中常用的命令使用笔记。</p><h2 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h2><blockquote><p>echo [选项] [输出内容]</p></blockquote><p>选项：</p><ul><li>-e 支持反斜杠控制的字符转换</li></ul><a id="more"></a><table><thead><tr><th>控制字符</th><th>作用</th></tr></thead><tbody><tr><td>\a</td><td>输出警告音</td></tr><tr><td>\b</td><td>退格键，即左删除键</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车键</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\0n</td><td>nn 按八进制ASCII码表输出字符，其中0是数字零，nnn是三位八进制数</td></tr><tr><td>\xh</td><td>h 按照十六进制ASCII码表输出z福。其中hh是两位十六进制数</td></tr></tbody></table><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>eg:<br><code>alias la=&quot;ls -la&quot;</code><br>查看系统中的别名：<br><code>alias</code><br>1.临时设置别名：</p><p>命令行输入 <code>alias la=&quot;ls -al --color=auto&quot;</code></p><p>2.永久设置：</p><p>写入环境变量配置文件:<br><code>~/.bashrc</code></p><p>3.删除别名：<br>临时删除可以直接输入: <code>unalias la</code>,<br>永久删除需要修改配置文件</p><ul><li><p>命令生效顺序</p><ol><li>第一顺位执行用绝对路径活泼相对路径执行的命令</li><li>第二顺位执行别名</li><li>第三执行bash的内部命令</li><li>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令</li></ol></li><li><p>命令快捷键</p></li></ul><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>ctrl + c</td><td>强行终止</td></tr><tr><td>cmd  + l</td><td>清屏(清除一行)</td></tr><tr><td>ctrl + l</td><td>清屏(屏幕中所有行), 效果同clear</td></tr><tr><td>ctrl + a</td><td>光标移动到命令行行首</td></tr><tr><td>ctrl + e</td><td>光标移动到命令行行尾</td></tr><tr><td>ctrl + u</td><td>从光标位置删除到行首</td></tr><tr><td>ctrl + z</td><td>把命令放入后台(命令无法使用ctrl + c z终止的时候使用，不建议 )</td></tr><tr><td>ctrl + r</td><td>在历史命令中搜索</td></tr><tr><td>ctrl + 左右方向键</td><td>按单词左右移动光标</td></tr></tbody></table><h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><p>上下箭头读取历史命令</p><ul><li>读取所有历史命令</li></ul><p><code>history [选项] [历史命令保存文件]</code></p><p>选项：</p><ul><li>-c 清空历史命令</li><li>-w 把缓存中的历史命令写入历史命令保存文件 <code>~/.bash_history</code></li></ul><p>注意: history命令中的命令包括文件保存的和当前登录输入的所有命令， 文件只会在登出的时候才会主动保存到文件，但是可以通过<code>-w</code>选项把当前登录后的历史命令手动保存在文件中</p><p>历史命令默认保存1000条，可以在<code>/etc/profile</code>中的<code>HISTSIZE=1000</code>字段中设置</p><ol><li><em>使用<code>!n</code>重复执行第n条历史命令</em></li><li><em>使用<code>!字串</code>重复执行最后一条以该字串开头的命令</em></li><li>使用<code>!!</code>重复执行上一条命令</li></ol><ul><li>命令和文件补全</li></ul><p>在bash中，按tab键自动补全命令、文件路径， 对提高输入速度和排错非常有用</p><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标准的输入输出设备:</span><br><span class="line">键盘    /dev.stdin  <span class="number">0</span> 标准输入</span><br><span class="line">显示器  /dev/sdtout <span class="number">1</span> 标准输出</span><br><span class="line">显示器  /dev/sdterr <span class="number">2</span> 标准错误输出</span><br></pre></td></tr></table></figure><h3 id="标准输出重定向："><a href="#标准输出重定向：" class="headerlink" title="标准输出重定向："></a>标准输出重定向：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 文件 ： 以覆盖方式，把命令的正确输出输出到指定文件或设备中</span><br><span class="line">命令 &gt;&gt; 文件 ： 以追加的方式，把命令的正确输出输出到指定文件或设备中</span><br></pre></td></tr></table></figure><p><strong>文件不存在， 先创建后写入， <code>&gt;</code>覆盖 <code>&gt;&gt;</code>追加</strong></p><h3 id="命令的错误输出："><a href="#命令的错误输出：" class="headerlink" title="命令的错误输出："></a>命令的错误输出：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误命令 <span class="number">2</span>&gt; 文件 ： 以覆盖方式，把命令的错误输出输出到指定文件或设备中</span><br><span class="line">错误命令 <span class="number">2</span>&gt;&gt; 文件 ： 以追加的方式，把命令的错误输出输出到指定文件或设备中</span><br></pre></td></tr></table></figure><p><em>注意：正确输出大于号左右有空格，错误输出左右没有空格</em></p><h3 id="正确和错误输出同时保存："><a href="#正确和错误输出同时保存：" class="headerlink" title="正确和错误输出同时保存："></a>正确和错误输出同时保存：</h3><ul><li>以<em>覆盖</em>方式，把正确输出和错误输出都保存到同一个文件中：</li></ul><ol><li>命令 &amp;&gt;文件</li><li>命令 &gt; 文件 2&gt;&amp;1</li></ol><p>eg: <code>./test.sh &gt;&gt; common.log 2&gt;&amp;1</code></p><ul><li>以<em>追加</em>方式，把正确输出和错误输出都保存到同一个文件中：</li></ul><ol><li>命令 &amp;&gt;&gt;文件</li><li>命令 &gt;&gt; 文件 2&gt;&amp;1</li></ol><p>eg: <code>./test.sh &gt;&gt; common.log 2&gt;&amp;1</code></p><ul><li><em>把正确输出追加到文件1， 把错误输出追加到文件2</em>：</li></ul><ol><li>命令 &gt;&gt; 文件一 2&gt;&gt; 文件二</li></ol><p>eg: <code>./test.sh &gt;&gt; success.log 2&gt;&gt; error.log</code></p><p><strong>注意上面命令中的空格，在错误输出中<code>2&gt;</code>或者<code>2&gt;&gt;</code>之间没有空格， <code>1&gt;</code> 等同于 <code>&gt;</code>，<code>1</code>省略不写</strong><br>一般都是以追加的方式写入日志文件<br>最常用的命令：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`命令&gt;&gt;文件一 <span class="number">2</span>&gt;&gt;文件二`</span><br><span class="line">`命令 &amp;&gt;&gt; 文件`</span><br></pre></td></tr></table></figure></p><p><code>/dev/null</code>目录文件写入后丢弃，用于一些不需要过程只需要结果的命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 和 <span class="number">1</span>&gt; 相同, 标准输出重定向</span><br><span class="line"><span class="number">2</span>&gt;&amp;<span class="number">1</span> 标标准错误输出 重定向到 标准输出</span><br><span class="line">&amp;&gt; file 把标准输出和错误输出都重定向到文件file中</span><br></pre></td></tr></table></figure><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p><code>wc [选项] [文件名]</code></p><p>选项：</p><ul><li>-c 统计字节数</li><li>-w 统计单词数</li><li>-l 统计行数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 把文件作为命令的输入</span><br><span class="line">命令 &lt;&lt; 标识符</span><br></pre></td></tr></table></figure></li></ul><p>标识符把标识符之间的内容作为命令的输入<br>eg:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc &lt; acc.<span class="built_in">log</span><span class="meta"># 统计文件的输入</span></span><br><span class="line">&lt;&lt;很少用</span><br></pre></td></tr></table></figure></p><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h2><h3 id="多命令顺序执行："><a href="#多命令顺序执行：" class="headerlink" title="多命令顺序执行："></a>多命令顺序执行：</h3><table><thead><tr><th>多命令执行符</th><th>格式</th><th>作用</th></tr></thead><tbody><tr><td>;</td><td>命令1; 命令2</td><td>多个命令顺序执行，之间没有任何逻辑关系</td></tr><tr><td>&amp;&amp;</td><td>命令1 &amp;&amp; 命令2</td><td>逻辑与， 当命令1正确执行，则命令2才会执行，否则命令2不执行</td></tr><tr><td></td><td></td><td></td><td>命令1</td><td></td><td>命令2</td><td>逻辑或， 当命令1执行不正确，才会执行命令2，否则命令2不会执行</td></tr></tbody></table><p>判断命令是否正确执行:</p><p><code>./test.sh &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</code></p><h3 id="管道符-1"><a href="#管道符-1" class="headerlink" title="管道符"></a>管道符</h3><p>格式：</p><p><code>命令1 | 命令2</code></p><p>命令1的正确输出作为命令2的操作对象<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep ESTABLISHED</span><br></pre></td></tr></table></figure></p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table><thead><tr><th>通配符</th><th>作用</th></tr></thead><tbody><tr><td>？ </td><td>匹配一个任意字符</td></tr><tr><td>*</td><td>匹配0个或任意多个字符</td></tr><tr><td>[]</td><td>匹配中括号中任意一个字符</td></tr><tr><td>[-]</td><td>匹配中括号中任意一个字符， - 代表范围</td></tr><tr><td>[^]</td><td>逻辑非， 匹配不上中括号内的一个字符</td></tr></tbody></table><p><em>通配符用于匹配文件名或目录名</em></p><h3 id="bash中其他特殊符号"><a href="#bash中其他特殊符号" class="headerlink" title="bash中其他特殊符号"></a>bash中其他特殊符号</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span></span><br><span class="line"><span class="string">""</span></span><br><span class="line"><span class="string">``</span> : 反引号，反引号括起来的是系统命令，在bash中会先执行它，和$()作用一样</span><br><span class="line">$() : 作用同反引号, 执行系统命令，然后获取到执行结果</span><br><span class="line">$ : 调用变量的值</span><br><span class="line">\ : 转义符</span><br><span class="line"><span class="comment">#  :注释</span></span><br></pre></td></tr></table></figure>]]></content><summary type="html">
    
      linux学习笔记之常用命令。
    
    </summary><category term="后端" scheme="https://mhynet.cn/categories/%E5%90%8E%E7%AB%AF/"/><category term="linux" scheme="https://mhynet.cn/tags/linux/"/><category term="bash" scheme="https://mhynet.cn/tags/bash/"/></entry><entry><title>linux学习笔记(2)</title><link href="https://mhynet.cn/linux-note-2.html"/><id>https://mhynet.cn/linux-note-2.html</id><published>2018-08-20T05:26:13.000Z</published><updated>2020-01-15T07:22:00.596Z</updated><content type="html"><![CDATA[<h3 id="1-shell-脚本"><a href="#1-shell-脚本" class="headerlink" title="1.shell 脚本"></a>1.shell 脚本</h3><p>脚本语言是用来让计算机自动化执行完成一系列工作的程序，不需要编译，通常是通过解释器运行的。</p><a id="more"></a><h3 id="2-shell环境"><a href="#2-shell环境" class="headerlink" title="2.shell环境"></a>2.shell环境</h3><p>shell文件的第一行的”#!”是一个约定的标记，告诉系统其后路径所指定的程序即是解释此脚本的shell程<br>linux的shell种类常见的有：</p><ul><li>Bourne Ageng Shell(/bin/bash)</li><li>Bourne Shell(/usr/bin/sh 或/bin/sh)</li><li>“C Shell” (/usr/bin/csh)</li><li>Shell for Root(/sbin/sh)</li></ul><h3 id="3-运行shell脚本"><a href="#3-运行shell脚本" class="headerlink" title="3.运行shell脚本"></a>3.运行shell脚本</h3><p>创建一个shell脚本文件,保存为test.sh<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span><span class="string">"hello"</span><span class="comment">#echo命令用于向窗口输出文本</span></span><br></pre></td></tr></table></figure></p><ol><li>作为可执行文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./text.sh  <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">./test.sh <span class="comment">#执行脚本</span></span><br></pre></td></tr></table></figure></li></ol><p>执行脚本必须指定路径，可以用绝对路径或者相对路径，不指定路径会从PATH里面找。</p><ol start="2"><li>作为解释器参数</li></ol><p>直接运行解释器，其参数为shell脚本的文件名<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure></p><p>这种方式运行脚本，第一行不需要指定解释器信息，写了也不起作用</p><h3 id="4-shell变量"><a href="#4-shell变量" class="headerlink" title="4.shell变量"></a>4.shell变量</h3><h4 id="4-1-变量定义"><a href="#4-1-变量定义" class="headerlink" title="4.1 变量定义"></a>4.1 变量定义</h4><p>变量名和等号之间不能有空格，shell变量定义的规定：</p><ul><li>变量命名只能使用英文字母，数字和下划线，首字符不能以数字开头</li><li>中间不能有空格，可以使用下划线</li><li>不能使用标点符号</li><li>不能使用bash里的关键字</li></ul><p>有效的变量示例如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Room</span><br><span class="line">L_YARM</span><br><span class="line">_var</span><br><span class="line">var2</span><br></pre></td></tr></table></figure></p><p>无效的变量名：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?var=123</span><br><span class="line">user*name=runoob</span><br></pre></td></tr></table></figure></p><p>变量赋值可以显式的直接赋值也可以用语句来赋值：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Room=222</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls /etc`</span><br></pre></td></tr></table></figure></p><h4 id="4-2-变量的使用"><a href="#4-2-变量的使用" class="headerlink" title="4.2 变量的使用"></a>4.2 变量的使用</h4><p>使用一个定义过的变量，只需要在变量前面加上美元符号即可<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">'mhy'</span></span><br><span class="line"><span class="built_in">echo</span><span class="variable">$your_name</span></span><br><span class="line"><span class="built_in">echo</span><span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure></p><p>变量名外面的花括号可选，加花括号是为了帮助解释器识别变量的边界<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java; <span class="keyword">do</span></span><br><span class="line">2<span class="built_in">echo</span><span class="string">"I am good at <span class="variable">$&#123;skill&#125;</span>Script"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>推荐给所有变量加上$</p><p>已定义的变量可以重新被定义<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"tom"</span></span><br><span class="line"><span class="built_in">echo</span><span class="variable">$&#123;your_name&#125;</span></span><br><span class="line">your_name=<span class="string">"lily"</span></span><br><span class="line"><span class="built_in">echo</span><span class="variable">$&#123;your_name&#125;</span></span><br></pre></td></tr></table></figure></p><p>但是变量定义的时候不能加$符号。</p><h4 id="4-3-只读变量"><a href="#4-3-只读变量" class="headerlink" title="4.3 只读变量"></a>4.3 只读变量</h4><p>使用readonly命令可以将变量定义为只读变量，修改只读变量会报错<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!bin/bash</span></span><br><span class="line">girl_friend=<span class="string">"lily"</span></span><br><span class="line"><span class="built_in">readonly</span> girl_fiend</span><br><span class="line">gir_friend=<span class="string">"leilei"</span></span><br></pre></td></tr></table></figure></p><p>运行脚本报错了.</p><h4 id="4-4-删除变量"><a href="#4-4-删除变量" class="headerlink" title="4.4 删除变量"></a>4.4 删除变量</h4><p>使用unset 命令删除变量<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">girl_friend=<span class="string">"xiao mei"</span></span><br><span class="line"><span class="built_in">unset</span> girl_friend</span><br></pre></td></tr></table></figure></p><p><strong>unset 命令不能删除只读变量</strong></p><h4 id="4-5-变量类型"><a href="#4-5-变量类型" class="headerlink" title="4.5 变量类型"></a>4.5 变量类型</h4><p>shell脚本语言存在三种变量：</p><ul><li>局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效</li><li>环境变量 所有的程序包括shell启动的程序，都能访问环境变量，必要时shell脚本也能定义环境变量</li><li>shell变量 shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h3 id="5-shell字符串"><a href="#5-shell字符串" class="headerlink" title="5.shell字符串"></a>5.shell字符串</h3><p>字符串是shell编程中最常用最有效的数据类型。<br>字符串可以用单引号或双引号或不用引号。</p><h4 id="5-1-单引号"><a href="#5-1-单引号" class="headerlink" title="5.1 单引号"></a>5.1 单引号</h4><p>单引号字符串的限制：</p><ul><li>单引号里任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字符串中不能出现单引号（对单引号使用转义符后也不行）<h4 id="5-2-双引号"><a href="#5-2-双引号" class="headerlink" title="5.2 双引号"></a>5.2 双引号</h4></li></ul><p>双引号的有点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h4 id="5-3-拼接字符串"><a href="#5-3-拼接字符串" class="headerlink" title="5.3 拼接字符串"></a>5.3 拼接字符串</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=<span class="string">"mhy"</span></span><br><span class="line">greeting=<span class="string">"hello"</span>, <span class="string">"<span class="variable">$your_name</span>"</span>!<span class="string">"</span></span><br><span class="line"><span class="string">greeting_1="</span>hello, <span class="variable">$&#123;your_name&#125;</span>!<span class="string">"</span></span><br><span class="line"><span class="string">echo <span class="variable">$greeting</span><span class="variable">$greeting_1</span></span></span><br></pre></td></tr></table></figure><h4 id="5-4-获取字符串长度"><a href="#5-4-获取字符串长度" class="headerlink" title="5.4 获取字符串长度"></a>5.4 获取字符串长度</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># string="beijing"</span></span><br><span class="line"><span class="comment"># echo $&#123;#string&#125; #输出 7</span></span><br></pre></td></tr></table></figure><h4 id="5-5-提取字符串"><a href="#5-5-提取字符串" class="headerlink" title="5.5 提取字符串"></a>5.5 提取字符串</h4><p>以下实例从字符串第2个字符开始截取4个字符<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"hello beijing!"</span></span><br><span class="line"><span class="built_in">echo</span><span class="variable">$&#123;string:1:4&#125;</span><span class="comment">#输出 trin</span></span><br></pre></td></tr></table></figure></p><h4 id="5-6-查找子字符串"><a href="#5-6-查找子字符串" class="headerlink" title="5.6 查找子字符串"></a>5.6 查找子字符串</h4><p>查找子字符串的位置<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"wellcome to beijing, shaonian"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$string</span>"</span> is` <span class="comment"># 输出</span></span><br></pre></td></tr></table></figure></p><h4 id="5-7-判断读取字符串值"><a href="#5-7-判断读取字符串值" class="headerlink" title="5.7 判断读取字符串值"></a>5.7 判断读取字符串值</h4><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>${var}</td><td>定义var的值，与$var相同</td></tr><tr><td></td><td></td></tr><tr><td>$(var-DEFAULT}</td><td>如果var没有被声明，那么就以$DEFAULT作为其值</td></tr><tr><td>${var:-DEFAULT}</td><td>如果var没有被声明，或者其值为空，那么就以$DEFAULT作为其值</td></tr><tr><td></td><td></td></tr><tr><td>${var=DEFAULT}</td><td>如果var没有被声明，那么就以$DEFAULT作为其值</td></tr><tr><td>${var:=DEFAULT</td><td>如果var没有被声明，或者其值为空，那么就以$DEFAULT作为其值</td></tr><tr><td></td><td></td></tr><tr><td>${var+OTHER}</td><td>如果var声明了，那么其值就是$OTHER,否则就为null字符串</td></tr><tr><td>${var:+OTHER}</td><td>如果var被设置了，那么其值就是$OTHER，否则就为null字符串</td></tr></tbody></table><h4 id="5-8-字符串操作汇总"><a href="#5-8-字符串操作汇总" class="headerlink" title="5.8 字符串操作汇总"></a>5.8 字符串操作汇总</h4><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>${string:position</td><td>在$string中, 从位置$position开始提取子串</td></tr><tr><td>${string:position:length</td><td>在$string中, 从位置$position开始提取长度为$length的子串</td></tr><tr><td></td><td></td></tr><tr><td>${string#substring</td><td>从变量$string的开头, 删除最短匹配$substring的子串</td></tr><tr><td>${string##substring</td><td>从变量$string的开头, 删除最长匹配$substring的子串</td></tr><tr><td>${string%substring</td><td>从变量$string的结尾, 删除最短匹配$substring的子串</td></tr><tr><td>${string%%substring</td><td>从变量$string的结尾, 删除最长匹配$substring的子串</td></tr><tr><td></td><td></td></tr><tr><td>${string/substring/replacement</td><td>使用$replacement, 来代替第一个匹配的$substring</td></tr><tr><td>${string//substring/replacement</td><td>使用$replacement, 代替所有匹配的$substring</td></tr><tr><td>${string/#substring/replacement</td><td>如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr><tr><td>${string/%substring/replacement</td><td>如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</td></tr></tbody></table><h3 id="6-shell数组"><a href="#6-shell数组" class="headerlink" title="6.shell数组"></a>6.shell数组</h3><p>bash支持一维数组不支持多维数组，没有限定数组的大小<br>数组下标从0开始编号，下便可以是整数或算数表达式，其值应该大于或等于0。</p><h4 id="6-1-定义数组"><a href="#6-1-定义数组" class="headerlink" title="6.1 定义数组"></a>6.1 定义数组</h4><p>在shell中用括号来表示数组，元素用空格符号隔开：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 值3 ... 值n)</span><br></pre></td></tr></table></figure></p><p>eg：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">  value0</span><br><span class="line">  value1</span><br><span class="line">  value2</span><br><span class="line">  value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>还可以单独定义数组的各个分量：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[100]=value100</span><br></pre></td></tr></table></figure></p><p>可以不使用连续的下标，而且下标的范围没有限制。</p><h4 id="6-2-数组的操作"><a href="#6-2-数组的操作" class="headerlink" title="6.2 数组的操作"></a>6.2 数组的操作</h4><ul><li>读取数组</li></ul><p>读取数组的语法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(array_name[index])</span><br></pre></td></tr></table></figure></p><p>使用@符号可以获取数组中所有元素：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(array_name[@])</span><br></pre></td></tr></table></figure></p><ul><li>获取数组的长度</li></ul><p>获取数组的长度的方法与获取字符串长度的方法相同。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数组元素的个数</span></span><br><span class="line">length=$(<span class="comment">#array_name[@])</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=$(<span class="comment">#array_name[*])</span></span><br><span class="line"><span class="comment"># 获取数组单个元素的长度</span></span><br><span class="line">lengthn=$(<span class="comment">#array_name[n])</span></span><br></pre></td></tr></table></figure></p><h3 id="7-注释"><a href="#7-注释" class="headerlink" title="7 注释"></a>7 注释</h3><p>shell中只有单行注释， 在每一行的开头加入#即可</p><p>多行代码可以用花括号括起来定义成一个函数，不调用它这块代码不会执行，和多行注释的效果一样</p>]]></content><summary type="html">
    
      linux学习笔记之shell编程
    
    </summary><category term="后端" scheme="https://mhynet.cn/categories/%E5%90%8E%E7%AB%AF/"/><category term="linux" scheme="https://mhynet.cn/tags/linux/"/><category term="bash" scheme="https://mhynet.cn/tags/bash/"/></entry><entry><title>linux学习笔记(1)</title><link href="https://mhynet.cn/linux-note-1.html"/><id>https://mhynet.cn/linux-note-1.html</id><published>2018-08-16T04:25:59.000Z</published><updated>2020-01-15T07:21:55.993Z</updated><content type="html"><![CDATA[<p>最近给家里的PC的虚拟机上搭建开发环境，经常用到文件或目录权限的问题， 发现对这一块的了解还不够，所以抽时间恶补了一下，这里记录一下。<br><a id="more"></a></p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>文件权限区分的文件类型有三种，分别是：</p><blockquote><p>-: 文件;<br>d: 目录;<br>l: 软连接文件<br>rw-  r– r–<br>u 所有者  g所属组  o其他人<br>r read  w write x 执行(excute)</p></blockquote><h2 id="权限范围的表示"><a href="#权限范围的表示" class="headerlink" title="权限范围的表示"></a>权限范围的表示</h2><p>使用ls -la 命令查看文件权限范围：</p><blockquote><p>ls 命令的选项详解:</p><ul><li>-a</li><li>-l (lang) (ll)</li><li>-d 查看目录属性</li><li>-h  人性化显示文件大小</li><li>-i 显示inode</li></ul></blockquote><p>执行<code>ls -la</code>后显示出来的内容从左到右依次为：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--   <span class="number">1</span>         root       wheel    <span class="number">515</span>B  <span class="number">7</span><span class="number">13</span><span class="number">2015</span> afpovertcp.cfg</span><br><span class="line">  权限  <span class="number">1</span>引用计数 所有者root 所属组sheel 文件大小 最后修改时间  文件名</span><br></pre></td></tr></table></figure></p><h2 id="文件权限控制"><a href="#文件权限控制" class="headerlink" title="文件权限控制"></a>文件权限控制</h2><p>文件格式：<br><code>-rw-r-r--</code></p><p>liniux文件权限格式一共有10位，第一位是文件类型，后面没三位代表一组，每三位一组， 相同权限的为一组，依次为：u 所有者, g所属组, o其他人</p><blockquote><p>u: User, 文件或目录的拥有者<br>g: Group，文件或目录的所属群组<br>o: Other, 除了文件或目录的拥有者或所属群组之外，其他用户皆属于这个范围<br>a: All, 全部用户，包含拥有者、所属群组以及其他用户<br>r: read， 读取权限， 数字代号为 ‘4’<br>w: write, 写入权限，数字代号为’2’<br>x: 执行或切换的权限，数字代号为’1’<br>-: 不具备任何权限， 数字代号为’0’<br>s: 特殊功能说明，变更文件或目录的权限</p></blockquote><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><ul><li><p>格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--<span class="built_in">help</span>] [--version] mode file...</span><br></pre></td></tr></table></figure></li><li><p>选项</p><blockquote><p>-c或–change: 效果类似’-v’参数，但仅返回更改的部分<br>-f或–quiet或–silent: 不显示错误信息<br>-R或–recursive: 递归处理， 将指令目录下的所有文件及字母里一并处理<br>-v或–verbose： 显示指令执行过程<br>–reference=&lt;参考文件或目录&gt;： 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同<br>&lt;权限范围&gt;+&lt;权限设置&gt;： 开启权限范围的文件或目录的该选项权限设置<br>&lt;权限范围&gt;-&lt;权限设置&gt;： 关闭权限范围的文件或目录的该选项权限设置<br>&lt;权限范围&gt;=&lt;权限设置&gt;： 指定权限范围的文件或目录的该选项权限设置</p></blockquote></li><li><p>参数<br>权限模式： 指定文件的权限模式<br>文件： 要改变权限的文件</p></li></ul><blockquote><p>chmod 722 ./shell.sh</p></blockquote><p>chmod 777 shell.sh # 统一授权方式，使用三位数字代表权限，每一位代表一个组，三个组授权均为7（rwx）<br>chmod u+x shell.sh # 给u组增加权限x</p><h1 id="数字0-7代表含义"><a href="#数字0-7代表含义" class="headerlink" title="数字0 ~ 7代表含义"></a>数字0 ~ 7代表含义</h1><blockquote><p>0: —   000<br>1: –x   001<br>2: -w-   010<br>3: -wx   011<br>4: r–   100<br>5: r-x   101<br>6: rw-   110<br>7: rwx   111</p></blockquote><p>可以看出规律，每一组的权限按照从左到右的排序依次是rwx,按三个二进制位排序，哪一位为1就代表该位有权限</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>改变文件所有者命令格式：</p><blockquote><p>chown [选项] 参数<br>chown [选项]… [所有者][:[组]] 文件…</p></blockquote><p>eg:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mhy:mhy ~/.ssh</span><br></pre></td></tr></table></figure></p><p>同时把<code>.ssh</code>的所有者和组都改成了mhy</p><p>选项：</p><ul><li>-R 或 –recursive 递归处理</li><li>–reference=&lt;参考文件或目录&gt;   把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录拥有者与所属群组相同</li></ul><p>参数：</p><ul><li>用户：组   指定所有者和所属组， 当省略组，仅改变所有者</li><li>文件      文件列表，可使用shell通配符改变多个<br>eg：<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mhy /<span class="built_in">home</span>/mhy<span class="comment">/*</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/user</span><br><span class="line">./file.js</span><br></pre></td></tr></table></figure><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><blockquote><p>cd ~ (当前用户的家目录，如果是root用户，则是在/root， 其他用户家目录在/home/username)<br>cd . 当前<br>cd .. 上一级<br>cd - 进入上一次目录</p></blockquote><h2 id="文件和文件夹处理命令"><a href="#文件和文件夹处理命令" class="headerlink" title="文件和文件夹处理命令"></a>文件和文件夹处理命令</h2><p>创建文件夹格式：</p><blockquote><p>mkdir -p [目录名]</p></blockquote><p>选项：</p><ul><li>-p 递归创建（先建立上一级目录）</li></ul><p>其他命令：</p><ul><li>pwd</li><li>rmdir 删除空白目录，如果有子文件则无法删除，不常用</li><li>rm 删文件或目录</li><li>rm -rf  强制删除目录</li><li>rm -r 删除目录， 会有确认提示</li><li>rm -f 强制删除，不会提示</li><li>cp 复制文件或目录</li><li>cp [选项] 需要复制的路径  目标位置</li><li>cp -r 复制目录</li><li>cp -p 连带文件属性复制</li><li>cp -d 若源文件是链接文件则复制链接属性</li><li>cp -a 相当于 -pdr</li><li>mv [源文件位置] [目标位置]</li></ul><h3 id="常用目录"><a href="#常用目录" class="headerlink" title="常用目录"></a>常用目录</h3><p>系统命令目录<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/bin</span></span><br><span class="line"><span class="string">/sbin</span></span><br><span class="line"><span class="string">/usr/bin</span></span><br><span class="line"><span class="string">/usr/sbin</span></span><br><span class="line">sbin下只有root权限可以执行， 其他两个所有不需要root</span><br><span class="line"></span><br><span class="line"><span class="string">/boot</span> 启动目录</span><br><span class="line"><span class="string">/etc</span> 默认配置文件目录</span><br><span class="line"><span class="string">/lib</span> 函数库</span><br><span class="line"><span class="string">/media</span> 挂载移动盘</span><br><span class="line"><span class="string">/mnt</span> 挂载磁盘</span><br><span class="line"><span class="string">/sys</span><span class="string">/proc</span>  内存相关的目录</span><br><span class="line"><span class="string">/tmp</span> 临时目录</span><br><span class="line"><span class="string">/usr</span> 系统软件资源目录</span><br><span class="line">2<span class="string">/usr/bin</span> 系统命令<span class="params">(普通用户)</span></span><br><span class="line">2<span class="string">/usr/sbin</span> 系统命令<span class="params">(root)</span></span><br><span class="line"><span class="string">/var</span> 系统相关的文档内容</span><br></pre></td></tr></table></figure></p><h2 id="链接命令-link"><a href="#链接命令-link" class="headerlink" title="链接命令(link)"></a>链接命令(link)</h2><blockquote><p>ln -s [原文件]] [目标文件]</p></blockquote><p>选项：</p><ul><li>-s 生成软连接 不带s则生成 硬链接</li></ul><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>特点：</p><blockquote><p>1.拥有相同的i节点和存储block块，可以看成是同一个文件<br>2.可通过i节点识别<br>3.不能跨分区<br>4.不能针对目录使用<br>5.删除一个，另一个还在（通过i节点识别）</p></blockquote><h3 id="软链接："><a href="#软链接：" class="headerlink" title="软链接："></a>软链接：</h3><p>特点：</p><blockquote><p>1.类似windows的快捷方式<br>2.软链接有自己的i节点和block块，数据只保存在原文件的文件名和i节点，并没有实际的文件数据<br>3.lrwx—–  第一个l表示软链接<br>4.修改原文件，改任何一个的都会改变，<br>5.删除原文件，软链接不能使用（硬链接不影响使用）<br>6.删除软链接可以使用原文件<br>7.软链接的权限777，但是实际权限是原文件的权限<br>8.创建软链接时原文件必须写绝对路径</p></blockquote><p>查看i节点：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ls -i</span></span><br></pre></td></tr></table></figure></p><h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><blockquote><p>1.文件搜索命令: locate<br>2.文件搜索命令: find<br>3.命令搜索命令: whereis, which<br>4.字符串搜索命令: grep</p></blockquote><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><blockquote><p>locate 文件名</p></blockquote><p>在后台数据库按文件名搜索，速度快, locate命令搜索的数据库是 <code>/var/lib/locate</code><br>每天更新一次，所有新建文件后可以强制更新该数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updatedb</span><br></pre></td></tr></table></figure></p><p>locate使用特点：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只能按文件名搜索</span><br><span class="line">配置文件: /etc/updatedb.conf</span><br><span class="line">配置里面的选项是不搜索的文件系统</span><br><span class="line">MAC系统和linux系统的locate有差异</span><br></pre></td></tr></table></figure></p><h3 id="whereis-where-which"><a href="#whereis-where-which" class="headerlink" title="whereis (where), which"></a>whereis (where), which</h3><blockquote><p>whereis 查看执行位置和帮助文档位置</p></blockquote><p>选项：</p><ul><li>-b 只查找可执行文件</li><li>-m 之查找帮助文件</li></ul><p>which 查看命令的可执行位置和别名</p><blockquote><p>which</p></blockquote><p><strong>只能查外部安装的命令，即只能查需要执行脚本文件的命令</strong><br>搜索依赖于环境变量 $PATH</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>文件搜索命令, 很强大</p><blockquote><p>find [搜索范围] [搜索条件]</p></blockquote><p>eg:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> / -name nginx.conf</span><br><span class="line"><span class="builtin-name">find</span> ~/.ssh -name config</span><br></pre></td></tr></table></figure></p><p><strong>避免大范围搜索，很消耗系统资源</strong>。<br>find是在系统中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配.</p><h3 id="通配符："><a href="#通配符：" class="headerlink" title="通配符："></a>通配符：</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>匹配任意内容</span><br><span class="line">? 匹配任意一个字符</span><br><span class="line">[] 匹配任意一个中括号内的字符</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-name  按名称</li><li>-iname 不区分大小写按名称</li><li>-user  按所有者搜索</li><li>-nouser 查找没有所有者的文件（内核文件没有所有者，u盘的数据可能没有所有者，windows文件没有所有者）</li><li>-mtime 查找限定时间前修改的文件 默认是天</li></ul><p>eg：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find /var/log/ -mtime +<span class="number">10</span> #查找<span class="number">10</span>天前修改的文件</span><br><span class="line"><span class="number">-10</span><span class="number">10</span>天内</span><br><span class="line"><span class="number">10</span><span class="number">10</span>天当天</span><br><span class="line">+<span class="number">10</span><span class="number">10</span>天前</span><br><span class="line">-atime 文件访问时间</span><br><span class="line">-ctime 改变文件属性</span><br><span class="line">-mtime 修改文件内容</span><br><span class="line"></span><br><span class="line">find / -size <span class="number">25</span>k #查找文件大小是<span class="number">25</span>kb的文件</span><br><span class="line">—<span class="number">25</span> 小于<span class="number">25</span>kb</span><br><span class="line"><span class="number">25</span>kb 等于<span class="number">25</span>kb</span><br><span class="line">+<span class="number">25</span>kb 大于<span class="number">25</span>kb</span><br><span class="line"></span><br><span class="line">find / -size +<span class="number">25</span>k -a <span class="number">-50</span>k # 大于<span class="number">25</span>k 且 小于<span class="number">50</span>k</span><br><span class="line">find / -size <span class="number">-25</span>k -o +<span class="number">50</span>k # 小于<span class="number">25</span>k 或 大于<span class="number">50</span>k</span><br><span class="line"></span><br><span class="line">find / -size <span class="number">25</span>k -exec ls -lh &#123;&#125; \; #查找，并显示详细信息</span><br></pre></td></tr></table></figure></p><p>查找到的文件执行后面的操作 -exec:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-exec <span class="string">...</span> &#123;&#125; \;  <span class="comment">#标准格式</span></span><br><span class="line">find . -inum 262422 <span class="comment">#查找i节点是262422的文件</span></span><br><span class="line"><span class="comment"># k字节小写， M字节大写</span></span><br><span class="line"><span class="keyword">ls</span> -i 文件名</span><br></pre></td></tr></table></figure></p><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p>在指定文件中搜索字符串</p><blockquote><p>grep [选项] 字符串 文件名<br>选项：</p><ul><li>-i 忽略大小写</li><li>-v 排除指定字符串， 取反搜索</li></ul></blockquote><p>eg:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span><span class="string">"size"</span> file_name</span><br><span class="line"><span class="keyword">grep</span><span class="string">"size"</span> file1 file2 file3  <span class="comment">#多文件搜索</span></span><br></pre></td></tr></table></figure></p><p>标记匹配颜色 –color=auto 选项：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"size"</span><span class="built_in">file_name</span> --<span class="built_in">color</span>=auto</span><br></pre></td></tr></table></figure></p><p>使用正则表达式 -E 选项：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -E <span class="string">"[1-9]+"</span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">egrep <span class="string">"[1-9]+"</span></span><br></pre></td></tr></table></figure></p><p>只输出文件中匹配到的部分 -o 选项：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> this <span class="keyword">is</span><span class="keyword">a</span> test <span class="built_in">line</span>. | <span class="keyword">grep</span> -<span class="keyword">o</span> -E <span class="string">"[a-z]+\."</span></span><br></pre></td></tr></table></figure></p><h3 id="grep-和-find-区别"><a href="#grep-和-find-区别" class="headerlink" title="grep 和 find 区别"></a>grep 和 find 区别</h3><ul><li>find 在系统中搜索文件名，通配符匹配， 通配符是<em>完全匹配</em></li><li>grep 在文件中搜索字符串，可以使用正则匹配，正则是<em>包含匹配</em></li></ul><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p> man 命令</p><ul><li>查看有哪些级别:<blockquote><p>man -f 命令  == whatis 命令</p></blockquote></li><li><p>查看指定级别:</p><blockquote><p>man -5 passwd<br>man -4 null<br>man -8 ifconfig</p></blockquote></li><li><p>查看所有含有命令关键词的信息:</p><blockquote><p>man -k 命令</p></blockquote></li></ul><h3 id="其他帮助命令"><a href="#其他帮助命令" class="headerlink" title="其他帮助命令"></a>其他帮助命令</h3><ul><li>选项帮助: –help</li></ul><p>命令帮助选项</p><ul><li>shell内部命令： help</li></ul><p>获取shell内部的帮助，shell有自带的一些命令，比如cd,help<br>可以通过whereis cd 确定是否是shell内部命令，看可执行文件</p><blockquote><p>help cd #command not found: help</p></blockquote><ul><li>info</li></ul><h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><ul><li>常营压缩格式：<blockquote><p>.zip  .gz  .bz2<br>.tar.gz  .tar.bz2</p></blockquote></li></ul><p><strong>linux文件不区分后缀名，但是压缩文件为了区分文件类型和压缩类型，必须要在后缀中写清楚格式</strong><br>按压缩格式来记命令笔记方便</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><ul><li>压缩文件：<blockquote><p>zip 压缩文件名  源文件</p></blockquote></li><li>压缩目录“<blockquote><p>zip -r 压缩文件名  源目录</p></blockquote></li><li>解压缩：<blockquote><p>unzip 压缩文件</p></blockquote></li></ul><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><ul><li>压缩为.gz格式文件，源文件会消失：<blockquote><p>gzip 源文件</p></blockquote></li><li>压缩为.gz格式，源文件保留：<blockquote><p>gzip -c 源文件 &gt; 压缩文件<br>eg：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -c <span class="selector-tag">a</span><span class="selector-class">.js</span> &gt; <span class="selector-tag">a</span><span class="selector-class">.js</span>.gz</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>实际上是把源文件输出到新的文件</p><ul><li>压缩目录<br>压缩目录实际上是把目录内的文件全部压缩<blockquote><p>gzip -r 目录</p></blockquote></li></ul><p>压缩目录下所有子文件，但是不能压缩目录</p><ul><li><p>解压缩文件</p><blockquote><p>gzip -d 压缩文件<br>gunzip 压缩文件</p></blockquote></li><li><p>解压缩目录</p><blockquote><p>gunzip -r 压缩目录</p></blockquote></li></ul><h3 id="bz2-（不能压缩目录）"><a href="#bz2-（不能压缩目录）" class="headerlink" title=".bz2 （不能压缩目录）"></a>.bz2 （不能压缩目录）</h3><p>压缩文件：</p><blockquote><p>bzip2 文件名<br>bzip2 -k 文件名</p></blockquote><p>解压缩文件：</p><blockquote><p>-k 保留压缩文件<br>bzip2 -d 压缩文件<br>bunzip2 压缩文件</p></blockquote><p><strong>上面三个压缩命令只有zip可以压缩没有了， gzip压缩目录实际上是压缩了目录内的文件，bz2直接回报错，可以用tar命令打包，然后再压缩</strong></p><h3 id="打包命令-tar"><a href="#打包命令-tar" class="headerlink" title="打包命令 tar"></a>打包命令 tar</h3><ul><li>打包命令：<blockquote><p>tar -cvf 打包文件名 源文件</p></blockquote></li></ul><p>选项：</p><ul><li>-c 打包</li><li>-v 显示过程</li><li><p>-f 指定打包后的文件名<br>eg:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span><span class="selector-tag">-cvf</span><span class="selector-tag">longzls</span><span class="selector-class">.tar</span><span class="selector-tag">longzls</span></span><br></pre></td></tr></table></figure></li><li><p>解打包命令：</p><blockquote><p>tar -xvf 打包文件名</p></blockquote></li></ul><p>选项：</p><ul><li>-x: 解打包<br>eg:<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span><span class="selector-tag">-xvf</span><span class="selector-tag">longzls</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="tar-gz"><a href="#tar-gz" class="headerlink" title=".tar.gz"></a>.tar.gz</h3><p>.tar.gz格式是先打包为.tar格式，然后压缩为.gz格式</p><blockquote><p>tar -zcvf 压缩包名.tar.gz 源文件</p></blockquote><p>选项：</p><ul><li>-z 压缩为.tar.gz格式</li></ul><blockquote><p>tar -zxvf 压缩包名.tar.gz</p></blockquote><p>选项：</p><ul><li>-x 解压缩.tar.gz格式</li></ul><h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><blockquote><p>tar -jcvf 压缩包名.tar.bz2 源文件</p></blockquote><p>选项：</p><ul><li>-j 压缩为.tar.bz2格式</li></ul><blockquote><p>tar -jxvf 压缩包名.tar,bz2</p></blockquote><p>选项：</p><ul><li>-x 解压缩.tar.bz2格式</li></ul><p>指定解压缩位置：</p><blockquote><p>tar -jxvf 压缩包名.gz.bz2  -C 解压缩位置</p></blockquote><p>注意： 选项大写C必须写到压缩包名后面</p><p>压缩多个文件时压缩文件名用空格连接</p><p>查看包里面内容不解压，选项：</p><ul><li>-t</li></ul><p><strong>Linux最常用的压缩格式是.tar.gz和.tar.bz2</strong></p><h2 id="Linux的关机和重启命令"><a href="#Linux的关机和重启命令" class="headerlink" title="Linux的关机和重启命令"></a>Linux的关机和重启命令</h2><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><blockquote><p>shutdown [选项] 时间</p></blockquote><p>选项：</p><ul><li>-c 取消前一个挂机命令</li><li>-h 关机</li><li>-r 重启</li></ul><p>时间：</p><ul><li>now #立即执行</li><li>10 #十分钟后执行</li></ul><p>eg:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h <span class="number">2</span>:<span class="number">33</span> # <span class="number">2</span>:<span class="number">32</span> 关机</span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure></p><p>shutdown 命令可以正确保持关机前的文件，比较安全.</p><p><strong>以下命令关机不安全</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">halt</span><br><span class="line">poweroff</span><br><span class="line">init <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h3 id="重启："><a href="#重启：" class="headerlink" title="重启："></a>重启：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line">init <span class="number">6</span></span><br></pre></td></tr></table></figure><p>reboot 是比较安全的重启方式</p><h3 id="退出登录："><a href="#退出登录：" class="headerlink" title="退出登录："></a>退出登录：</h3><blockquote><p>logout</p></blockquote><h2 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h2><p>查询系统中挂载的点：</p><blockquote><p>mount</p></blockquote><p>依据/etc/fstab文件自动挂载：</p><blockquote><p>mount -a</p></blockquote><p>挂载命令格式：</p><blockquote><p>mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点</p></blockquote><p>选项：</p><ul><li>-t 文件系统：eg:ext3,ext4, ios9660….</li><li>-o 特殊选项：可以指定挂载的额外选项</li></ul><p>挂载光盘(先要插入光盘或者虚拟机导入iso镜像):</p><p>1.建立挂载点：</p><blockquote><p>mkdir /mnt/cdrom/</p></blockquote><p>2.挂载光盘</p><blockquote><p>mount -t iso9660 /dev/cdrom/ /mnt/cdrom/</p></blockquote><p>3.简写（默认的文件系统）</p><blockquote><p>mount /dev/sr0 /mnt/cdrom</p></blockquote><p>4.卸载命令：</p><blockquote><p>umount 设备名或挂载点<br>umount /mnt/cdrom</p></blockquote><p>5.挂载U盘:</p><blockquote><p>fdisk -l # 查看U盘设备文件名<br>mount -t vfat /dev/sdb1 /mnt/ust/</p></blockquote><h2 id="远程登录y用户信息查看"><a href="#远程登录y用户信息查看" class="headerlink" title="远程登录y用户信息查看"></a>远程登录y用户信息查看</h2><blockquote><p>w</p></blockquote><p><code>w</code> 命令查看系统远程登录用户信息，包括系统资源</p><blockquote><p> who</p></blockquote><p><code>who</code> 命令查看系统远程登录用户信息，功能和w命令类似，不过没有系统资源信息</p><blockquote><p>last</p></blockquote><p>last命令默认是读取<code>/var/log/wtmp</code>文件的数据。命令输出：</p><blockquote><p>用户名  登录终端 登录ip 登录时间 退出时间(在线时间)</p></blockquote><blockquote><p>lastlog</p></blockquote><p>查询所有用户的最后一次登录</p><p>参考：<br><a href="http://man.linuxde.net/chmod" target="_blank" rel="noopener">chmod命令</a><br><a href="http://www.runoob.com/linux/linux-comm-chmod.html" target="_blank" rel="noopener">Linux chmod命令</a></p>]]></content><summary type="html">
    
      linux 学习笔记之权限管理。
    
    </summary><category term="后端" scheme="https://mhynet.cn/categories/%E5%90%8E%E7%AB%AF/"/><category term="linux" scheme="https://mhynet.cn/tags/linux/"/><category term="bash" scheme="https://mhynet.cn/tags/bash/"/></entry><entry><title>mongodb学习笔记</title><link href="https://mhynet.cn/mongodb-notes.html"/><id>https://mhynet.cn/mongodb-notes.html</id><published>2018-07-04T02:36:21.000Z</published><updated>2020-01-13T04:05:08.198Z</updated><content type="html"><![CDATA[<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>在mac下启动mongod服务时，如果读取默认配置文件的话直接执行<code>mongod</code>就行了，如果要添加其他配置可以添加对应的配置项，但是最合理的应该是读取配置文件且后台运行服务。<br>使用 -f 或 –config 选项指定配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f  /etc/mongod.conf &amp;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">mongod --config  /etc/mongod.conf &amp;</span><br></pre></td></tr></table></figure></p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>如果存在则切换，不存在则创建<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> DATABASE_NAME</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> dbs</span><br></pre></td></tr></table></figure><p>发现刚刚创建的数据库没有有显示出来，可以插入数据<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.runoob.<span class="built_in">insert</span>(&#123;<span class="string">"name"</span>:<span class="string">"菜鸟教程"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>然后执行<code>show dbs</code>发现刚刚创建的数据库显示出来了</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>以下命令删除的是当前的数据库，如果要删除非当前数据库需要先使用<code>use DATABASE_NAME</code>命令切换过去，然后执行以下命令<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.dropDatabase</span>()</span><br></pre></td></tr></table></figure></p><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.create<span class="constructor">Collection(<span class="params">name</span>, <span class="params">optipon</span>)</span></span><br></pre></td></tr></table></figure><ul><li>name: 集合名称</li><li>options： 可选参数对象，有以下选项<ul><li>capped: 布尔 (可选)， 如果为true则创建固定集合，是指有固定大小的集合，当达到最大值时会自动覆盖最早的数据， 当该值为true时，必须指定size参数</li><li>autoIndexId: 布尔 （可选）如果为true，则自动在_id字段创建索引，默认为false</li><li>size: 数值 （可选） 固定集合指定一个最大值， 单位是字节</li><li>max: 数值 （可选） 固定集合中包含的文档的最大数量</li></ul></li></ul><h3 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h3><p>查看当前数据库的已有集合<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> collections</span><br></pre></td></tr></table></figure></p><p>eg:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">db.createCollection("my_test_coll1",</span><span class="string">&#123;</span><span class="attr">capped:</span><span class="literal">true</span><span class="string">,</span><span class="attr">autoIndexId:</span><span class="literal">true</span><span class="string">,</span><span class="attr">size:</span><span class="number">6142800</span><span class="string">,</span><span class="attr">max :</span><span class="number">10000</span><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure></p><p>在mongodb中也可以通过直接插入数据创建集合<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.my_test_coll2.<span class="built_in">insert</span>(&#123;<span class="string">"name"</span>: <span class="string">"mhyuan"</span>, <span class="string">"age"</span>: <span class="number">22</span>&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.drop</span>()</span><br></pre></td></tr></table></figure><p>如果删除成功返回true，否则返回false</p><h3 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h3><p>BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。mongodb中所有存储在集合中的数据都是BSON结构。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.COLLECTION_NAME</span><span class="selector-class">.insert</span>(<span class="selector-tag">document</span>)</span><br></pre></td></tr></table></figure></p><p>eg:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col</span><span class="selector-class">.insert</span>(&#123;<span class="attribute">title</span>: <span class="string">'MongoDB 教程'</span>,</span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'mhy'</span>,</span><br><span class="line">    url: <span class="string">'http://www.mhynet.cn'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>可以将数据定义成一个变量，然后插入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">document</span>=(&#123;title: <span class="string">'MongoDB 教程'</span>,</span><br><span class="line">    description: <span class="string">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class="line">    by: <span class="string">'mhy'</span>,</span><br><span class="line">    url: <span class="string">'http://www.mhynet.cn'</span>,</span><br><span class="line">    tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col2</span><span class="selector-class">.insert</span>(<span class="selector-tag">document</span>)</span><br></pre></td></tr></table></figure></p><p>也可以执行<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col</span><span class="selector-class">.save</span>(<span class="selector-tag">document</span>)</span><br></pre></td></tr></table></figure></p><p>如果不知道_id字段则效果和insert一样，如果指定了_id，则会更新该_id的数据</p><ul><li><p>db.collection.insertOne(): 向指定集合中插入一条文档数据</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert<span class="constructor">One(&#123;<span class="string">"a"</span>: 3&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>db.collection.insertMany(): 向指定集合中插入多条文档数据</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.collection</span><span class="selector-class">.insertMany</span>(<span class="selector-attr">[&#123;<span class="string">"b"</span>: 3&#125;, &#123;<span class="string">'c'</span>: 4&#125;]</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>mongodb使用updata()和save()方法更新数据<br>update()方法用于更新已存在的文档<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">2<span class="params">&lt;query&gt;</span>,</span><br><span class="line">2<span class="params">&lt;update&gt;</span>,</span><br><span class="line">2&#123;</span><br><span class="line"><span class="symbol">upsert:</span><span class="params">&lt;boolean&gt;</span>,</span><br><span class="line"><span class="symbol">multi:</span><span class="params">&lt;boolean&gt;</span>,</span><br><span class="line"><span class="symbol">writeConcern:</span><span class="params">&lt;document&gt;</span></span><br><span class="line">2&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ul><li>参数说明：<ul><li>query: update的查询条件，类似于SQL update 的where后面的</li><li>update: update的对象和一些更新的操作符（如$,$inc…），也可以理解为SQL update 查询内set后面的</li><li>upsert: 可选， 如果不存在update的记录，是否插入数据， true为插入， 默认为false</li><li>multi: 可选， mongodb默认为false，只更新找到的第一条记录，如果这个参数为true，就把按条件查出来的多条记录全部更新</li><li>writeConcern: 可选，抛出异常的级别</li></ul></li></ul><ul><li><p>只更新第一条记录：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="symbol">$</span><span class="keyword">gt</span> : <span class="number">1</span> &#125; &#125; , &#123; <span class="symbol">$</span><span class="keyword">set</span> : &#123; <span class="string">"test2"</span> : <span class="string">"OK"</span>&#125; &#125; );</span><br></pre></td></tr></table></figure></li><li><p>全部更新：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="symbol">$</span><span class="keyword">gt</span> : <span class="number">3</span> &#125; &#125; , &#123; <span class="symbol">$</span><span class="keyword">set</span> : &#123; <span class="string">"test2"</span> : <span class="string">"OK"</span>&#125; &#125;,false,true <span class="comment">)</span>;</span><br></pre></td></tr></table></figure></li><li><p>只添加第一条：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="symbol">$</span><span class="keyword">gt</span> : <span class="number">4</span> &#125; &#125; , &#123; <span class="symbol">$</span><span class="keyword">set</span> : &#123; <span class="string">"test5"</span> : <span class="string">"OK"</span>&#125; &#125;,true,false <span class="comment">)</span>;</span><br></pre></td></tr></table></figure></li><li><p>全部添加进去:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.update( &#123; <span class="string">"count"</span> : &#123; <span class="symbol">$</span><span class="keyword">gt</span> : <span class="number">5</span> &#125; &#125; , &#123; <span class="symbol">$</span><span class="keyword">set</span> : &#123; <span class="string">"test5"</span> : <span class="string">"OK"</span>&#125; &#125;,true,true <span class="comment">)</span>;</span><br></pre></td></tr></table></figure></li><li><p>全部更新：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.<span class="keyword">update</span>( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : <span class="number">15</span> &#125; &#125; , &#123; <span class="variable">$inc</span> : &#123; <span class="string">"count"</span> : <span class="number">1</span>&#125; &#125;<span class="built_in">,false</span><span class="built_in">,true</span> );</span><br></pre></td></tr></table></figure></li><li><p>只更新第一条记录：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.<span class="keyword">update</span>( &#123; <span class="string">"count"</span> : &#123; <span class="variable">$gt</span> : <span class="number">10</span> &#125; &#125; , &#123; <span class="variable">$inc</span> : &#123; <span class="string">"count"</span> : <span class="number">1</span>&#125; &#125;<span class="built_in">,false</span><span class="built_in">,false</span> );</span><br></pre></td></tr></table></figure></li></ul><h3 id="save-方法"><a href="#save-方法" class="headerlink" title="save()方法"></a>save()方法</h3><p>save方法通过传入的文档来替换已有文档<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.collection</span><span class="selector-class">.save</span>(</span><br><span class="line">2&lt;<span class="selector-tag">document</span>&gt;,</span><br><span class="line">2&#123;</span><br><span class="line">22<span class="attribute">writeConcern</span>: &lt;document&gt;</span><br><span class="line">2&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ul><li>参数说明：<ul><li>document: 文档数据</li><li>writeConcern: 可选， 抛出异常的级别</li></ul></li></ul><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db<span class="built_in">.collection</span><span class="built_in">.remove</span>(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">query</span>&gt;</span>,</span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">justOne</span>&gt;</span></span></span><br><span class="line"><span class="xml">)</span></span><br><span class="line"><span class="xml">如果你的 Mong</span></span><br></pre></td></tr></table></figure><p>如果你的 MongoDB 是 2.6 版本以后的，语法格式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.collection</span><span class="selector-class">.remove</span>(</span><br><span class="line">   &lt;<span class="selector-tag">query</span>&gt;,</span><br><span class="line">   &#123;</span><br><span class="line"><span class="attribute">justOne</span>: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ul><li>参数说明<ul><li>query : （可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul></li></ul><blockquote><p>remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法。</p></blockquote><blockquote><p>如删除集合下全部文档：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.deleteMany</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 status 等于 A 的全部文档：</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.deleteMany</span>(&#123; <span class="attribute">status </span>: <span class="string">"A"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 status 等于 D 的一个文档：</span></span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.inventory</span><span class="selector-class">.deleteOne</span>( &#123; <span class="attribute">status</span>: <span class="string">"D"</span> &#125; )</span><br></pre></td></tr></table></figure></p></blockquote><p>remove() 方法 并不会真正释放空间。<br>需要继续执行 db.repairDatabase() 来回收磁盘空间</p><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.collection</span><span class="selector-class">.find</span>(<span class="selector-tag">query</span>, <span class="selector-tag">projection</span>)</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>query ：可选，使用查询操作符指定查询条件</li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul></li></ul><p>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col</span><span class="selector-class">.find</span>()<span class="selector-class">.pretty</span>()</span><br></pre></td></tr></table></figure></p><p>pretty() 方法以格式化的方式来显示所有文档。</p><p>除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。</p><table><thead><tr><th>操作</th><th>格式</th><th>范例</th><th>RDBMS中的类似语句</th></tr></thead><tbody><tr><td>等于</td><td>{\<key>:\<value>}</value></key></td><td>db.col.find({“by”:”菜鸟教程”}).pretty()</td><td>where by = ‘菜鸟教程’</td></tr><tr><td>小于</td><td>{\<key>:{$lt:\<value>}}</value></key></td><td>db.col.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>小于或等于</td><td>{\<key>:{$lte:\<value>}}</value></key></td><td>db.col.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;= 50</td></tr><tr><td>大于</td><td>{\<key>:{$gt:\<value>}}</value></key></td><td>db.col.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>大于或等于</td><td>{\<key>:{$gte:\<value>}}</value></key></td><td>db.col.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;= 50</td></tr><tr><td>不等于</td><td>{\<key>:{$ne:\<value>}}</value></key></td><td>db.col.find({“likes”:{$ne:50}}).pretty()</td><td>where likes != 50</td></tr></tbody></table><ul><li>MongoDB AND 条件</li></ul><p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。</p><p>语法格式如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col</span><span class="selector-class">.find</span>(&#123;<span class="attribute">key1</span>:value1, <span class="attribute">key2</span>:value2&#125;)<span class="selector-class">.pretty</span>()</span><br></pre></td></tr></table></figure></p><p>eg:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.col.<span class="builtin-name">find</span>(&#123;<span class="string">"by"</span>:<span class="string">"菜鸟教程"</span>, <span class="string">"title"</span>:<span class="string">"MongoDB 教程"</span>&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"56063f17ade2f21f36b03133"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"菜鸟教程"</span>,</span><br><span class="line"><span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line"><span class="string">"tags"</span> : [</span><br><span class="line"><span class="string">"mongodb"</span>,</span><br><span class="line"><span class="string">"database"</span>,</span><br><span class="line"><span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line"><span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上实例中类似于 WHERE 语句：WHERE by=’菜鸟教程’ AND title=’MongoDB 教程’</p><ul><li><p>MongoDB OR 条件<br>MongoDB OR 条件语句使用了关键字 $or,语法格式如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.col</span><span class="selector-class">.find</span>(</span><br><span class="line">   &#123;</span><br><span class="line">      $<span class="attribute">or</span>: [</span><br><span class="line">         &#123;<span class="attribute">key1</span>: value1&#125;, &#123;<span class="attribute">key2</span>:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">)<span class="selector-class">.pretty</span>()</span><br></pre></td></tr></table></figure></li><li><p>AND 和 OR 联合使用<br>类似常规 SQL 语句为：<code>&#39;where likes&gt;50 AND (by = &#39;菜鸟教程&#39; OR title = &#39;MongoDB 教程&#39;)&#39;</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.col.<span class="builtin-name">find</span>(&#123;<span class="string">"likes"</span>: &#123;<span class="variable">$gt</span>:50&#125;, <span class="variable">$or</span>: [&#123;<span class="string">"by"</span>: <span class="string">"菜鸟教程"</span>&#125;,&#123;<span class="string">"title"</span>: <span class="string">"MongoDB 教程"</span>&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_id"</span> : ObjectId(<span class="string">"56063f17ade2f21f36b03133"</span>),</span><br><span class="line"><span class="string">"title"</span> : <span class="string">"MongoDB 教程"</span>,</span><br><span class="line"><span class="string">"description"</span> : <span class="string">"MongoDB 是一个 Nosql 数据库"</span>,</span><br><span class="line"><span class="string">"by"</span> : <span class="string">"菜鸟教程"</span>,</span><br><span class="line"><span class="string">"url"</span> : <span class="string">"http://www.runoob.com"</span>,</span><br><span class="line"><span class="string">"tags"</span> : [</span><br><span class="line"><span class="string">"mongodb"</span>,</span><br><span class="line"><span class="string">"database"</span>,</span><br><span class="line"><span class="string">"NoSQL"</span></span><br><span class="line">        ],</span><br><span class="line"><span class="string">"likes"</span> : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content><summary type="html">
    
      mongodb数据库常用命令
    
    </summary><category term="数据库" scheme="https://mhynet.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/><category term="mongodb" scheme="https://mhynet.cn/tags/mongodb/"/><category term="数据库" scheme="https://mhynet.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/></entry><entry><title>vuex学习笔记</title><link href="https://mhynet.cn/vuex-notes.html"/><id>https://mhynet.cn/vuex-notes.html</id><published>2018-05-09T11:37:39.000Z</published><updated>2020-01-09T07:07:51.481Z</updated><content type="html"><![CDATA[<blockquote><p>vuex是为Vue应用开发的<strong>状态管理模式</strong>。<br>它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p></blockquote><p>这个状态自管理应用包含以下几个部分：</p><ul><li>state，驱动应用的数据源；</li><li>view，以声明方式将 state 映射到视图；</li><li>actions，响应在 view 上的用户输入导致的状态变化。<a id="more"></a><strong>单向数据流</strong><img src="https://vuex.vuejs.org/zh-cn/images/flow.png" style="width: 400px; display: block;"></li></ul><p><strong>多个组件共享状态</strong><br><img src="https://vuex.vuejs.org/zh-cn/images/vuex.png" style="width: 400px; display: block;"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用npm安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure></p><p>使用yarn安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vuex</span><br></pre></td></tr></table></figure></p><p>在项目中使用<code>Vue.use()</code>来安装引入 Vuex<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span><span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span><span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><h4 id="在-Vue-组件中获得-Vuex-状态"><a href="#在-Vue-组件中获得-Vuex-状态" class="headerlink" title="在 Vue 组件中获得 Vuex 状态"></a>在 Vue 组件中获得 Vuex 状态</h4><p>从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line"><span class="keyword">return</span> store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line"><span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="app"&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line"><span class="keyword">return</span><span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h4><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span><span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  computed: mapState(&#123;</span><br><span class="line"><span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class="line">    countAlias: <span class="string">'count'</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line"><span class="keyword">return</span> state.count + <span class="keyword">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line"><span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line"><span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h4 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h4><p>mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符（现处于 ECMASCript 提案 stage-3 阶段），我们可以极大地简化写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line"><span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState(&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 接受 state 作为其第一个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        todos: [</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">test</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Getter 会暴露为 store.getters 对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br></pre></td></tr></table></figure></p><p>我们可以很容易地在任何组件中使用它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line"><span class="keyword">return</span><span class="keyword">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="mapGetters-辅助函数"><a href="#mapGetters-辅助函数" class="headerlink" title="mapGetters 辅助函数"></a>mapGetters 辅助函数</h4><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span><span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="comment">//使用对象展开符 将 getter 混入 computed 对象中</span></span><br><span class="line">        ...mapGetters([</span><br><span class="line"><span class="string">'doneTodosCount'</span>,</span><br><span class="line"><span class="string">'anothersGetters'</span>,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapGetters([</span><br><span class="line"><span class="comment">// 映射 `this.doneCount` 为 `store.getters.doneTodosCount`</span></span><br><span class="line">    doneCount: <span class="string">'doneTodosCount'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span><span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutation: &#123;</span><br><span class="line">        increment(state) &#123;</span><br><span class="line">            count ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></p><p>可以传入额外的参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>多数情况下为一个对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.count += payload.amount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">'increment'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h4><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">muations: &#123;</span><br><span class="line">    increment (state, payload) &#123;</span><br><span class="line">        state.count += payload.amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.commit(&#123;</span><br><span class="line">    type: <span class="string">'increment'</span>,</span><br><span class="line">    amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="Mutation-需遵守-Vue-的响应规则"><a href="#Mutation-需遵守-Vue-的响应规则" class="headerlink" title="Mutation 需遵守 Vue 的响应规则"></a>Mutation 需遵守 Vue 的响应规则</h4><p>Vuex 的 store 中的状态是响应式的，所以当我们变更状态时，监视状态的Vue组件也会自动更新。 意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p><ul><li>最好提前在 store 中 初始化所有需要的属性</li><li>当需要在对象上添加新属性时：<ul><li>使用 Vue.set(obj, ‘newProp’, 123) 或者</li><li>以新对象替换旧对象。例如，使用 stage-3 的 对象展开运算符：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h4><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span><span class="keyword">const</span> SOME_MUTATION = <span class="string">'SOME_MUTATION'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span><span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span><span class="string">'mutation-types'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.store(&#123;</span><br><span class="line">  state: &#123;...&#125;,</span><br><span class="line">  mutation: &#123;</span><br><span class="line"><span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION] (state) &#123;</span><br><span class="line"><span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>使用常量对于多人协作的大型项目很有帮助， 但不是必需的。</p><h4 id="Mutation-必须是同步函数"><a href="#Mutation-必须是同步函数" class="headerlink" title="Mutation 必须是同步函数"></a>Mutation 必须是同步函数</h4><p><strong>mutation必须是同步函数</strong></p><h4 id="在组件中提交-mutation"><a href="#在组件中提交-mutation" class="headerlink" title="在组件中提交 mutation"></a>在组件中提交 mutation</h4><p>在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation ，或者使用 <code>mapMutation</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span><span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations ([</span><br><span class="line"><span class="string">'increment'</span>, <span class="comment">// 将`this.increment()` 映射为`this.$store.commit('increment')`</span></span><br><span class="line"></span><br><span class="line"><span class="string">'incrementBy'</span><span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      add: <span class="string">'increment'</span><span class="comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mutation都是同步事物，处理异步事物需要使用action.</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p>让我们来注册一个简单的 action：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    motations: &#123;</span><br><span class="line">        increment(state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        increment (context) &#123;</span><br><span class="line">            context.commit(<span class="string">'increment'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="分发-Action"><a href="#分发-Action" class="headerlink" title="分发 Action"></a>分发 Action</h4><p>Action 通过 store.dispatch 方法触发：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'increment'</span>)</span><br></pre></td></tr></table></figure></p><p>可以在 action 内部进行异步操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">action: &#123;</span><br><span class="line">  incrementAsync(&#123;commit&#125;)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Actions 支持同样的载荷方式和对象方式进行分发：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>来看一个官方文档上更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line"><span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line"><span class="keyword">const</span> savedCartItems = [...state.cart.added]</span><br><span class="line"><span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    commit(types.CHECKOUT_REQUEST)</span><br><span class="line"><span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.buyProducts(</span><br><span class="line">      products,</span><br><span class="line"><span class="comment">// 成功操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_SUCCESS),</span><br><span class="line"><span class="comment">// 失败操作</span></span><br><span class="line">      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来一个：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span><span class="string">'axios'</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'...'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span><span class="function"><span class="keyword">function</span><span class="title">loadmore</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> details = state.details</span><br><span class="line"><span class="keyword">let</span> resp = <span class="keyword">await</span> axios.get(url)</span><br><span class="line"><span class="keyword">return</span> resp.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span><br><span class="line"><span class="keyword">async</span> moreDetails(&#123;commit, state&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'loadmore'</span>, <span class="keyword">await</span> loadmore(state))</span><br><span class="line">  &#125;,</span><br><span class="line">  changeAddress(&#123;commit, address&#125;) &#123;</span><br><span class="line">    commit(<span class="string">'CHANGEADDRESS'</span>, address)</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="keyword">async</span> resetAddress(&#123;commit&#125;) &#123;</span><br><span class="line"><span class="keyword">let</span> addresses = []</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">let</span> resp = <span class="keyword">await</span> axios.get(<span class="string">`...`</span>)</span><br><span class="line">      addresses = resp.data</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commit(<span class="string">'CHANGEADDRESS'</span>, addresses)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h4><p>在组件中分发action有两种方式：</p><ul><li>使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code></li><li>使用 <code>mapActions</code> 辅助函数将组件的 <code>methods</code> 映射为 <code>store.dispatch</code>来调用（需要在根节点注入store）<br>来个官网的例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span><span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span><span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line"><span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line"><span class="string">'incrementBy'</span><span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span><span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="组合使用-Action"><a href="#组合使用-Action" class="headerlink" title="组合使用 Action"></a>组合使用 Action</h4><p>store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line">actions: &#123;</span><br><span class="line"><span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line"><span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure></p><p><a href="https://vuex.vuejs.org/zh-cn/api.html" target="_blank" rel="noopener">Vuex官方API文档</a></p>]]></content><summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;vuex是为Vue应用开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。&lt;br&gt;它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个状态自管理应用包含以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state，驱动应用的数据源；&lt;/li&gt;
&lt;li&gt;view，以声明方式将 state 映射到视图；&lt;/li&gt;
&lt;li&gt;actions，响应在 view 上的用户输入导致的状态变化。
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/><category term="vue" scheme="https://mhynet.cn/tags/vue/"/><category term="vuex" scheme="https://mhynet.cn/tags/vuex/"/></entry><entry><title>移动端页面远程调试</title><link href="https://mhynet.cn/mobile-remote-debug.html"/><id>https://mhynet.cn/mobile-remote-debug.html</id><published>2018-05-05T11:27:02.000Z</published><updated>2020-01-13T04:05:08.198Z</updated><content type="html"><![CDATA[<p>本文记录一下移动端页面调试的方法，待日后有时间在详细说明相关步骤。</p><a id="more"></a><h2 id="手机连接代理"><a href="#手机连接代理" class="headerlink" title="手机连接代理"></a>手机连接代理</h2><p>手机端调试页面都需要代理，IOS和安卓都一样，连接代理的方式因手机类型不同稍有差异，但是归纳起来只有开启权限、下载证书、配置代理几部分。<br>首先需要在电脑上打开Charles应用程序，<br>Charles官网是<a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">https://www.charlesproxy.com/</a>，<br>安装证书的方式都大同小异,在浏览器中打开charles官网，下载证书，然后安装。如果安装失败，很大的可能是浏览器权限或者手机设置不对。一般只需要在浏览器中打开Charles官网，连接代理后访问页面会自动下载代理。</p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p>连接完代理之后需要安装证书，否则无法解析https的数据。<br>依次点击: 电脑上charles的help菜单 =&gt; SSL Proxying =&gt; ios手机：install Charles Root ceritificate in ios simulatore; Android手机： on a mobile devices or remote browser =&gt; 弹窗中的 chls.pro/ssl 输入到手机的浏览器中下载证书 =&gt; 在手机上点击该文件进行安装 =&gt; 部分手机的可以识别.pem证书，可以直接安装，不识别该类型文件的手机需要手动安装，请继续下面的操作 =&gt; 找到该证书文件所在资源管理器中的路径，记住它，QQ浏览器下载的路径一般在: Tentcent/QQfile_recv目录下 =&gt; 接下来是手动安装, 打开手机的设置 =&gt; 找到 “安全与隐私” 菜单，点进入，不同的手机菜单不同，请根据不同手机进行实际查找，进入该菜单下 =&gt; 在当前菜单或其子菜单中找到 “从存储设备安装” 菜单(华为mate20手机，在该目录下的 更多安全设置 -&gt; 加密与凭证 下) =&gt; 然后进入了资源管理器，找到刚才的证书路径，安装证书</p><p>不同的手机找中 “从存储设备安装”功能菜单的路径有差异，基本上都可以在安全与隐私菜单下面找到，有些手机可以在设置中直接搜索，极大地方便了查找。</p><h2 id="安卓手机远程调试"><a href="#安卓手机远程调试" class="headerlink" title="安卓手机远程调试"></a>安卓手机远程调试</h2><p><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/?utm_source=dcc&amp;utm_medium=redirect&amp;utm_campaign=2016q3" target="_blank" rel="noopener">远程调试 Android 设备使用可以参考这本篇文章</a><br>需要注意的是该方法必须使用Chrome浏览器，浏览器需要相关权限。</p><h2 id="IOS手机远程调试"><a href="#IOS手机远程调试" class="headerlink" title="IOS手机远程调试"></a>IOS手机远程调试</h2><p>IOS手机远程调试需要使用的是原生浏览器safari，同样需要数据线连接电脑，连接代理<br>需要的相关设置</p><p>手机端：<br>依次进入：设置 &gt; Safari &gt; 高级，然后开启Javascript 和 Web检查器</p><p>电脑端：<br>打开 Safari 浏览器， 在设置里面打开： 设置 &gt; 高级 , 勾选最后面的 <em>在菜单中显示“开发”菜单</em>，在电脑用户名选项下勾选<em>自动显示JSContext的网页检查器</em>，然后在手机端的Safari浏览器中打开需要调试的页面，电脑Safari浏览器的开发菜单中会出现一个手机名称的选项卡，里面会显示出手机端在Safari中打开的所有页面，点击需要调试的页面即可。如果没有显示出来，重启电脑上的Safari浏览器即可。如果还么有，可能是数据线或者设置的问题，检查相关步骤有没有问题。</p>]]></content><summary type="html">
    
      移动端h5页面调试方法
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="安卓" scheme="https://mhynet.cn/tags/%E5%AE%89%E5%8D%93/"/><category term="调试" scheme="https://mhynet.cn/tags/%E8%B0%83%E8%AF%95/"/></entry><entry><title>dispatchEvent的用法</title><link href="https://mhynet.cn/dispatchEvent.html"/><id>https://mhynet.cn/dispatchEvent.html</id><published>2018-05-04T03:58:31.000Z</published><updated>2020-01-13T04:05:08.195Z</updated><content type="html"><![CDATA[<p>浏览器事件一般被称为DOM事件，通常的用法是给某个DOM元素添加事件。浏览器中原生的DOM事件有很多，最常用的有以下几大类：鼠标事件、键盘事件、框架/对象事件、表单事件、剪切板事件、打印事件、多媒体事件、动画事件等。每一类都有若干个DOM事件。<br>前端最常用的是鼠标事件和键盘事件，比如鼠标点击、键盘键入、移动端的touch等，Web页面与用户交互是通过DOM事件来完成的。<br>最常用的事件列表这里不在罗列，可以在<a href="http://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">www.runoob.com</a>上查。之前总结过<a href="http://mhynet.cn/2017/09/04/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/">DOM事件</a>方面的知识，本文想说的是自定义事件的使用.</p><a id="more"></a><p>创建事件的方式早期的有<code>createEvent()</code>，但是目前已经过时了，现在常用的方式是使用构造函数的方式来创建事件。</p><p>事件触发一般通过用户在页面上的操作触发，但是也可以通过事件触发器来实现。在一些特殊情况下，用事件触发器来触发事件比用户的实际操作来触发事件更方便。</p><p>触发事件每种浏览器都有原生的方式，IE支持<code>fireEvent()</code>方法触发事件，标准浏览器都支持<code>dispatchEvent()</code>方法。<br>简单介绍一下<code>fireEvent()</code>方式吧，下面是一段prototype.js的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fireEvent = <span class="function"><span class="keyword">function</span><span class="title">fireEvent</span>(<span class="params">element,event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.createEventObject)&#123;</span><br><span class="line"><span class="comment">// IE浏览器支持fireEvent方法</span></span><br><span class="line"><span class="keyword">var</span> evt = <span class="built_in">document</span>.createEventObject();</span><br><span class="line"><span class="keyword">return</span> element.fireEvent(<span class="string">'on'</span>+event,evt)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 其他标准浏览器使用dispatchEvent方法</span></span><br><span class="line"><span class="keyword">var</span> evt = <span class="built_in">document</span>.createEvent( <span class="string">'HTMLEvents'</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// initEvent接受3个参数：</span></span><br><span class="line"><span class="comment">// 事件类型，是否冒泡，是否阻止浏览器的默认行为</span></span><br><span class="line">        evt.initEvent(event, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> !element.dispatchEvent(evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="dispatchEvent-事件触发器"><a href="#dispatchEvent-事件触发器" class="headerlink" title="dispatchEvent 事件触发器"></a>dispatchEvent 事件触发器</h2><ul><li><p>早期的创建事件的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>); <span class="comment">// 一个参数， 表示事件类型</span></span><br><span class="line">event.initEvent(<span class="string">'build'</span>, <span class="literal">true</span>, <span class="literal">true</span>); <span class="comment">// 三个参数，eventName事件类型、canBubble是否冒泡、preventDefault是否阻止事件的默认操作</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(event) <span class="comment">// 参数为事件对象</span></span><br></pre></td></tr></table></figure></li><li><p>构造函数方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听事件</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="comment">// e.target matches document from above</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(event);</span><br></pre></td></tr></table></figure></li></ul><p>再举个可以给事件传值的例子，可以将触发事件定义在一个方法内:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'mhy'</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> evt = <span class="keyword">new</span> Event(<span class="string">'haha'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="title">handler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> o = e.eventBody</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'addevt'</span>, o)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'evt'</span>, evt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'haha'</span>, handler, <span class="literal">false</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="title">disPatchEvt</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">2evt.eventBody = obj</span><br><span class="line">2<span class="built_in">document</span>.dispatchEvent(evt, obj)</span><br><span class="line">&#125;</span><br><span class="line">disPatchEvt(obj)</span><br></pre></td></tr></table></figure></p><p>以上例子中所传的数据可以是任任意类型的数据，通过这种方法基本可以满足任意标准浏览器环境下通过自定义事件的需求。</p>]]></content><summary type="html">
    
      javascript 浏览器事件，dispatchEvent事件触发器
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/><category term="dispatchEvent" scheme="https://mhynet.cn/tags/dispatchEvent/"/><category term="Event" scheme="https://mhynet.cn/tags/Event/"/></entry><entry><title>window对象之屏幕尺寸相关的属性</title><link href="https://mhynet.cn/window-screen-property.html"/><id>https://mhynet.cn/window-screen-property.html</id><published>2018-03-15T05:12:19.000Z</published><updated>2020-01-09T07:08:53.590Z</updated><content type="html"><![CDATA[<h2 id="window对象中屏幕尺寸相关的属性"><a href="#window对象中屏幕尺寸相关的属性" class="headerlink" title="window对象中屏幕尺寸相关的属性"></a><code>window</code>对象中屏幕尺寸相关的属性</h2><h3 id="window-screenX-和-window-screentY"><a href="#window-screenX-和-window-screentY" class="headerlink" title="window.screenX 和 window.screentY"></a><code>window.screenX</code> 和 <code>window.screentY</code></h3><p>返回浏览器窗口左上角相对于屏幕左上角的（0,0)的水平距离和垂直距离， 单位为像素。<br><a id="more"></a></p><h3 id="window-innerWidth-和-window-innerHeight"><a href="#window-innerWidth-和-window-innerHeight" class="headerlink" title="window.innerWidth 和 window.innerHeight"></a><code>window.innerWidth</code> 和 <code>window.innerHeight</code></h3><p>返回当前浏览器窗口可视部分的宽度和高度, 即“视口”（viewport）, 单位像素。<br>这两个属性包含滚动条的尺寸。<br>当用户放大网页尺寸的时候，这两个属性的值会变小，因为这时网页的像素大小不变，只是每个像素占据的屏幕空间变大了，因为可见部分（视口）就变小了。</p><h3 id="window-outerWidth-和-window-outerHeight"><a href="#window-outerWidth-和-window-outerHeight" class="headerlink" title="window.outerWidth 和 window.outerHeight"></a><code>window.outerWidth</code> 和 <code>window.outerHeight</code></h3><p>返回浏览器窗口的高度和宽度，包括浏览器菜单栏和边框，单位为像素。</p><h3 id="window-pageXOffset-和-window-pageYOffset"><a href="#window-pageXOffset-和-window-pageYOffset" class="headerlink" title="window.pageXOffset 和 window.pageYOffset"></a><code>window.pageXOffset</code> 和 <code>window.pageYOffset</code></h3><p>返回页面的水平和垂直滚动距离， 单位为像素。</p><h2 id="window对象中屏幕滚动相关的方法"><a href="#window对象中屏幕滚动相关的方法" class="headerlink" title="window对象中屏幕滚动相关的方法"></a><code>window</code>对象中屏幕滚动相关的方法</h2><p><code>window</code>对象中屏幕滚动相关的方法最常用的有<code>window.scrollTo(x, y)</code> 和<code>window.scrollBy(x, y)</code>， 单位都是像素。</p><h3 id="window-scrollTo"><a href="#window-scrollTo" class="headerlink" title="window.scrollTo()"></a><code>window.scrollTo()</code></h3><p>该方法用于将网页的指定位置（参数坐标位置），滚动到浏览器的左上角。参数是相对于整张网页的坐标。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="window-scrollBy"><a href="#window-scrollBy" class="headerlink" title="window.scrollBy()"></a><code>window.scrollBy()</code></h3><p>该方法用于将网页滚动指定距离。两个参数分别为向右滚动的距离和项下滚动的距离，如果为负值，则向相反的方向滚动。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollBy(<span class="number">0</span>, <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure></p>]]></content><summary type="html">
    
      &lt;h2 id=&quot;window对象中屏幕尺寸相关的属性&quot;&gt;&lt;a href=&quot;#window对象中屏幕尺寸相关的属性&quot; class=&quot;headerlink&quot; title=&quot;window对象中屏幕尺寸相关的属性&quot;&gt;&lt;/a&gt;&lt;code&gt;window&lt;/code&gt;对象中屏幕尺寸相关的属性&lt;/h2&gt;&lt;h3 id=&quot;window-screenX-和-window-screentY&quot;&gt;&lt;a href=&quot;#window-screenX-和-window-screentY&quot; class=&quot;headerlink&quot; title=&quot;window.screenX 和 window.screentY&quot;&gt;&lt;/a&gt;&lt;code&gt;window.screenX&lt;/code&gt; 和 &lt;code&gt;window.screentY&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;返回浏览器窗口左上角相对于屏幕左上角的（0,0)的水平距离和垂直距离， 单位为像素。&lt;br&gt;
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/><category term="window" scheme="https://mhynet.cn/tags/window/"/></entry><entry><title>ES6之Set和Map</title><link href="https://mhynet.cn/ES6-Set-and-Map.html"/><id>https://mhynet.cn/ES6-Set-and-Map.html</id><published>2018-03-08T07:28:03.000Z</published><updated>2020-01-13T04:05:08.193Z</updated><content type="html"><![CDATA[<p>Set和Map是ES6新增的数据结构, Set类似于数组，Map类似于对象。</p><a id="more"></a><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set的元素可以是任何类型的数据，但是都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set实例。<br>生成Set实例用new操作符。</p><h3 id="生成Set实例"><a href="#生成Set实例" class="headerlink" title="生成Set实例"></a>生成Set实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], &#123;<span class="attr">name</span>:<span class="string">'li'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;];</span><br><span class="line"><span class="keyword">let</span><span class="keyword">set</span> = new Set(arr)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span><span class="keyword">set</span> = new Set();</span><br><span class="line">[1,2,2,3,4,5,5].forEach(e =&gt; <span class="keyword">set</span>.add(e));</span><br><span class="line">console.log(<span class="keyword">set</span>); //Set &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.size); // 5</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span><span class="keyword">set</span> = new Set(obj); //Set &#123;&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">set</span>.add(obj); // Set &#123;&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">set</span>.add(obj); // Set &#123;&#123;&#125;&#125;</span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;); <span class="comment">// Set &#123;&#123;&#125;, &#123;&#125;&#125;</span></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;); <span class="comment">// Set &#123;&#123;&#125;, &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Set的属性和方法"><a href="#Set的属性和方法" class="headerlink" title="Set的属性和方法"></a>Set的属性和方法</h3><h4 id="size属性"><a href="#size属性" class="headerlink" title="size属性"></a>size属性</h4><p>返回Set实例的元素数量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'s'</span>,<span class="string">'s'</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span><span class="keyword">set</span> = new Set(arr); // Set &#123;<span class="string">'s'</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">set</span>.size; // 3</span><br></pre></td></tr></table></figure></p><p>#### add(value)</p><p>add() 方法用于向Set的末尾添加元素，可以添加任何类型的数据(包括Set类型)。如果set中有该元素，则不添加；<br>添加某个值，返回 Set 结构本身。<br>例子见上面。<br>链式写法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span><span class="built_in">Set</span>()</span><br><span class="line">  .add(<span class="number">3</span>)</span><br><span class="line">  .add(<span class="number">2</span>)</span><br><span class="line">  .add(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h4 id="delete-value"><a href="#delete-value" class="headerlink" title="delete(value)"></a>delete(value)</h4><p>delete方法用于删除Set实例中的元素，删除的元素为传入的参数。<br>返回值为布尔值， 如果实例中有该参数值，删除并返回true，否则返回false.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'s'</span>,<span class="string">'s'</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span><span class="keyword">set</span> = new Set(arr); // Set &#123;<span class="string">'s'</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">set</span>.delete('s'); // true</span><br><span class="line"><span class="keyword">set</span>.delete('s'); // false</span><br></pre></td></tr></table></figure></p><h4 id="has-value"><a href="#has-value" class="headerlink" title="has(value)"></a>has(value)</h4><p>has方法用来检查set实例中是否包含某个值， 如果有则返回true, 否则返回false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'s'</span>,<span class="string">'s'</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span><span class="keyword">set</span> = new Set(arr); // Set &#123;<span class="string">'s'</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">set</span>.has('s'); //true</span><br><span class="line"><span class="keyword">set</span>.delete('s'); // true</span><br><span class="line"><span class="keyword">set</span>.has('s'); //false</span><br></pre></td></tr></table></figure></p><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>clear方法用于清空Set。没有返回值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span><span class="keyword">set</span> = new Set([1,2,3,4,5]);</span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set &#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Set-的遍历方法"><a href="#Set-的遍历方法" class="headerlink" title="Set 的遍历方法"></a>Set 的遍历方法</h3><p>Set有四个遍历方法。</p><h4 id="keys-、values-和-enttries"><a href="#keys-、values-和-enttries" class="headerlink" title="keys()、values()和 enttries()"></a>keys()、values()和 enttries()</h4><p>keys方法、values方法、entries方法返回的都是遍历器对象。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let item of <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span><span class="keyword">set</span>.values()) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span><span class="keyword">set</span>.entries()) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></table></figure></p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。<br>这意味着，可以省略values方法，直接用for…of循环遍历 Set。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span><span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">for (let x of <span class="keyword">set</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure></p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，<strong>没有返回值</strong>。<br>forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="keyword">set</span> = new Set([1,2,3,4,5,5,6,6]);</span><br><span class="line"><span class="keyword">set</span>.forEach(item =&gt; console.log(item) )</span><br><span class="line">console.log(<span class="keyword">set</span>)</span><br></pre></td></tr></table></figure></p><h3 id="遍历器的应用"><a href="#遍历器的应用" class="headerlink" title="遍历器的应用"></a>遍历器的应用</h3><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><p>数组去重的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">'2'</span>,<span class="string">'s'</span>,<span class="string">'s'</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr)]);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span><span class="built_in">Set</span>(arr));</span><br></pre></td></tr></table></figure></p><h4 id="数组的map和filter方法也可以间接用于-Set"><a href="#数组的map和filter方法也可以间接用于-Set" class="headerlink" title="数组的map和filter方法也可以间接用于 Set"></a>数组的map和filter方法也可以间接用于 Set</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的map()</span></span><br><span class="line"><span class="keyword">let</span><span class="keyword">set</span> = new Set([1,2,3,4,5,5,6,6,7]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(item =&gt; `$&#123;item&#125;&lt;----&gt;$&#123;item * <span class="number">2</span>&#125;<span class="string">`))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//数组的filter</span></span><br><span class="line"><span class="string">let set = new Set([1, 2, &#123;name: 'li', age: 22&#125;, &#123;name: 'wang', age: 22&#125;, &#123;name: 'li', age: 24&#125;]);</span></span><br><span class="line"><span class="string">let s = new Set([...set].filter(item =&gt;  item instanceof Object &amp;&amp; item.age == 22 ))</span></span><br></pre></td></tr></table></figure><h4 id="实现并集（Union）、交集（Intersect）和差集（Difference"><a href="#实现并集（Union）、交集（Intersect）和差集（Difference" class="headerlink" title="实现并集（Union）、交集（Intersect）和差集（Difference)"></a>实现并集（Union）、交集（Intersect）和差集（Difference)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span><span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span><span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集 union</span></span><br><span class="line"><span class="keyword">let</span> nuion = <span class="keyword">new</span><span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span><span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">item</span> =&gt;</span> b.has(item)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span><span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">item</span> =&gt;</span> !b.has(item)));</span><br></pre></td></tr></table></figure><h4 id="直接在遍历操作中改变原来的-Set-结构"><a href="#直接在遍历操作中改变原来的-Set-结构" class="headerlink" title="直接在遍历操作中改变原来的 Set 结构"></a>直接在遍历操作中改变原来的 Set 结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span><span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set([...<span class="keyword">set</span>].map(val =&gt; val * 2));</span><br><span class="line">// <span class="keyword">set</span>的值是2, 4, 6</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">let <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"><span class="keyword">set</span> = new Set(Array.from(<span class="keyword">set</span>, val =&gt; val * 2));</span><br><span class="line">// <span class="keyword">set</span>的值是2, 4, 6</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map和对象类似，都是存储的键值对，不同之处在于对象的键只能是字符串，而Map的键可以为任意类型的数据。</p><h3 id="生成Map实例"><a href="#生成Map实例" class="headerlink" title="生成Map实例"></a>生成Map实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span><span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'name'</span>, <span class="string">'lili'</span>],</span><br><span class="line">    [<span class="string">'age'</span>, <span class="number">22</span>],</span><br><span class="line">    [<span class="string">'sex'</span>, <span class="string">'male'</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="Map的属性和操作方法"><a href="#Map的属性和操作方法" class="headerlink" title="Map的属性和操作方法"></a>Map的属性和操作方法</h3><h4 id="Map的属性size"><a href="#Map的属性size" class="headerlink" title="Map的属性size"></a>Map的属性size</h4><p>Map的size属性和Set的size属性类似，返回Map结构的成员总数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.size; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><h4 id="set-key-value"><a href="#set-key-value" class="headerlink" title="set(key, value)"></a>set(key, value)</h4><p>Map的set()方法用于向Map实例中添加新成员，该方法有两个参数，分别为Map实例的键和值。如果键key已存在，则更新值value。返回Map结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span><span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'name'</span>, <span class="string">'liu'</span>); <span class="comment">// Map &#123;'name', 'liu'&#125;</span></span><br></pre></td></tr></table></figure></p><p>可以采用链式写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span><span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br></pre></td></tr></table></figure></p><h4 id="get-key"><a href="#get-key" class="headerlink" title="get(key)"></a>get(key)</h4><p>Map的get()方法用于查询Map实例的成员， 参数为键, 返回该键key所对应的值value。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span><span class="built_in">Map</span>([<span class="string">'name'</span>, <span class="string">'lili'</span>]);</span><br><span class="line">m.get(<span class="string">'name'</span>); <span class="comment">// 'lili'</span></span><br><span class="line">m.get(<span class="string">'age'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h4 id="has-key"><a href="#has-key" class="headerlink" title="has(key)"></a>has(key)</h4><p>Map结构的has()方法用来判断某个键是否在该Map结构中， 返回布尔值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span><span class="built_in">Map</span>(<span class="string">'name'</span>, <span class="string">'wang'</span>);</span><br><span class="line">m.has(<span class="string">'name'</span>); <span class="comment">// ture</span></span><br><span class="line">m.has(<span class="string">'sex'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h4 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h4><p>同Set的clear()方法， 用于清空所有成员， 没有返回值。</p><h4 id="delete-key"><a href="#delete-key" class="headerlink" title="delete(key)"></a>delete(key)</h4><p>删除某个键， 删除成功返回true, 否则返回false。</p><h3 id="Map的遍历方法"><a href="#Map的遍历方法" class="headerlink" title="Map的遍历方法"></a>Map的遍历方法</h3><p>Map的遍历方法有keys(), values(), entries(), forEach().<br>Map 的遍历顺序就是插入顺序。<br>与for…of循环组合使用很好用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span><span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'name'</span>, <span class="string">'lili'</span>],</span><br><span class="line">    [<span class="string">'age'</span>, <span class="number">22</span>],</span><br><span class="line">    [<span class="string">'sex'</span>, <span class="string">'male'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用m.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> m) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p><h3 id="Map-转换为其他数据结构"><a href="#Map-转换为其他数据结构" class="headerlink" title="Map 转换为其他数据结构"></a>Map 转换为其他数据结构</h3><h4 id="Map-lt-gt-数组"><a href="#Map-lt-gt-数组" class="headerlink" title="Map&lt;==&gt;数组"></a>Map&lt;==&gt;数组</h4><p>转为数组结构，可以用展开符：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组转为Map</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span><span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map转为数组</span></span><br><span class="line">[...map.keys()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.values()]</span><br><span class="line"><span class="comment">// ['one', 'two', 'three']</span></span><br><span class="line"></span><br><span class="line">[...map.entries()]</span><br><span class="line"><span class="comment">// [[1,'one'], [2, 'two'], [3, 'three']]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br></pre></td></tr></table></figure></p><h3 id="Map-lt-gt-Object"><a href="#Map-lt-gt-Object" class="headerlink" title="Map&lt;==&gt;Object"></a>Map&lt;==&gt;Object</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="title">strMapToObj</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 该方法创建的对象没有原型， 参数为null</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [k,v] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">        obj[k] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Map的键为字符串可以无损转为对象，如果不是字符串则转化为字符串，然后转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="title">strObjToMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span><span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span><span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        strMap.set(k, obj[k]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Map-lt-gt-JSON"><a href="#Map-lt-gt-JSON" class="headerlink" title="Map &lt;==&gt; JSON"></a>Map &lt;==&gt; JSON</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON -&gt; Map</span></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="title">JSONToMap</span>(<span class="params">str</span>)) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strObjToMap(<span class="built_in">JSON</span>.parse(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map -&gt; JSON</span></span><br><span class="line"><span class="comment">//键名为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="title">strMapToJSON</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span><span class="built_in">JSON</span>.stringify(strMapToObj(strMap))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名为非字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span><span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content><summary type="html">
    
      &lt;p&gt;Set和Map是ES6新增的数据结构, Set类似于数组，Map类似于对象。&lt;/p&gt;
    
    </summary><category term="前端" scheme="https://mhynet.cn/categories/%E5%89%8D%E7%AB%AF/"/><category term="javascript" scheme="https://mhynet.cn/tags/javascript/"/></entry><entry><title>MySQL学习笔记</title><link href="https://mhynet.cn/MySQL-notes.html"/><id>https://mhynet.cn/MySQL-notes.html</id><published>2018-03-03T03:35:30.000Z</published><updated>2020-01-13T04:05:08.194Z</updated><content type="html"><![CDATA[<p>MySQL数据库学习笔记。<br>MySQL环境搭建可查阅资料，此处不细说。默认已搭建好MySQL环境。</p><a id="more"></a><h2 id="1-授权、登录相关"><a href="#1-授权、登录相关" class="headerlink" title="1.授权、登录相关"></a>1.授权、登录相关</h2><h3 id="启动MySQL服务常用命令"><a href="#启动MySQL服务常用命令" class="headerlink" title="启动MySQL服务常用命令:"></a>启动MySQL服务常用命令:</h3><ul><li>启动mysql服务：sudo start mysql 或者 sudo service mysql start</li><li>停止mysql服务：sudo stop mysql 或者 sudo service mysql stop</li><li>重启mysql服务： sudo restart mysql 或者 sudo service mysql restart</li><li>查看mysql数据库的版本号：mysql -V</li><li>启动mysqld服务: sudo /etc/init.d/mysql start</li><li>停止mysqld服务: sudo /etc/init.d/mysql stop</li><li>启动mysqld服务: sudo /etc/init.d/mysql restart</li></ul><h3 id="以root用户登录MySQL"><a href="#以root用户登录MySQL" class="headerlink" title="以root用户登录MySQL"></a>以root用户登录MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>然后输入密码，登录成功后输入以下命令，创建个人用户：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user mhy inentified by <span class="string">'123'</span>;</span><br></pre></td></tr></table></figure></p><p>用户名为: <code>mhy</code>, 密码为: <code>123</code>。</p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>创建用户后需要进行授权， 授权命令格式:</p><p><code>grant [privilegesCode] on [dbName.tableName] to [username@host] identified by [&quot;password&quot;];</code></p><p><code>[]</code>内的项需要根据自己的情况选择。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on <span class="built_in">test</span>.* to mhy@localhost identified by <span class="string">'123'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><strong>privilegesCode</strong>代表授予的权限，常用的权限类型有：</p><ul><li><code>all privileges</code> 所有权限</li><li><code>select</code> 读取权限</li><li><code>delete</code> 删除权限</li><li><code>update</code> 更新权限</li><li><code>create</code> 创建权限</li><li><code>drop</code> 删除数据库、数据表权限</li></ul><p><strong>dbName.tableName</strong>表示授予权限的数据库和数据表，常用的类型有以下几个：</p><ul><li><code>.</code> 授予该数据库服务器上所有的数据库的权限</li><li><code>dbName.*</code> 授予dbName数据库上所有数据表的权限</li><li><code>dbName.dbTable</code> 授予dbName数据库的dbTable数据表的权限</li></ul><p><strong>username@host</strong>表示授予权限的用户及允许该用户登录的IP地址。其中Host有以下几种选择：</p><ul><li><code>localhost</code> 只允许本地登录，不允许远程登录。</li><li><code>%</code> 允许在除本机之外的任何一台机器远程登录。</li><li><code>192.168.33.21</code> 具体的IP地址，表示允许该用户从特定的IP登录。</li></ul><p><strong>password</strong><br> 指定该用户登录时的密码。</p><p><strong>flush privileges</strong><br> 表示刷新权限变更。</p><p>运行以下命令可以删除用户：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user zhangsan@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure></p><p>查看用户<code>mhy</code>的权限用以下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants <span class="keyword">for</span><span class="string">'mhy'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="2-创建、修改和删除数据库-database"><a href="#2-创建、修改和删除数据库-database" class="headerlink" title="2.创建、修改和删除数据库 database"></a>2.创建、修改和删除数据库 database</h2><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>创建数据库命令, dbName为数据库名字：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database dbName;</span><br></pre></td></tr></table></figure></p><h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database dbName;</span><br></pre></td></tr></table></figure><h3 id="查看所有数据库："><a href="#查看所有数据库：" class="headerlink" title="查看所有数据库："></a>查看所有数据库：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><h3 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h3><p>修改数据表更多的是修改数据表的结构。使用<code>alter table</code>语句。</p><ul><li><p>删除字段用 <code>drop</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName drop 字段名;</span><br></pre></td></tr></table></figure></li><li><p>添加字段用 <code>add</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName add 字段名 数据类型 [可选项];</span><br></pre></td></tr></table></figure></li><li><p>修改字段名称和类型<br>有两种方式：<code>modify</code>和<code>change</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName modify 字段名 [char(20)]</span><br></pre></td></tr></table></figure></li></ul><p>可选项中可以是数据类型。</p><p><code>change</code>语句除了重新定义字段，还可以重命名字段：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName change 原字段名 新字段名 char(10);</span><br></pre></td></tr></table></figure></p><ul><li>修改数据表名<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName rename to newTableName;</span><br></pre></td></tr></table></figure></li></ul><p>还可以修改字段的默认值。</p><p>如果引擎是innodb的话，数据库名称不能修改，其他引擎的数据库重命名有数据丢失的风险，所以在创建数据库的时候命名切勿草率。</p><h2 id="3-创建和修改数据表-table"><a href="#3-创建和修改数据表-table" class="headerlink" title="3.创建和修改数据表 table"></a>3.创建和修改数据表 table</h2><p>创建数据表之前需要选择数据库，使用以下命令选择数据库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use dbName;</span><br></pre></td></tr></table></figure></p><p>选择数据库之后就可以创建数据表了，创建数据表的时候需要填写的有表名、表的字段名称、每个字段的数据类型，还有其他可选项主键（PRIMARY KEY）、外键（）、自动增长（AUTO_INCREMENT）、默认值（DEFAULT）、是否允许为空（NOT NULL）等。ENGINE=InnoDB设置引擎，引擎一般会在配置文件中设置，如果要建的数据表的引擎和配置文件不一样需要在此处指明。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table tableName (</span><br><span class="line">  字段1 数据类型 [其他可选项]，</span><br><span class="line">  字段2 数据类型 [其他可选项]，</span><br><span class="line">  ...</span><br><span class="line">) [ENGINE=InnoDB DEFAULT CHARSET=utf8];</span><br></pre></td></tr></table></figure></p><p><code>[]</code>内的项为可选项，最后面的<code>ENGING DEFAULT CHARSET</code>也是可选项，一般都会在配置文件中设置，不需要在创建表时进行设置。<br>创建数据表的具体实例稍后讲了mysql的数据类型和约束后在将。<br>查看数据表：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables [from dbName];</span><br></pre></td></tr></table></figure></p><p>查看表结构：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show columns from tableName;</span><br></pre></td></tr></table></figure></p><p>数据表删除的三种语句drop、delete和truncate的异同：</p><p><strong>相同点</strong>：</p><ol><li>truncate和delete只删除表数据保留表结构；</li><li>truncate和不带where子句的delete，以及drop都能删除表内的数据.</li></ol><p><strong>不同点</strong>：</p><ol><li>drop整个删除数据表，速度最快；</li><li>delete删除数据表中的数据，可以加入条件语句where，需要先查询符合条件的数据然后删除，如果不加条件语句，则清空所有数据;</li><li>truncate清空表内数据，但不删除数据表结构。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除数据表（结构、属性、索引）</span></span><br><span class="line">drop table tableName;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某一行</span></span><br><span class="line">delete from tableName  Where volumnName=values;</span><br><span class="line"><span class="comment"># 删除所有数据</span></span><br><span class="line">delete from tableName；</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">delete * from tableName</span><br><span class="line"></span><br><span class="line"><span class="comment">#清空数据</span></span><br><span class="line">truncate table tableName;</span><br></pre></td></tr></table></figure></li></ol><p>对于有主外键关系的表，不能使用truncate而应该使用不带where子句的delete语句，由于truncate不记录在日志中，不能够激活触发器。</p><h2 id="4-SQL数据类型"><a href="#4-SQL数据类型" class="headerlink" title="4.SQL数据类型"></a>4.SQL数据类型</h2><p>SQL语句常见的数据类型有字符串、数字和日期三大类。</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p><img style="width: 70%" src="https://wicdn.xiaohongchun.com/xhc-plat/1520585223512_53Wbnarmmc.png"></p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p><img style="width: 70%" src="https://wicdn.xiaohongchun.com/xhc-plat/1520585223512_yJtAzAQjAC.png"></p><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><p><img style="width: 70%" src="https://wicdn.xiaohongchun.com/xhc-plat/1520585223509_bknXEkz6P5.png"></p><p>合理选用数据类型对于提高MySQL性能具有非常重要的意义，这一块可以参考《高性能MYSQL》进行学习。</p><h2 id="5-约束"><a href="#5-约束" class="headerlink" title="5.约束"></a>5.约束</h2><p>约束主要完成对数据的检验和限制，从而保证数据库的完整性。常见的约束有以下几种：</p><ul><li>外键约束(foreign key)</li><li>主键约束(primary key)</li><li>唯一值约束(unique)</li><li>自增长约束(auto_increment)</li><li>默认值约束(default)</li><li>非空约束(not null)</li></ul><h3 id="主键约束（primary-key"><a href="#主键约束（primary-key" class="headerlink" title="主键约束（primary key)"></a>主键约束（primary key)</h3><p>主键约束列不能重复，任意两行的主键值都不能相同，也不能为空值。<br>一般每一张数据表都有一个约束，通常为id，最好不要把业务字段设为主键，因为可能会有重复的数据。<br>创建数据表的时候在需要创建主键约束的字段后面的可选项位置加入 <code>primary key</code> 即可。<br>拥有主键约束的表插入数据时，拥有主键约束的字段的数据重复或为空时会报错。<br>常见的操作：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据表时加入主键的两种方法</span></span><br><span class="line">create table tableName (</span><br><span class="line">  字段名1 数据类型 primary key,</span><br><span class="line">  字段名2 数据类型</span><br><span class="line">);</span><br><span class="line">create table tableName (</span><br><span class="line">  字段名1 数据类型,</span><br><span class="line">  字段名2 数据类型,</span><br><span class="line">  constraint 约束名 primary key(字段名1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加主键 列名columnName如果为多个时建立联合主键</span></span><br><span class="line">alter table tableName add primary key(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除主键约束</span></span><br><span class="line">alter table tableName drop primary key;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改列为主键</span></span><br><span class="line">alter table tableName modify 字段名 数据类型 primary key;</span><br></pre></td></tr></table></figure></p><p><strong>联合主键</strong>:联合多个列建立联合主键。</p><h3 id="外键约束（foreign-key）"><a href="#外键约束（foreign-key）" class="headerlink" title="外键约束（foreign key）"></a>外键约束（foreign key）</h3><p>外键约束的作用是建立两张表之间的联系，保持数据的一致性。表的外键可以是另一张表的主键或唯一索引或唯一约束。<br>外键可以有重复的, 可以是空值。实现一对一或一对多关系。<br>创建外键约束实例：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建父表</span></span><br><span class="line">create table fatherTable(</span><br><span class="line">  id int primary key,</span><br><span class="line">  title varchar(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子表，建立外键有两种方式</span></span><br><span class="line"><span class="comment"># 第一种：添加关键字</span></span><br><span class="line">create table sonTable(</span><br><span class="line">  id int auto_increment,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  constraint son_id primary key(id),</span><br><span class="line">  father_id int references fatherTable(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment"># 第二种： 额外声明 son_id 为主键的名字，fa_tab_id为外键的名字</span></span><br><span class="line">create table sonTable(</span><br><span class="line">  id int auto_increment,</span><br><span class="line">  name varchar(20),</span><br><span class="line">  constraint son_id primary key(id),</span><br><span class="line">  father_id int,</span><br><span class="line">  constraint fa_tab_id foreign key(father_id) reference fatherTable(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>加外键约束的条件</strong>：</p><ul><li>父表和子表必须使用相同的存储引擎， 数据表的存储引擎只能为InnoDB,default-storage-engine-INNODB</li><li>外键列和参照列必须具有相似的数据类型，数字的长度或是有符号位必须相同，而字符 的长度可以不同</li><li>外键列和参照列必须创建索引，如果外键列不存在索引的话，MySQL将自动创建索引。</li></ul><p>设定参照列:FOREIGN KEY(id) PEFERENCES provinces(id)<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除外键约束</span></span><br><span class="line">alter table tableName drop foreign key 外键约束名;</span><br><span class="line">(创建外键的方法没有指定约束名称，系统会默认给外键约束分配外键约束名称，命名为student_ibfk_n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加外键约束</span></span><br><span class="line">alter table tableName add foreign key 列名 references 父表(对应列名);</span><br></pre></td></tr></table></figure></p><h3 id="唯一约束（unique-key）"><a href="#唯一约束（unique-key）" class="headerlink" title="唯一约束（unique key）"></a>唯一约束（unique key）</h3><p><code>unique key</code>的用途：主要是用来防止数据插入的时候重复。<br>创建数据表时在字段后面加入<code>unique key</code>即可建立唯一约束。<br>也可以单独设置：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName modify columnName char(20) unique key;</span><br></pre></td></tr></table></figure></p><h2 id="6-插入和修改记录"><a href="#6-插入和修改记录" class="headerlink" title="6.插入和修改记录"></a>6.插入和修改记录</h2><p>建立好数据表之后就可以插入数据了。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入数据使用<code>insert into</code>语句，具体如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into tableName (字段1, 字段2, 字段3,...字段n) values (值1, 值2, 值3, ...值n);</span><br><span class="line"><span class="comment"># 如果数据为字符串，必须加引号。</span></span><br></pre></td></tr></table></figure></p><p>注意：以上语句插入数据的时候必须要保证一致性，即前后必须一一对应。<br>还有一种方式：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into tableName (字段1=值1, 字段2=值2, ...);</span><br></pre></td></tr></table></figure></p><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>update set命令用来修改表中的数据。<br>update set命令格式：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tableName <span class="built_in">set</span> 字段=新值, ... <span class="built_in">where</span> 条件;</span><br></pre></td></tr></table></figure></p><h2 id="7-查询"><a href="#7-查询" class="headerlink" title="7.查询"></a>7.查询</h2><p>数据查询使用<code>select</code>语句。<br><code>select 查询项 from tableName [where 条件]</code></p>]]></content><summary type="html">
    
      MySQL数据库初级应用指南。
    
    </summary><category term="数据库" scheme="https://mhynet.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/><category term="mysql" scheme="https://mhynet.cn/tags/mysql/"/><category term="数据库" scheme="https://mhynet.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/></entry></feed>
