---
title: 对象的方法汇总
date: 2018-02-17 15:25:27
category: 技术
tags: [Object]
---
Javascript语言中，对象Object是该语言重要的数据结构之一，掌握对象的属性和方法是学好该语言的必要条件。

## Object构造函数的属性
### Object.length
值为1。
### Object.prototype
`Object.prototype`属性表示`Object`的原型对象
可以为所有 Object 类型的对象添加属性
几乎所有的 JavaScript 对象都是 Object 的实例；一个典型的对象继承了Object.prototype的属性（包括方法），尽管这些属性可能被遮蔽（也被称为覆盖）。然而，一个Object可能是故意创建的，这是不确定的（例如通过Object.create(null)），或者它可能被改变，所以这不再是准确的（例如Object.setPrototypeOf）。

改变Object原型，会通过原型链，而改变所有对象；除非这些属性和方法被其他对原型链更里层的改动所覆盖。这提供了一个非常强大的、但有潜在危险的机制，来覆盖或扩展对象行为。

## Object构造函数的方法:
### Object.assign()
方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
#### 1.语法：`Object.assign(target, ...sources)`

如果目标对象的属性和源对象具有相同的键值，则后来的源的属性将覆盖早先的属性。
`Object.assign` 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。
该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。

String类型和 Symbol 类型的属性都会被拷贝。
注意，Object.assign 不会跳过那些值为 null 或 undefined 的源对象。

针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。
#### 2.复制对象 & 合并对象
```js
var obj = {name: 'mhy',city: 'beijing'};
let obj1 = Object.assign({}, obj, {city: 'tianjin', age: 22}); //{name: "mhy", city: "tianjin", age: 22}
```
#### 3.深拷贝问题
针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。
对象的深拷贝可以使用`JSON.parse(JSON.stringify(obj))`实现， 但是该方法在拷贝时会忽略方法和原型。还有一种方式是递归。jQuery 的extend方法也可以实现深拷贝`$.extend(true, {}, ...)`

```js
function test() {
  'use strict';

  let obj1 = { a: 0 , b: { c: 0}};
  let obj2 = Object.assign({}, obj1);
  console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}
  
  obj1.a = 1;
  console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
  console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}
  
  obj2.a = 2;
  console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
  console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}
  
  obj2.b.c = 3;
  console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}
  console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}
  
  // 深拷贝
  obj1 = { a: 0 , b: { c: 0}};
  let obj3 = JSON.parse(JSON.stringify(obj1));
  obj1.a = 4;
  obj1.b.c = 4;
  console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
}

test();
```
#### 4.拷贝 symbol 类型的属性
```js
var o1 = { a: 1 };
var o2 = { [Symbol('foo')]: 2 };

var obj = Object.assign({}, o1, o2);
console.log(obj); // { a : 1, [Symbol("foo")]: 2 }
Object.getOwnPropertySymbols(obj); // [Symbol(foo)]
```

#### 5.继承属性和不可枚举属性是不能拷贝的
```js
var obj = Object.create({foo: 1}, { // foo 是个继承属性。
    bar: {
        value: 2  // bar 是个不可枚举属性。
    },
    baz: {
        value: 3,
        enumerable: true  // baz 是个自身可枚举属性。
    }
});

var copy = Object.assign({}, obj);
console.log(copy); // { baz: 3 }
```

### Object.create()
使用指定的原型对象和属性创建一个新对象。 

#### 1.语法: `Object.create(proto[, propertiesObject])`
#### 2.用 Object.create实现类式继承
```js
// Shape - 父类(superclass)
function Shape() {
  this.x = 0;
  this.y = 0;
}

// 父类的方法
Shape.prototype.move = function(x, y) {
  this.x += x;
  this.y += y;
  console.info('Shape moved.');
};

// Rectangle - 子类(subclass)
function Rectangle() {
  Shape.call(this); // call super constructor.
}

// 子类续承父类
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

// 因为使用“.prototype =...”后,constructor会改变为“=...”的那个
// constructor，所以要重新指定.constructor 为自身。
```
```js
var rect = new Rectangle();

console.log('Is rect an instance of Rectangle?',
  rect instanceof Rectangle); // true
console.log('Is rect an instance of Shape?',
  rect instanceof Shape); // true
rect.move(1, 1); // Outputs, 'Shape moved.'
```
```js
function Father() {
	this.city = 'beijing';
	this.lastName = 'ma';

}
Father.prototype.where = function () {
	console.log("where? ", this.city)
}

function Son() {
	Father.call(this);
}

Son.prototype = Object.create(Father.prototype);
Son.prototype.constructor = Son

let s = new Son()
s.city;//
s.lastName; //
s.where(); //
```
#### 3.使用混入模式继承到多个对象
```js
function MyClass() {
     SuperClass.call(this);
     OtherSuperClass.call(this);
}

// 继承一个类
MyClass.prototype = Object.create(SuperClass.prototype);
// 混合其它
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// 重新指定constructor
MyClass.prototype.constructor = MyClass;

MyClass.prototype.myMethod = function() {
     // do a thing
};
```

### Object.defineProperty()
直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
#### 1.语法：
`Object.defineProperty(obj, prop, descriptor)`
#### 2.参数
- 2.1 obj
要在其上定义属性的对象。
prop
要定义或修改的属性的名称。
- 2.2 descriptor
将被定义或修改的属性描述符。

在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。


### Object.defineProperties()
在一个对象上定义新的属性或修改现有属性，并返回该对象。
#### 1.语法： 
`Object.defineProperties(obj, props)`
#### 2.参数
- 2.1 **obj**

在其上定义或修改属性的对象。

- 2.2 **props**

>要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：
   
- configurable
true 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。
默认为 false

- enumerable
true 当且仅当在枚举相应对象上的属性时该属性显现。
默认为 false
- value
与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。
默认为 undefined.
writable
true当且仅当与该属性相关联的值可以用assignment operator改变时。
默认为 false
- get
作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。
默认为 undefined
- set
作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。
默认为 undefined
返回值
传递给函数的对象。

`Object.defineProperties`本质上定义了obj 对象上props的可枚举属性相对应的所有属性。
```js
var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
  // etc. etc.
});
```

### Object.entries()
返回给定对象自身可枚举属性的[key, value]数组。
### Object.freeze()
冻结对象：其他代码不能删除或更改任何属性。
### Object.getOwnPropertyDescriptor()
返回对象指定的属性配置。
### Object.getOwnPropertyNames()
返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。
### Object.getOwnPropertySymbols()
返回一个数组，它包含了指定对象自身所有的符号属性。
### Object.getPrototypeOf()
返回指定对象的原型对象。
### Object.is() 
比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。
### Object.isExtensible()
判断对象是否可扩展。
### Object.isFrozen()
判断对象是否已经冻结。
### Object.isSealed()
判断对象是否已经密封。
### Object.keys()
返回一个包含所有给定对象自身可枚举属性名称的数组。
### Object.preventExtensions()
防止对象的任何扩展。
### Object.seal()
防止其他代码删除对象的属性。
### Object.setPrototypeOf()
设置对象的原型（即内部[[Prototype]]属性）。
### Object.values()
返回给定对象自身可枚举值的数组。


## 3.Object 实例和Object 原型对象:
JavaScript中的所有对象都来自Object；所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖。例如，其他构造函数的原型将覆盖constructor属性并提供自己的toString()方法。Object原型对象的更改将传播到所有对象，除非受到这些更改的属性和方法将沿原型链进一步覆盖。

### Object.prototype.__defineGetter__()  
关联一个函数到一个属性。访问该函数时，执行该函数并返回其返回值。
### Object.prototype.__defineSetter__()  
关联一个函数到一个属性。设置该函数时，执行该修改属性的函数。
### Object.prototype.__lookupGetter__()  
返回使用 __defineGetter__ 定义的方法函数 。
### Object.prototype.__lookupSetter__()  
返回使用 __defineSetter__ 定义的方法函数。
### Object.prototype.hasOwnProperty()
返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。
### Object.prototype.isPrototypeOf()
返回一个布尔值，表示指定的对象是否在本对象的原型链中。
### Object.prototype.propertyIsEnumerable()
判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。
### Object.prototype.toSource() 
返回字符串表示此对象的源代码形式，可以使用此字符串生成一个新的相同的对象。
### Object.prototype.toLocaleString()
直接调用 toString()方法。
### Object.prototype.toString()
返回对象的字符串表示。
### Object.prototype.unwatch() 
移除对象某个属性的监听。
### Object.prototype.valueOf()
返回指定对象的原始值。
### Object.prototype.watch() 
给对象的某个属性增加监听。
