---
title: 前端设计模式
date: 2017-12-09 09:27:02
category: javascript
tags: [设计模式]
---
设计模式对于提高开发效率具有非常重要的作用，根据不同的需求采用合适的设计模式可以事半功倍。

## 1.常见设计模式

- 构造函数模式
- 工厂模式
- 模块模式
- **混合模式**
- **单例模式**
- **发布订阅模式**

## 2.构造函数模式 Constructor
构造函数模式，最简单的方式，实现如下：
```js
function Person(name, age){
    this.name = name;
    this.age = age;
}
Person.prototype.sayName = function(){
    return this.name;
};
```
调用
```js
var student = new Person("mhy", 24);
student.sayName(); // "mhy"
console.log(student);
```
将方法定义到原型上，可以在每次生成`Person`实例的时候实现继承，使`this`指向该对象而不是`window`。
```js
function Person(name, age {
    this.name = name;
    this.age = age;
    this.sayName = function() {
        return this.name;
    }
})
// 调用
let teacher = new Person('wang', 28);
teacher.sayName();
let student = new Person('li', 18);
student.sayName(); 
```
上面的实现方法将`sayName`实现在this上，每次调用的时候都会定义一个`sayName`方法，如果有很多实例的话会占用更多内存。

调用的时候是否使用`new`关键词？ 
```js
// 作为函数调用
var p = Person('m', 12);
console.log(typeof p); // "undefined"
console.log(window.sayName()); // "m"

// 使用 new 关键词
var s = new Person("w", 23);
console.log(typeof s); // "object"
console.log(s.sayName()); // "w"
``` 
可以强制使用`new`关键词, 在定义`Person`的时候加入判断，如果没有使用`new`操作符则在内部使用`new`操作符生成实例
```js
function Person(name, age) {
    if (!(this instanceof Person)) {
        return new Person(name, age);
    }
    // ...
}
```

## 3.工厂模式 Factory
工厂模式可以定义根据参数不同的子类，提供了有个创建对象的接口。
```js
function createPerson(opts){
    var person = {
        name: opts.name || 'mhy',
        sayName: function(){
            console.log(this.name)
        }
    };
    return person;
}
var p1 = createPerson({name : 'mhy'});
var p2 = createPerson({name : '小李'});

// 工厂模式，每次使用都要new一个实例
```
根据不同的子类类型，需要定义对应的子类。[汤姆大叔](http://www.cnblogs.com/TomXu/archive/2012/02/23/2353389.html)的讲解非常详细，想深入研究可以参考。

以下几种情景下工厂模式特别有用：

1.对象的构建十分复杂；

2.需要依赖具体环境创建不同实例；

3.处理大量具有相同属性的小对象；

什么时候不该用工厂模式？
不滥用运用工厂模式，有时候仅仅只是给代码增加了不必要的复杂度，同时使得测试难以运行下去。


## 4.模块模式 
```js
var Person = (function(){
    var name = 'mhy';
    function sayName(){
        console.log(name);
    }
    return {
        name: name,
        sayName: sayName
    }
})()
```
闭包方式实现一个模块
```js
var Person = (function(){
    var name = 'mhy';
    return {
        changeName: function(newName){
            name = newName;
        },
        sayName: function(){
            console.log(name);
        }
    };
})()
Person.sayName();
Person.changeName('mhy');
Person.sayName();
```


## 5.混合模式
使用继承的方式实现一个模块
```js
var Person = function(name, age){
    this.name = name;
    this.age = age;
};
Person.prototype.sayName = function(){
    console.log(this.name);
}

var Student = function(name, age, score){
    Person.call(this, name, age);
    //调用call方法，等价于 <==> this.name = name; this.age = age;
    this.score = score;
} ;
//Student.prototype = Object.create(Person.prototype);
Student.prototype = create(Person.prototype);

function create(parentObj){
    function F(){};
    F.prototype = parentObj;
    return new F();
};

Student.prototype.sayScore = function(){
    console.log(this.score);
}
var student = new Student("mhy", 24, 98);
console.log(student);

```

## 6.单例模式
```js
var People = (function(){
    var instance;
    function init(name){
        //define private methods and properties
        //do something
        return {
            //define public methods and properties
            name: name
        };
    } //词法作用域
    return {
        createPeople: function(name){
            if(!instance){
                instance = init(name);
            }
            return instance;
        }
    };
})()

var obj1 = People.createPeople('mhy'); // {name: 'mhy'}
var obj2 = People.createPeople('小李子'); //{name: 'mhy'}

//初始化一次后，之后每次调用，输出的值为第一次初始的值
// 单例模式， 常用于对话框  dialog
```

## 7.发布订阅模式
发布订阅模式， 处理异步模式非常便利
```js
var EventCenter = (function(){
    var events = {};
    function on(evt, handler){
        events[evt] = events[evt] || [];
        events[evt].push({
            handler: handler
        });
    }

    function fire(evt, args){
        if(!events[evt]){
            return;
        }
        for(var i = 0; i < events[evt].length; i ++){
            events[evt][i].handler(args);
        }
    }

    function off(name){
        delete events[name]
    }

    return {
        on: on,
        fire: fire,
        off: off
    }
})()

EventCenter.on('mu_event', function(date){
    console.log('my_event received...');
});
EventCenter.on('my_event', function(date){
    console.log('my_event2 received...');
});
EventCenter.fire('my_event');
```